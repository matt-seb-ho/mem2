{
  "concepts": {
    "GCD Pair Parametrization": {
      "name": "GCD Pair Parametrization",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "gcd_val",
          "typing": "integer",
          "description": "The known greatest common divisor of the pair"
        },
        {
          "name": "factors",
          "typing": "pair of integers",
          "description": "The coprime coefficients a and b"
        }
      ],
      "description": "Representing two integers x, y with gcd(x, y) = g as x = g*a, y = g*b where gcd(a, b) = 1 to simplify GCD/LCM constraints.",
      "cues": [
        "Problem involves GCD or LCM of two unknown integers",
        "Need to enforce gcd(x, y) = g explicitly",
        "Constraints relate LCM to one of the numbers",
        "Problem involves finding integer pairs with specified GCD and LCM values.",
        "Constraints link the GCD and LCM of the unknown variables."
      ],
      "implementation": [
        "// Parametrize integers as x = gcd_val * a, y = gcd_val * b with gcd(a, b) = 1",
        "variable_num = gcd_val * a",
        "fixed_num = gcd_val * fixed_factor",
        "Represented variables as a = gcd_val * m and b = gcd_val * n.",
        "Reduced constraints to gcd(m, n) = 1 and m * n = lcm_val / gcd_val."
      ],
      "used_in": [
        "cmath_10550",
        "cmath_10998"
      ]
    },
    "Reverse Search for Maximum": {
      "name": "Reverse Search for Maximum",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "start_val",
          "typing": "integer",
          "description": "The maximum possible value to start searching from"
        },
        {
          "name": "condition",
          "typing": "predicate function",
          "description": "The boolean condition that the value must satisfy"
        }
      ],
      "description": "Iterating from the theoretical upper bound downwards to find the largest value satisfying a predicate, allowing early termination.",
      "cues": [
        "Objective is to maximize a discrete variable",
        "Search space is bounded and ordered",
        "Validity check is computationally feasible",
        "Objective is to find the largest value satisfying a condition",
        "Search space consists of discrete candidates that can be ordered",
        "Requirement to find the largest value satisfying conditions",
        "Existence of a calculable theoretical upper bound"
      ],
      "implementation": [
        "max_a = floor((upper_bound - 1) / gcd_val)",
        "For a from max_a down to 1:",
        "If gcd(a, fixed_factor) == 1: ... Return",
        "Step 4: Sorted divisors of 2001 in descending order",
        "Step 5: Iterated through candidates and returned the first valid n as the maximum size",
        "Computed max_n as floor(limit / multiplier) to establish search start",
        "Iterated n from max_n down to 1",
        "Returned immediately upon finding the first valid candidate"
      ],
      "used_in": [
        "cmath_10550",
        "cmath_5271",
        "cmath_5477"
      ]
    },
    "Coprimality Check": {
      "name": "Coprimality Check",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "num1",
          "typing": "integer",
          "description": "First integer"
        },
        {
          "name": "num2",
          "typing": "integer",
          "description": "Second integer"
        }
      ],
      "description": "Verifying two numbers are relatively prime by checking if their greatest common divisor is 1.",
      "cues": [
        "Constraint requires gcd(a, b) = 1",
        "Problem involves reduced fractions or coprime factors",
        "GCD parametrization introduces coprime coefficients",
        "Requirement for a modular inverse to exist",
        "Simplifying fractions or ratios in number theory problems",
        "Constraints involving divisibility or common factors between numbers",
        "Conditions requiring neighbors in a sequence to be relatively prime",
        "Condition involves gcd(x, n) == 1",
        "Checking for invertibility in modular arithmetic",
        "Derived variables must be relatively prime to satisfy GCD constraints.",
        "Predicate gcd(m, n) = 1 is explicitly required.",
        "verifying invertibility in modular arithmetic",
        "checking if gcd(a, m) = 1",
        "justifying division in congruences",
        "Constraint that a numerator must not be divisible by a specific prime (base of the denominator).",
        "Requirement for a canonical fraction representation.",
        "Application of Euler's Totient Theorem",
        "Modular inverse computation",
        "Modular inverse exists if and only if a and m are relatively prime",
        "Need to validate solvability before returning result"
      ],
      "implementation": [
        "If gcd(a, fixed_factor) == 1:",
        "Explicitly asserted `gcd == 1` after computing the extended GCD to validate the precondition for the modular inverse.",
        "Iterating through each adjacent pair (u, v) in the permutation",
        "Checking if gcd(u, v) > 1 to determine if the pair violates the coprimality condition",
        "Filtering the residue system into sets based on whether elements are relatively prime to the modulus",
        "Computed gcd(m, n) for each candidate factor pair.",
        "Filtered pairs where the greatest common divisor was not 1.",
        "Verifying gcd(2, 55) = 1 to validate dividing the congruence by 2",
        "Ensured the numerator m and the base 3 are relatively prime (gcd(m, 3) = 1) to define the unique form m / 3^n.",
        "Implicitly verified gcd(19, 25) == 1 to ensure validity of exponent reduction",
        "Checks `If g != 1` to verify gcd(a, m) == 1",
        "Returns \"No Inverse\" if the coprimality condition fails"
      ],
      "used_in": [
        "cmath_10550",
        "cmath_10774",
        "cmath_10816",
        "cmath_10993",
        "cmath_10998",
        "cmath_11055",
        "cmath_2167",
        "cmath_5177",
        "cmath_5195"
      ]
    },
    "Double Factorial": {
      "name": "Double Factorial",
      "kind": "definition",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The non-negative integer to compute the double factorial for"
        }
      ],
      "description": "Product of integers from n down to 1 or 2 with a step of 2, denoted as n!!",
      "cues": [
        "double exclamation mark notation",
        "product of integers with same parity",
        "skipping every other integer in multiplication"
      ],
      "implementation": [
        "Defined via recursive function DoubleFactorial(n)",
        "Base case returns 1 for n <= 1",
        "Recursive step multiplies n by DoubleFactorial(n - 2)"
      ],
      "used_in": [
        "cmath_10564"
      ]
    },
    "Modular Arithmetic": {
      "name": "Modular Arithmetic",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "modulus",
          "typing": "integer",
          "description": "The prime number p defining the field Z_p"
        }
      ],
      "description": "Performing arithmetic operations within a fixed range defined by a modulus",
      "cues": [
        "finding the last digit",
        "finding the remainder",
        "large numbers requiring reduction",
        "cyclic patterns",
        "Problem involves operations modulo n",
        "Existence of modular inverses is specified or required",
        "Congruence relations are used",
        "Operations specified as \"mod p\"",
        "Requirement to compute modular inverses",
        "Prime modulus constraint",
        "Problem involves residues modulo n",
        "Operations defined within a finite ring Z_n",
        "congruence relations (\u2261)",
        "modulus operations",
        "residue normalization",
        "Operations constrained within a fixed range defined by a modulus.",
        "Expressions involving \"mod p\" or congruences.",
        "Divisibility condition involving a specific integer (7)",
        "Use of congruence notation or modulo operator",
        "Conditions involving divisibility or remainders",
        "Relationships between elements defined by congruence",
        "S(k) \u2262 0 (mod 200)",
        "Checking divisibility conditions",
        "Congruence relationships between values",
        "Request for remainder or last N digits",
        "Large numbers requiring reduction",
        "Large integers in modular context",
        "Simplification of operands",
        "Constraint involving remainders or divisibility by a modulus",
        "Condition expressed as congruence",
        "units digit",
        "last digit",
        "modulo 10",
        "remainder calculation"
      ],
      "implementation": [
        "Applied MOD 10 to the final total_sum to extract the last digit",
        "Established the domain for all calculations (mod n)",
        "Validated the existence of inverses for (ab) and (a+b)",
        "Applied inverse property x * x^(-1) \u2261 1 to cancel terms",
        "Used to define the domain for all additions and multiplications",
        "Applied to the final summation result",
        "Context for computing k^(-1) and (k+1)^(-1)",
        "Defining the search space as the complete residue system {0, 1, ..., n-1}",
        "Simplifying the congruence 2r \u2261 -3 (mod 55)",
        "Normalizing -3 to 52 mod 55",
        "Solving the linear congruence by dividing by 2",
        "Computed residue r = (n^2) mod p.",
        "Used modulus p = 11 for all calculations.",
        "Evaluate the polynomial expression `P(n)` modulo 7",
        "Verify if the result is congruent to 0 to satisfy the divisibility constraint",
        "Step 2: Deduced all elements are congruent modulo (n-1) based on the integer average condition",
        "Step 3: Applied congruence property to specific elements 1 and 2002 to establish 2002 \u2261 1 (mod n-1)",
        "Uses the modulo operator to check if the sum of squares is divisible by 200.",
        "Reduces the divisibility condition to a congruence relation.",
        "Verifying that the difference between the expected digit sum (S_n + 1) and the candidate option is divisible by 9",
        "Returning total_sum mod 1000",
        "Reduced base 333 modulo 11 to 3",
        "Applied before exponentiation",
        "Verified candidate % modulus == remainder for each generated multiple",
        "Set modulus to 10 to extract the units digit of the Fermat number.",
        "Performed final addition and modulo operation to ensure result is within [0, 9]."
      ],
      "used_in": [
        "cmath_10564",
        "cmath_10942",
        "cmath_10978",
        "cmath_10993",
        "cmath_11055",
        "cmath_4845",
        "cmath_4974",
        "cmath_5271",
        "cmath_5274",
        "cmath_5334",
        "cmath_5349",
        "cmath_5421",
        "cmath_5477",
        "cmath_5543"
      ]
    },
    "Iterative Accumulation": {
      "name": "Iterative Accumulation",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "sequence",
          "typing": "list",
          "description": "The collection of values to iterate over."
        },
        {
          "name": "accumulator",
          "typing": "variable",
          "description": "The variable storing the running sum or product"
        },
        {
          "name": "start",
          "typing": "integer",
          "description": "Starting value of the loop counter"
        },
        {
          "name": "end",
          "typing": "integer",
          "description": "Ending value of the loop counter"
        },
        {
          "name": "update_rule",
          "typing": "function",
          "description": "The function applied to the current element to update the sum"
        },
        {
          "name": "operation",
          "typing": "function",
          "description": "The transformation applied to each element before accumulation."
        }
      ],
      "description": "Accumulating a result by iterating through a sequence of values and updating a running total",
      "cues": [
        "sum of a series",
        "total value",
        "loop over a range",
        "running total",
        "Aggregating counts from independent components",
        "Combinatorial product of choices",
        "Problem asks for the sum of valid solutions",
        "Solution involves a loop updating a running total",
        "Solution requires combining results from multiple independent components (prime factors)",
        "A running total or product is updated in a loop",
        "Aggregating results from a sequence of independent choices",
        "Computing a total count or product from individual component counts",
        "Loop structure \"For each integer k from...\"",
        "Initialization of a sum variable S = 0",
        "Update step S = (S + Term) mod p",
        "Looping through a list of values to compute an aggregate",
        "Sequential processing of independent components",
        "Summing results over a range of integer parameters",
        "Loop iterates through a range of parameter values",
        "Running total is updated in each iteration",
        "Final answer is sum of contributions from each case",
        "Summing counts over a range of cases",
        "Loop structure with a running total variable",
        "Computing a total sum or aggregate from a sequence of contributions",
        "Building a frequency map or histogram from input data",
        "Sum(D)",
        "Calculate digit_sum",
        "Computing an aggregate value (product) over a set of enumerated items (divisors).",
        "Updating a running value as items are processed.",
        "running total variable",
        "summing values from a sequence",
        "loop with accumulator update",
        "The solution requires computing a total by summing a sequence of computed terms.",
        "A loop structure is used to traverse a range of integer values.",
        "summing values",
        "aggregating results over a sequence"
      ],
      "implementation": [
        "Initialized total_sum = 0",
        "Iterated odd integers i from 1 to 49",
        "Updated total_sum += DoubleFactorial(i) in each step",
        "Initialized total_count to 1 (multiplicative identity)",
        "Multiplied num_even_choices for each prime factor into the running total",
        "Initialize ValidSum = 0",
        "Iterate through candidate values (divisors)",
        "If condition met (x is integer), add x to ValidSum",
        "Return ValidSum",
        "Initialized cube_divisor_count = 1",
        "Iterated through each prime exponent and updated the count by multiplying valid choices",
        "Initialized `TotalCombinations` to 1",
        "Iterated through each prime exponent's valid choice count and updated the running product (`TotalCombinations = TotalCombinations * NumValidChoices`)",
        "Iterates k from 1 to p-2",
        "Computes the term (inv_k * inv_k1) mod p for each k",
        "Updates the running sum S modulo p at each step",
        "Iterating through `item_counts` to update `total_combinations` via multiplication",
        "Accumulating the sum of Stirling numbers for i from 1 to k",
        "Loop k from 1 to n-1",
        "total_count = total_count + ways in each valid iteration",
        "Sum contributions across all valid subset sizes",
        "Initialize total_count = 0",
        "Update total_count = total_count + ways_to_choose_prefix inside the loop",
        "Summing the weighted exponents of each prime factor into a global map across all terms in the product expression",
        "Aggregating the extracted digits into a single scalar value",
        "Using the accumulated sum as the metric for the stopping condition",
        "Step `Compute product P = \u220f_{d in D} d` accumulates the product of divisors.",
        "Initializes product implicitly (identity 1) and multiplies by each divisor.",
        "Variable total_k accumulates the sum of valuations across the sequence.",
        "Updates total_k <- total_k + CountPrimeValuation(n, 3) in each iteration.",
        "Initializes `total_ways` to 0.",
        "Iterates `i` from 0 to `num_targets` to generate each term of the inclusion-exclusion sum.",
        "Updates `total_ways` by adding the current `term` in each iteration.",
        "Accumulates the total count of trailing zeros across multiple factorial values (100!, 200!, 300!).",
        "Initializes a total counter to zero and adds the result of the Legendre count for each N."
      ],
      "used_in": [
        "cmath_10564",
        "cmath_10630",
        "cmath_10664",
        "cmath_10860",
        "cmath_10934",
        "cmath_10978",
        "cmath_1854",
        "cmath_2027",
        "cmath_2147",
        "cmath_2476",
        "cmath_4681",
        "cmath_4689",
        "cmath_5240",
        "cmath_5295",
        "cmath_9112",
        "cmath_9126"
      ]
    },
    "base_digit_range_formula": {
      "name": "base_digit_range_formula",
      "kind": "formula",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "num_digits",
          "typing": "integer",
          "description": "The number of digits in the representation"
        },
        {
          "name": "base",
          "typing": "integer",
          "description": "The base of the number system"
        }
      ],
      "description": "Determines the minimum and maximum base-10 integer values representable by a number with a specific count of digits in a given base.",
      "cues": [
        "n-digit number in base b",
        "range of values for a specific base representation",
        "smallest/largest number with n digits",
        "Problem specifies numbers with a fixed number of digits in a specific base (e.g., 3-digit base 5)",
        "Need to determine the range of base-10 integer values these representations correspond to",
        "4-digit base-8 integer",
        "decimal range",
        "Smallest 4-digit base-8 number",
        "Largest 4-digit base-8 number",
        "calculating maximum representable value",
        "sum of base powers",
        "digit count constraints"
      ],
      "implementation": [
        "Used in `get_base_range` to compute `min_val` as `base^(num_digits - 1)`.",
        "Used in `get_base_range` to compute `max_val` as `base^num_digits - 1`.",
        "Applied to find ranges for 4-digit base-3 and 2-digit base-6 numbers.",
        "Calculated min_5 and max_5 for 3-digit base 5 numbers (100_5 to 444_5)",
        "Calculated min_8 and max_8 for 2-digit base 8 numbers (10_8 to 77_8)",
        "Computed min_val as 8^(4-1) to find the smallest decimal value.",
        "Computed max_val as 8^4 - 1 to find the largest decimal value.",
        "Computed `max_val` by summing `base^i` for `i` from 0 to `powers_count - 1`, corresponding to the maximum value with all coefficients set to 1."
      ],
      "used_in": [
        "cmath_10590",
        "cmath_10822",
        "cmath_5075",
        "cmath_5330"
      ]
    },
    "interval_intersection_logic": {
      "name": "interval_intersection_logic",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "interval1",
          "typing": "tuple (start, end)",
          "description": "First range boundaries"
        },
        {
          "name": "interval2",
          "typing": "tuple (start, end)",
          "description": "Second range boundaries"
        }
      ],
      "description": "Computes the overlapping range between two closed intervals [a, b] and [c, d].",
      "cues": [
        "satisfies multiple range constraints",
        "values common to two sets",
        "intersection of conditions",
        "simultaneous constraints",
        "Multiple independent constraints each define a valid range of integers",
        "Solution requires finding values that satisfy all range constraints simultaneously"
      ],
      "implementation": [
        "Calculated `intersection_start` using `MAX` of lower bounds.",
        "Calculated `intersection_end` using `MIN` of upper bounds.",
        "Checked validity with `intersection_start <= intersection_end`.",
        "Computed valid_min as max(min_5, min_8)",
        "Computed valid_max as min(max_5, max_8)"
      ],
      "used_in": [
        "cmath_10590",
        "cmath_10822"
      ]
    },
    "arithmetic_progression_mean": {
      "name": "arithmetic_progression_mean",
      "kind": "identity",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "start",
          "typing": "integer",
          "description": "The first integer in the sequence"
        },
        {
          "name": "end",
          "typing": "integer",
          "description": "The last integer in the sequence"
        }
      ],
      "description": "The mean of a finite set of consecutive integers is equal to the average of the first and last terms.",
      "cues": [
        "average of integers in a range",
        "mean of consecutive numbers",
        "sum of arithmetic sequence",
        "consecutive integers",
        "Problem asks for the average of a set of integers",
        "The set of valid integers forms a consecutive sequence (arithmetic progression with difference 1)"
      ],
      "implementation": [
        "Computed `average` as `(intersection_start + intersection_end) / 2`.",
        "Avoided explicit summation or counting of elements in the intersection.",
        "Calculated result as (valid_min + valid_max) / 2 instead of summing all elements"
      ],
      "used_in": [
        "cmath_10590",
        "cmath_10822"
      ]
    },
    "Base-b Polynomial Representation": {
      "name": "Base-b Polynomial Representation",
      "kind": "algebraic manipulation",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "digits",
          "typing": "list of integers",
          "description": "The sequence of digits d_n...d_0 representing the number."
        },
        {
          "name": "base_variable",
          "typing": "symbol",
          "description": "The variable representing the unknown base (e.g., b)."
        }
      ],
      "description": "Interpreting a number represented by digits in an unknown base b as a polynomial expression in b, where each digit is a coefficient corresponding to a power of b.",
      "cues": [
        "Problem involves arithmetic with numbers written in an unspecified or variable base.",
        "Digits are explicitly given in the problem statement.",
        "Numbers represented with digits in an unspecified base (e.g., $121_c$)",
        "Equations involving numbers in different bases",
        "base-3 representation contains only digits 0 and 1",
        "T_n = \u03a3(b_i * 3^i)",
        "sums of distinct powers of 3",
        "Constructing an integer value from a sequence of digits",
        "Positional notation (ones, tens, hundreds)"
      ],
      "implementation": [
        "Step 3: Convert each number from base-b representation to a polynomial in b (e.g., digits d_n...d_0 map to sum(d_i * b^i)).",
        "Converted $121_c$ to polynomial $1 \\cdot c^2 + 2 \\cdot c + 1$",
        "Converted base-$b$ number to polynomial $7 \\cdot b + 1$",
        "Expressed the nth term T_n as a polynomial in base 3 with binary coefficients",
        "Calculated the sum of 3^i for every position i where the ith bit of n is 1",
        "Computing value = 100 * d1 + 10 * d2 + d3 for base 10"
      ],
      "used_in": [
        "cmath_10600",
        "cmath_10695",
        "cmath_5236",
        "cmath_5349"
      ]
    },
    "Minimum Valid Base Constraint": {
      "name": "Minimum Valid Base Constraint",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "digits",
          "typing": "set of integers",
          "description": "All unique digits appearing in the numbers within the problem."
        }
      ],
      "description": "A constraint determining the lower bound for a valid base, which must be strictly greater than the largest digit value appearing in the number representations.",
      "cues": [
        "The base of the number system is unknown.",
        "Numbers are represented using standard positional notation digits.",
        "base representation",
        "digit value",
        "validity check",
        "Variables representing numerical bases",
        "Solutions to equations that yield multiple candidates (e.g., quadratic roots)",
        "base b",
        "3-digit numbers",
        "distinct digits requirement"
      ],
      "implementation": [
        "Step 1: Identify the maximum digit D present in all numbers within the equation.",
        "Step 2: Set the minimum valid base b_min = D + 1.",
        "APPLY CONSTRAINT: Base b must be strictly greater than digit d (b > 3)",
        "FILTER: Valid Bases = {b in D | b > d}",
        "Filtered quadratic roots to select positive integer value for base $c$",
        "Ensured base satisfies fundamental validity requirements ($c > 0$)",
        "Established lower bound b=3 for iteration since 3 distinct digits require at least values 0, 1, 2",
        "Ensured base is large enough to support the required number of distinct digits"
      ],
      "used_in": [
        "cmath_10600",
        "cmath_10637",
        "cmath_10695",
        "cmath_4869"
      ]
    },
    "Integer Base Enumeration": {
      "name": "Integer Base Enumeration",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "start_value",
          "typing": "integer",
          "description": "The minimum valid base to start the search from."
        },
        {
          "name": "condition",
          "typing": "boolean function",
          "description": "The algebraic equation or logical condition that must evaluate to true."
        }
      ],
      "description": "A search strategy for finding an unknown integer base by iterating through candidate values starting from a valid lower bound and checking for satisfaction of the problem conditions.",
      "cues": [
        "The unknown variable is a base (implied to be a small integer).",
        "An algebraic equation involving the base has been constructed.",
        "Analytic solution of the polynomial may be difficult or unnecessary.",
        "find base b",
        "equation N(b) = 100",
        "small search space"
      ],
      "implementation": [
        "Step 5: Iterate integer b starting from b_min upwards.",
        "Step 6: Evaluate the equation for each b.",
        "Step 7: Return the first b where the equation holds true.",
        "Iterated integer b starting from 3",
        "Evaluated N(b) at each step until it equaled 100"
      ],
      "used_in": [
        "cmath_10600",
        "cmath_4869"
      ]
    },
    "Cartesian Product Enumeration": {
      "name": "Cartesian Product Enumeration",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "base_set",
          "typing": "set",
          "description": "The set of values to pick from"
        },
        {
          "name": "length",
          "typing": "int",
          "description": "The number of elements to pick"
        }
      ],
      "description": "Generating all ordered tuples of a fixed length from a base set, allowing repetition.",
      "cues": [
        "pick n items from a set",
        "with replacement",
        "ordered sequences",
        "all possible outcomes",
        "Composite object formed from independent components",
        "Fixed number of components (rows) per object",
        "Search space constructed from combinations of pre-validated parts"
      ],
      "implementation": [
        "Generate all outcomes via Cartesian_Product(value_set, repeat=pick_count)",
        "Generating all candidate matrices by taking the Cartesian product of the set of valid rows"
      ],
      "used_in": [
        "cmath_10604",
        "cmath_2100"
      ]
    },
    "Set Deduplication": {
      "name": "Set Deduplication",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "values",
          "typing": "iterable",
          "description": "The sequence of values to deduplicate"
        }
      ],
      "description": "Using a set data structure to store results of a transformation to automatically filter duplicates, useful for identifying distinct outcomes.",
      "cues": [
        "distinct values",
        "unique sums",
        "ensure uniqueness",
        "how many different results",
        "Multiple inputs may map to the same output value.",
        "Only unique results are needed for aggregation.",
        "Goal is to count the number of *unique* or *distinct* outcomes.",
        "Multiple different inputs (subsets) may produce the same output (sum)."
      ],
      "implementation": [
        "Map each outcome to its sum",
        "Store sums in a Set to ensure uniqueness",
        "Initialized set quadratic_residues = {}.",
        "Added r to quadratic_residues to automatically handle duplicates (e.g., n and p-n yield same square).",
        "Initialized an empty set $U$ specifically to store unique sums.",
        "Inserted each computed subset sum into $U$, relying on the set data structure's property to automatically filter duplicates.",
        "Returned the cardinality of $U$ as the final answer."
      ],
      "used_in": [
        "cmath_10604",
        "cmath_4845",
        "cmath_9094"
      ]
    },
    "Summation of Distinct Values": {
      "name": "Summation of Distinct Values",
      "kind": "calculation method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "distinct_values",
          "typing": "set",
          "description": "The set of unique numbers to sum"
        }
      ],
      "description": "Calculating the arithmetic sum of all unique values in a collection.",
      "cues": [
        "sum of all distinct",
        "total of unique values",
        "Problem asks for the sum of all valid solutions",
        "Solution set consists of unique values derived from distinct candidates",
        "Aggregating values from a collection of unique elements.",
        "Problem asks for the sum of distinct outcomes.",
        "Sum all possible integer values",
        "total_sum",
        "range of digit counts",
        "Final answer requires the sum of the collected valid numbers.",
        "The collected numbers are distinct by virtue of the search process."
      ],
      "implementation": [
        "Compute final answer as the Sum of all elements in the Set",
        "Computed the arithmetic sum of all valid integer values of n obtained from the valid divisors",
        "Calculated m = sum of elements in quadratic_residues.",
        "Iterated from min_d to max_d inclusive.",
        "Accumulated each integer d into total_sum.",
        "Step `Return sum of elements in nice_numbers`.",
        "Aggregates the list of 10 found \"nice numbers\" into a single sum."
      ],
      "used_in": [
        "cmath_10604",
        "cmath_4759",
        "cmath_4845",
        "cmath_5075",
        "cmath_5240"
      ]
    },
    "Product of Divisors Formula": {
      "name": "Product of Divisors Formula",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The number whose divisors are being multiplied"
        },
        {
          "name": "x",
          "typing": "integer",
          "description": "The total count of divisors of n"
        }
      ],
      "description": "The product of all positive divisors of an integer n is n raised to the power of half the count of its divisors.",
      "cues": [
        "product of divisors",
        "divisor count",
        "exponent involving divisor count"
      ],
      "implementation": [
        "Used to establish the initial exponent x/2 for the product of all divisors in Step 1"
      ],
      "used_in": [
        "cmath_10610"
      ]
    },
    "Proper Divisor Product Relation": {
      "name": "Proper Divisor Product Relation",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Relates the product of proper divisors to the product of all divisors by dividing by the number itself.",
      "cues": [
        "proper divisors",
        "product excluding the number itself",
        "adjustment of divisor product"
      ],
      "implementation": [
        "Applied in Step 2 to adjust the exponent from x/2 to (x-2)/2 by dividing by n"
      ],
      "used_in": [
        "cmath_10610"
      ]
    },
    "Equating Coefficients": {
      "name": "Equating Coefficients",
      "kind": "algebraic manipulation",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Method for solving parameters in an identity by matching the coefficients of corresponding powers of the variable on both sides.",
      "cues": [
        "identity in a variable",
        "unknown parameters in linear or polynomial expressions",
        "equation holding for all valid values of a variable"
      ],
      "implementation": [
        "Applied in Step 4 to derive relationships between a, b, and c by matching coefficients of x and constant terms"
      ],
      "used_in": [
        "cmath_10610"
      ]
    },
    "GCD Normalization": {
      "name": "GCD Normalization",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "ratio",
          "typing": "list of integers",
          "description": "The proportional values derived from equations"
        },
        {
          "name": "target_gcd",
          "typing": "integer",
          "description": "The desired greatest common divisor"
        }
      ],
      "description": "Process of scaling a set of proportional integers to satisfy a greatest common divisor constraint, typically gcd=1.",
      "cues": [
        "gcd constraint on parameters",
        "integer solution required",
        "ratio of parameters determined"
      ],
      "implementation": [
        "Used in Step 5 to select the specific integer values a=1, b=-2, c=2 from the ratio 1:-2:2"
      ],
      "used_in": [
        "cmath_10610"
      ]
    },
    "Divisor Count Structure": {
      "name": "Divisor Count Structure",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "target_divisors",
          "typing": "integer",
          "description": "The exact number of divisors the integer must have"
        }
      ],
      "description": "Characterizes the prime factorization form of an integer based on its total number of divisors using the divisor function formula tau(n).",
      "cues": [
        "exactly N factors",
        "number of divisors",
        "divisor count",
        "Problem specifies a count of divisors (total or restricted).",
        "Need to determine the structure of the number (prime exponents) from the count.",
        "Relationship between prime factorization exponents and total divisor count is needed.",
        "exact number of divisors specified",
        "infer number form from divisor count"
      ],
      "implementation": [
        "Determined that n must be p^3 or p*q to have exactly 4 factors",
        "Used to infer total divisor count D by adding 2 to the restricted count (accounting for 1 and N).",
        "Applied the relation tau(N) = product(e_i + 1) to derive prime exponents from factors of D.",
        "Validated that candidate numbers constructed from exponents satisfy the divisor count requirement.",
        "Deduced that numbers with exactly 3 factors must be squares of primes (p^2)"
      ],
      "used_in": [
        "cmath_10619",
        "cmath_5475",
        "cmath_5532"
      ]
    },
    "Constructive Enumeration": {
      "name": "Constructive Enumeration",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "primitives",
          "typing": "list",
          "description": "Fundamental elements to build from (e.g., list of primes)"
        },
        {
          "name": "construction_rules",
          "typing": "list",
          "description": "Mathematical forms to apply to primitives (e.g., p^3, p*q)"
        }
      ],
      "description": "Generates valid instances by composing fundamental building blocks (e.g., primes) according to structural rules instead of brute-force checking.",
      "cues": [
        "smallest k numbers with property",
        "generate candidates",
        "find integers satisfying condition",
        "generate sequence",
        "structural rules",
        "recurrence relation",
        "valid instance generation",
        "The solution space consists of discrete structural configurations (e.g., partitions).",
        "Objective is to find an optimal value (min/max) among valid configurations.",
        "Search space is defined by structural constraints rather than a numeric range.",
        "Problem requires generating valid instances (subsets) based on structural rules (fixed cardinality).",
        "Need to compute a derived value (sum) for each generated instance."
      ],
      "implementation": [
        "Iterated over primes to generate p^3",
        "Iterated over prime pairs to generate p*q",
        "Used a while loop to append values to `sequence` based on the recurrence rule instead of checking all subsets.",
        "Generated all multiplicative partitions of the total divisor count D.",
        "Constructed candidate integers for each partition configuration.",
        "Iterated through all valid structures to identify the global minimum.",
        "Iterated through cardinalities $k$ from 2 to $|S|$.",
        "Generated all subsets $C$ of size $k$ from the input set $S$.",
        "Computed the sum for each subset to form the collection of candidate values."
      ],
      "used_in": [
        "cmath_10619",
        "cmath_2114",
        "cmath_5475",
        "cmath_9094"
      ]
    },
    "K-Smallest Aggregation": {
      "name": "K-Smallest Aggregation",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "k",
          "typing": "integer",
          "description": "Count of extreme values to select"
        },
        {
          "name": "aggregation_func",
          "typing": "function",
          "description": "Function to apply to selected subset (e.g., sum, product)"
        }
      ],
      "description": "Selects the k extreme values from a generated set and computes an aggregate value over them.",
      "cues": [
        "sum of smallest",
        "first k",
        "minimum k values"
      ],
      "implementation": [
        "Sorted all candidates in ascending order",
        "Selected the first k candidates",
        "Computed the sum of selected candidates"
      ],
      "used_in": [
        "cmath_10619"
      ]
    },
    "Direct Enumeration": {
      "name": "Direct Enumeration",
      "kind": "algorithm",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "start",
          "typing": "int",
          "description": "The starting integer of the range."
        },
        {
          "name": "end",
          "typing": "int",
          "description": "The ending integer of the range."
        },
        {
          "name": "operation",
          "typing": "function",
          "description": "The logic applied to each element in the range."
        },
        {
          "name": "search_variable",
          "typing": "integer",
          "description": "The variable being incremented to search for a solution"
        },
        {
          "name": "start_value",
          "typing": "integer",
          "description": "The initial value for the search variable"
        },
        {
          "name": "search_space",
          "typing": "set or sequence",
          "description": "The finite set of candidates to enumerate."
        }
      ],
      "description": "Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.",
      "cues": [
        "Small search space size (e.g., less than 1000 elements)",
        "Problem specifies a concrete range of integers to analyze",
        "Small bounded search space for integer variables",
        "Linear constraint reduces degrees of freedom to one variable",
        "Need to find all or one valid integer solution",
        "Small finite search space (e.g., permutations of a small set of digits)",
        "Requirement to verify a global property across all possible configurations",
        "Search space is finite and small (e.g., n=16)",
        "No closed-form formula immediately applied",
        "Finite and manageable search space (e.g., 3-digit numbers 100-999)",
        "Problem requires checking a condition for every element in a range",
        "Finite search space for sub-components",
        "Local constraint verification required before assembly",
        "Small finite search space for a decision variable",
        "Iterating through all possible counts of an item",
        "FindSmallestN",
        "Initialize n = 1",
        "Loop",
        "Increment n",
        "Return n",
        "Finite search space defined by a target value",
        "Iterating through integers to verify a condition",
        "Problem asks for the smallest or first integer satisfying a condition",
        "No closed-form solution is immediately apparent",
        "Finite search space defined by a modulus or bound.",
        "Requirement to check every candidate in a range.",
        "Finite search space for variables (e.g., a from 1 to sqrt(n))",
        "Need to verify a condition for each candidate",
        "Finite range of integer inputs specified (2 to 100)",
        "Requirement to check a property for each value in the range",
        "Iterating through candidate integers starting from a lower bound (n=2).",
        "Search terminates when a specific count of valid instances (10) is reached.",
        "finite search space",
        "iterating through every element",
        "explicit check or computation for each candidate",
        "Iterating through a provided list of candidate values",
        "Finite search space for valid parameters",
        "Finite search space",
        "Verifying conditions for each element",
        "Small finite search space allowing full iteration",
        "Problem requires aggregating over all valid configurations",
        "Finite, manageable search space of small integers to test",
        "Need to generate specific instances to verify or bound a general property",
        "finite set of inputs",
        "checking specific cases",
        "iterating through a list"
      ],
      "implementation": [
        "Loop `For each integer m from 1 to 99`",
        "Iterated through positive integer values for m",
        "For each m, calculated c = (12 - 3m) / 2 and checked if c is a positive integer",
        "Stopped when valid solution found and computed n = m + c",
        "Generating all permutations P of the digit set D = {1, 2, 3, 4, 5, 6}",
        "Iterating through each permutation p in P to check validity",
        "Iterating through every element in the residue system to compute sums A and B",
        "DEFINE domain D = {n | 100 <= n <= 999}",
        "FOR each n IN D",
        "Iterating through all possible row configurations to identify and store those satisfying the row sum constraint",
        "FOR num_E FROM 0 TO count_E",
        "Iterating through integer values of n starting from 1",
        "Checking the digit sum condition at each step",
        "Terminating immediately upon finding the first valid n",
        "Looping through integers \u03bd from 1 to Target_LCM",
        "Iterating n starting from 1 upwards (n <- n + 1) until the condition on divisor count is met",
        "Loop For n from 1 to p - 1 covers all non-zero residues.",
        "Iterating variable a from 1 to floor(sqrt(n)) to check for valid pairs",
        "Iterating variable n from 1 upwards to find the first valid integer",
        "Loop structure `For n from 2 to 100` iterates through all candidate integers",
        "Each integer `n` is individually processed to evaluate the polynomial",
        "Outer loop `While length(nice_numbers) < 10` iterates `n` upwards.",
        "Checks each candidate `n` against the problem condition.",
        "Iterates through every exponent k from 0 to 4000 to check the condition for 9^k.",
        "Loop iterates through each of the first 100 odd integers explicitly.",
        "Search space is small enough (100 elements) to allow brute-force summation.",
        "Looping through 'options' to find the first value satisfying the digit sum transition constraints",
        "Iterating through x and y within determined bounds to check the equation",
        "Iterating through all ordered triples from Permutations(D, 3)",
        "Iterated through small integer inputs (SmallestCompositeIntegers) to generate specific instances of the polynomial value",
        "Iterates through the specific list of integers [100, 200, 300] to apply the counting function.",
        "Treats the given values as a manageable search space for aggregation."
      ],
      "used_in": [
        "cmath_10621",
        "cmath_10731",
        "cmath_10816",
        "cmath_10993",
        "cmath_1988",
        "cmath_2100",
        "cmath_2432",
        "cmath_4689",
        "cmath_4733",
        "cmath_4818",
        "cmath_4845",
        "cmath_4949",
        "cmath_4974",
        "cmath_5240",
        "cmath_5246",
        "cmath_5295",
        "cmath_5334",
        "cmath_5342",
        "cmath_5349",
        "cmath_5540",
        "cmath_9126"
      ]
    },
    "GCD Computation": {
      "name": "GCD Computation",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "a",
          "typing": "int",
          "description": "The first integer."
        },
        {
          "name": "b",
          "typing": "int",
          "description": "The second integer."
        }
      ],
      "description": "Calculating the greatest common divisor of two integers to analyze their divisibility relationship.",
      "cues": [
        "Problem involves common factors, simplification, or divisibility",
        "Explicit mention of gcd or greatest common divisor",
        "reducing fractions to irreducible form",
        "analyzing divisibility relationship",
        "Need to find the common divisor of multiple generated values",
        "Determining the greatest integer satisfying multiple divisibility constraints"
      ],
      "implementation": [
        "Compute `g = gcd(m, 100)`",
        "Used to reduce probability fraction to irreducible form m/n.",
        "Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)"
      ],
      "used_in": [
        "cmath_10621",
        "cmath_2190",
        "cmath_5540"
      ]
    },
    "Conditional Counting": {
      "name": "Conditional Counting",
      "kind": "counting method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "predicate",
          "typing": "boolean function",
          "description": "The condition elements must satisfy to be counted"
        },
        {
          "name": "initial_value",
          "typing": "int",
          "description": "The starting value of the counter."
        },
        {
          "name": "domain",
          "typing": "set",
          "description": "The set of elements to iterate over"
        }
      ],
      "description": "Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.",
      "cues": [
        "Question asks \"how many\" or \"find the number of\"",
        "Solution involves a counter variable and an if-statement",
        "filtering set",
        "counting valid items",
        "boolean predicate",
        "Need to verify solutions satisfy multiple constraints",
        "Boolean predicate determines validity of candidate solutions",
        "Problem asks for the total number of configurations satisfying a specific property",
        "Solution involves accumulating a total based on a boolean predicate",
        "Goal is to compute the total number of valid solutions.",
        "Validity depends on satisfying multiple boolean predicates.",
        "Goal is to count the number of elements satisfying a specific property",
        "Logic involves a boolean predicate inside an iteration",
        "Problem asks for a total count of valid configurations",
        "Global constraints must be verified on generated candidates",
        "Accumulating a total only when elements satisfy specific boolean predicates",
        "Loop with conditional check before adding to total",
        "Accumulating total count based on validity conditions",
        "Filtering valid configurations before summing",
        "Counting elements that satisfy a boolean predicate over a range",
        "Accumulating a total based on a condition",
        "Counting the number of elements satisfying a property",
        "Checking if a count meets a threshold",
        "Accumulating a total based on a boolean predicate",
        "Counting solutions to an equation",
        "Goal is to determine the number of values satisfying a condition",
        "Presence of a counter variable and a conditional increment",
        "Counting objects that satisfy a specific constraint (in this case, being a sum of a subset with size $\\ge 2$).",
        "The counting happens implicitly by only adding valid results to the collection."
      ],
      "implementation": [
        "Initialize `count` to 0",
        "If `g` is a single-digit number: Increment `count`",
        "FILTER: Valid Bases = {b in D | b > d}",
        "OUTPUT: Count of Valid Bases",
        "Checked if c is a positive integer before accepting the (m, c) pair",
        "Only computed family size n when both m and c satisfied positivity and integrality constraints",
        "Initializing valid_count = 0",
        "Incrementing valid_count only if is_valid remains True after checking all adjacent pairs",
        "Initialized a counter and incremented only for valid pairs.",
        "Applied ordering check m < n to ensure unique pair counting.",
        "IF d2 > d1 AND d2 > d3: count <- count + 1",
        "RETURN count",
        "Incrementing a counter only when a generated matrix satisfies the column sum constraints",
        "total_count accumulates ways only when size_A != size_B",
        "Skip iteration when constraints become contradictory (size_A == size_B)",
        "IF num_M is integer AND 0 <= num_M <= count_M: total_ways += ...",
        "Initialized count to 0",
        "Incremented count only when denominator had prime factors other than 2 or 5",
        "Iterated through n from 1 to 100 to check each fraction",
        "Calculating |D|, the count of divisors of n^2 - n that are less than or equal to n, and checking if 0 < |D| < n",
        "Incrementing count only when b_squared is a perfect square",
        "Adding 1 or 2 to the count based on whether a == b",
        "Initialize `count = 0` before the loop",
        "Execute `count = count + 1` only when the condition `P(n) \u2261 0 (mod 7)` is true",
        "Accumulates the total by incrementing a counter only when the leading digit equals 9.",
        "Incrementing solution_count only when 2^(2*x) - 3^(2*y) == 55",
        "The loop structure implicitly filters for subsets with cardinality $k \\in [2, |S|]$.",
        "The final count $|U|$ represents the total number of distinct values satisfying the condition of being a sum of such a subset."
      ],
      "used_in": [
        "cmath_10621",
        "cmath_10637",
        "cmath_10731",
        "cmath_10816",
        "cmath_10998",
        "cmath_1988",
        "cmath_2100",
        "cmath_2147",
        "cmath_2432",
        "cmath_4771",
        "cmath_4818",
        "cmath_4949",
        "cmath_4974",
        "cmath_5246",
        "cmath_5342",
        "cmath_9094"
      ]
    },
    "LCM Valuation Identity": {
      "name": "LCM Valuation Identity",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "The p-adic valuation of the least common multiple of two numbers is the maximum of their individual p-adic valuations.",
      "cues": [
        "Problem involves LCM or GCD operations",
        "Equation relates multiples or divisors",
        "Need to simplify LCM expressions algebraically"
      ],
      "implementation": [
        "Applied property v_p(lcm(x, y)) = max(v_p(x), v_p(y)) to transform the LCM equation into exponent equations."
      ],
      "used_in": [
        "cmath_10627"
      ]
    },
    "Valuation Analysis": {
      "name": "Valuation Analysis",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "p",
          "typing": "prime",
          "description": "The prime base for the valuation."
        },
        {
          "name": "n",
          "typing": "integer",
          "description": "The number to analyze for prime valuation."
        }
      ],
      "description": "Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.",
      "cues": [
        "Equations involving multiplication, division, LCM, or GCD",
        "Constants given as powers or easily factorizable",
        "Unknowns appear in multiplicative contexts",
        "Counting divisors with specific properties",
        "Constraints on prime exponents",
        "Prime factorization given or computable",
        "Problem involves properties of divisors dependent on prime exponents",
        "Need to analyze divisibility conditions on exponents of prime factors",
        "Problem involves properties of divisors or factors",
        "Solution requires analyzing prime factorization exponents",
        "Constraints are applied independently to each prime factor",
        "Simplifying rational expressions to find the prime factorization of the denominator",
        "Comparing the multiplicity of a prime in the numerator versus the denominator",
        "Determining the exact power of a prime dividing a quotient",
        "Problem asks for parameters derived from the prime factorization of a rational number.",
        "Requirement to express a value as m / p^n.",
        "Problems involving perfect powers (squares, cubes)",
        "Divisibility constraints dependent on prime exponents",
        "GCD/LCM relationships analyzed via prime signatures",
        "Logarithmic equation with integer constraints",
        "Base conversion to prime",
        "exponent of a prime in factorization",
        "repeated divisibility check by a prime",
        "p-adic valuation computation"
      ],
      "implementation": [
        "Represented m as 2^a * 5^b * k where gcd(k, 10) = 1.",
        "Solved separate exponent equations for p=2 and p=5 independently.",
        "Decomposed N into prime factorization to access exponents",
        "Analyzed each prime exponent independently to determine valid choices",
        "Decomposed N = 3! * 5! * 7! into prime factors to analyze exponents independently",
        "Determined valid exponent choices for each prime factor based on the cube constraint",
        "Decomposed the counting problem into independent subproblems for each prime exponent in the factorization $3^6 \\cdot 5^{10}$",
        "Determined valid exponent choices for each prime separately before combining results",
        "Computed the exponent of 2 in the simplified denominator (`log2_n`) by subtracting the valuation of the numerator (`v2_factorial`) from the valuation of the unsimplified denominator (`total_games`).",
        "Expressed the computed probability as m / 3^n to isolate the exponent of the prime 3 in the denominator.",
        "Identified n as the 3-adic valuation of the denominator.",
        "Decomposing each base in the product expression into prime factors",
        "Aggregating exponents for each prime across all terms to determine the global prime signature",
        "Converted log_base(a) and log_base(r) to prime exponents x, y to form linear equation",
        "Function CountPrimeValuation computes the exponent of prime 3 in each number by repeated division.",
        "Used to determine the contribution of each odd integer to the total power of 3."
      ],
      "used_in": [
        "cmath_10627",
        "cmath_10630",
        "cmath_10860",
        "cmath_10934",
        "cmath_2104",
        "cmath_2167",
        "cmath_4681",
        "cmath_5291",
        "cmath_5295"
      ]
    },
    "Max Function Case Analysis": {
      "name": "Max Function Case Analysis",
      "kind": "algebraic manipulation",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Solving equations involving max(a, b) by splitting the domain into cases based on the comparison of a and b.",
      "cues": [
        "Equations containing max() terms",
        "Piecewise conditions derived from valuations or absolute values"
      ],
      "implementation": [
        "Solved max(a + 3, 10) = 2 + max(a, 10) by testing cases a >= 7 and a < 7 to determine valid exponent values."
      ],
      "used_in": [
        "cmath_10627"
      ]
    },
    "Perfect Square Exponent Count": {
      "name": "Perfect Square Exponent Count",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "exponent",
          "typing": "integer",
          "description": "The maximum exponent e in the prime factorization p^e of the original number"
        }
      ],
      "description": "Calculates the number of valid even exponents k (0 <= k <= e) for a prime factor p^e to contribute to a perfect square divisor.",
      "cues": [
        "Perfect square factors",
        "Divisor counting",
        "Parity constraints on exponents"
      ],
      "implementation": [
        "Computed floor(e / 2) + 1 for each prime exponent to find the number of even values in range [0, e]"
      ],
      "used_in": [
        "cmath_10630"
      ]
    },
    "Base Digit Divisibility Reduction": {
      "name": "Base Digit Divisibility Reduction",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "N",
          "typing": "Integer",
          "description": "The integer value represented in base b"
        },
        {
          "name": "d",
          "typing": "Integer",
          "description": "The target last digit value"
        },
        {
          "name": "b",
          "typing": "Integer",
          "description": "The unknown base variable"
        }
      ],
      "description": "Transforming a constraint on the last digit of a number in base b into a divisibility constraint where b must divide the difference between the number and the digit.",
      "cues": [
        "last digit in base b",
        "finding valid bases",
        "digit constraint"
      ],
      "implementation": [
        "DERIVE: Condition for last digit d in base b is N mod b = d",
        "TRANSFORM: This implies b divides (N - d)",
        "COMPUTE: Difference M = N - d = 2010"
      ],
      "used_in": [
        "cmath_10637"
      ]
    },
    "Divisor Enumeration": {
      "name": "Divisor Enumeration",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "Integer",
          "description": "The integer to find divisors for"
        },
        {
          "name": "target_number",
          "typing": "integer",
          "description": "The integer whose divisors are being computed"
        }
      ],
      "description": "Computing the complete set of positive divisors for a given integer to identify candidate values satisfying divisibility conditions.",
      "cues": [
        "divisibility constraint",
        "find candidates",
        "integer M",
        "Solution requires finding factors of a specific integer product.",
        "The search space is defined by the divisors of a derived value.",
        "Problem involves checking if k divides N",
        "Need to find all factors of a number",
        "Problem condition depends on the divisors of the candidate number.",
        "Need to identify specific divisors (proper divisors) to compute a property."
      ],
      "implementation": [
        "FIND: Set of all positive divisors D of M",
        "Iterated from 1 to floor(sqrt(target_product)) to find divisors.",
        "Checked divisibility condition target_product % m == 0.",
        "Constructing the set D of integers k in range [1, n] such that k divides n^2 - n",
        "Step `Determine set D of proper divisors of n (divisors d where 1 < d < n)`.",
        "Filters standard divisors to exclude 1 and n."
      ],
      "used_in": [
        "cmath_10637",
        "cmath_10998",
        "cmath_4818",
        "cmath_5240"
      ]
    },
    "Divisor Enumeration for Integrality": {
      "name": "Divisor Enumeration for Integrality",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "Numerator",
          "typing": "Integer",
          "description": "The constant value in the numerator of the fraction."
        },
        {
          "name": "Denominator Expression",
          "typing": "Function",
          "description": "The expression involving the variable that forms the denominator."
        }
      ],
      "description": "Solving equations where a rational expression must be an integer by enumerating the divisors of the numerator and solving for the variable in the denominator.",
      "cues": [
        "Fraction must evaluate to an integer",
        "Variable appears in the denominator",
        "Numerator is a known constant",
        "Integer domain allows negative values (requires checking negative divisors)",
        "Divisibility constraint involving a variable expression (e.g., f(n) | K)",
        "Small constant term allowing for complete divisor enumeration",
        "Goal is to find integer values for the variable",
        "Rational expression involving a variable must evaluate to an integer",
        "Divisibility condition derived from integrality constraint"
      ],
      "implementation": [
        "Identify condition: Denominator must divide Numerator",
        "Find all integer divisors of the Numerator (including negative divisors)",
        "Set Denominator Expression equal to each divisor",
        "Solve for x and verify if x is an integer",
        "Enumerated all integer divisors of 20 to identify candidate values for the expression 2n - 1",
        "Solved the linear equation 2n - 1 = d for each candidate divisor d",
        "Identified that n + 10 must be a divisor of 900 to satisfy the integrality condition.",
        "Selected the largest divisor (900) to maximize n, solving n + 10 = 900.",
        "Steps 2-3: Derived condition that n-1 must divide 2001 from the integrality of (S-x)/(n-1)",
        "Step 4: Enumerated divisors of 2001 to find candidate values for n-1"
      ],
      "used_in": [
        "cmath_10664",
        "cmath_4759",
        "cmath_5235",
        "cmath_5271"
      ]
    },
    "Divisibility Counting Formula": {
      "name": "Divisibility Counting Formula",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "limit",
          "typing": "integer",
          "description": "The upper bound of the range (inclusive)"
        },
        {
          "name": "divisor",
          "typing": "integer",
          "description": "The number whose multiples are being counted"
        }
      ],
      "description": "Calculates the number of multiples of an integer k within the range [1, N] using the floor division formula floor(N / k).",
      "cues": [
        "counting multiples within a range",
        "divisibility condition",
        "large range where enumeration is inefficient",
        "multiples in range",
        "floor(n/k)",
        "counting divisible numbers"
      ],
      "implementation": [
        "count_actual_true <- FLOOR(total_items / true_divisor)",
        "count_marked_false <- FLOOR(total_items / mark_false_divisor)",
        "count_intersection <- FLOOR(total_items / lcm_divisor)",
        "Used inside the loop to count how many numbers in [1, n] are divisible by the current power of 5",
        "Expression floor(n / power_of_5) calculates the count of multiples"
      ],
      "used_in": [
        "cmath_10691",
        "cmath_5545"
      ]
    },
    "LCM Intersection Property": {
      "name": "LCM Intersection Property",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "divisor_a",
          "typing": "integer",
          "description": "First divisor"
        },
        {
          "name": "divisor_b",
          "typing": "integer",
          "description": "Second divisor"
        },
        {
          "name": "lcm_value",
          "typing": "integer",
          "description": "Precomputed LCM of divisor_a and divisor_b"
        }
      ],
      "description": "The set of integers divisible by both a and b is identical to the set of integers divisible by lcm(a, b), allowing intersection counts to be computed via the LCM.",
      "cues": [
        "two simultaneous divisibility conditions",
        "finding common multiples",
        "intersection of divisibility sets"
      ],
      "implementation": [
        "count_intersection <- FLOOR(total_items / lcm_divisor)"
      ],
      "used_in": [
        "cmath_10691"
      ]
    },
    "Symmetric Difference Counting": {
      "name": "Symmetric Difference Counting",
      "kind": "counting method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "count_a",
          "typing": "integer",
          "description": "Size of set A"
        },
        {
          "name": "count_b",
          "typing": "integer",
          "description": "Size of set B"
        },
        {
          "name": "count_intersection",
          "typing": "integer",
          "description": "Size of intersection A \u2229 B"
        }
      ],
      "description": "Computes the size of the symmetric difference of two sets (elements in exactly one set) by summing the counts of elements unique to each set (|A| + |B| - 2|A \u2229 B|).",
      "cues": [
        "correct classification where truth and prediction differ",
        "counting mismatches",
        "exclusive OR logic between two conditions"
      ],
      "implementation": [
        "correct_true <- count_actual_true - count_intersection",
        "correct_false <- count_marked_false - count_intersection",
        "RETURN correct_true + correct_false"
      ],
      "used_in": [
        "cmath_10691"
      ]
    },
    "Perfect Square Factorization": {
      "name": "Perfect Square Factorization",
      "kind": "algebraic manipulation",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "polynomial",
          "typing": "expression",
          "description": "The quadratic expression to be factored"
        },
        {
          "name": "variable",
          "typing": "symbol",
          "description": "The variable with respect to which the square is formed"
        }
      ],
      "description": "Recognizing and factoring a quadratic polynomial as the square of a binomial (e.g., $x^2 + 2x + 1 = (x+1)^2$) to simplify equations.",
      "cues": [
        "Quadratic expressions with coefficients forming a perfect square pattern (e.g., 1, 2, 1)",
        "Equations involving squares of variables on both sides"
      ],
      "implementation": [
        "Identified $c^2 + 2c + 1$ as $(c+1)^2$",
        "Simplified $b^2 = (c+1)^2$ to linear relation $b = c+1$"
      ],
      "used_in": [
        "cmath_10695"
      ]
    },
    "Algebraic Substitution": {
      "name": "Algebraic Substitution",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "target_equation",
          "typing": "equation",
          "description": "The equation into which substitution is performed"
        },
        {
          "name": "substitution_expression",
          "typing": "expression",
          "description": "The expression replacing the variable"
        },
        {
          "name": "variable",
          "typing": "symbol",
          "description": "The variable being eliminated"
        }
      ],
      "description": "Replacing a variable in an equation with an equivalent expression derived from another equation to reduce the system to a single variable.",
      "cues": [
        "System of multiple equations with shared variables",
        "One equation allows easy isolation of a variable (e.g., linear relation)",
        "Given specific values for algebraic sub-expressions",
        "Target expression contains terms matching known values",
        "Linear constraint relating two variables",
        "Solving for one variable in terms of another to reduce dimensionality",
        "substitute the ratio-based holdings",
        "distribution expressions",
        "system of linear equations",
        "expression involves variables with derived forms",
        "simplify by replacing variables"
      ],
      "implementation": [
        "Substituted $b = c + 1$ into $c^2 = 7b + 1$",
        "Reduced system to single quadratic equation $c^2 - 7c - 8 = 0$",
        "Substituted the known value (ab)^(-1) \u2261 2 into the transformed expression",
        "Replaced the complex term with a constant to simplify computation",
        "num_M = required_cost_M / cost_M",
        "Substituted the parameterized ratio holdings into the linear expressions describing the distribution process.",
        "Generated a system of linear equations linking the taken quantities to the scaling factor k.",
        "Substituted x=p1^2, y=p2^2, z=p3^2 into E = x^2 * y^3 * z^4 to find prime factorization of E"
      ],
      "used_in": [
        "cmath_10695",
        "cmath_10942",
        "cmath_2432",
        "cmath_5283",
        "cmath_5532"
      ]
    },
    "Fraction Clearing": {
      "name": "Fraction Clearing",
      "kind": "algebraic manipulation",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Converting equations with rational coefficients to integer coefficients by multiplying through by the LCM of all denominators",
      "cues": [
        "Equation contains fractions or rational coefficients",
        "Need to simplify to work with integer arithmetic",
        "Linear or polynomial equations with fractional terms"
      ],
      "implementation": [
        "Multiplied M/4 + C/6 = 8 by 12 (LCM of 4 and 6) to obtain 3M + 2C = 96"
      ],
      "used_in": [
        "cmath_10731"
      ]
    },
    "Divisibility Substitution": {
      "name": "Divisibility Substitution",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "variable",
          "typing": "symbol",
          "description": "The original variable subject to divisibility constraint"
        },
        {
          "name": "divisor",
          "typing": "integer",
          "description": "The known divisor that the variable must be a multiple of"
        },
        {
          "name": "parameter",
          "typing": "symbol",
          "description": "The new integer parameter representing the quotient"
        }
      ],
      "description": "Replacing variables with parameterized forms based on known divisibility constraints (e.g., if x must be divisible by k, set x = k\u00b7t for integer t)",
      "cues": [
        "Variable must be a multiple of a known value",
        "Problem involves partitioning or grouping with fixed sizes",
        "Need to reduce search space using structural constraints",
        "converting congruences to algebraic equations",
        "parameterizing integer solutions",
        "expressions involving integer multiples (e.g., mk + r)",
        "Counting divisors subject to a multiple constraint (e.g., divisors of N that are multiples of k)",
        "Condition where a variable must be divisible by a constant",
        "proportional holdings",
        "given ratio",
        "common scaling factor",
        "Constraint that the target number must be a multiple of a specific integer",
        "Desire to reduce the search space density"
      ],
      "implementation": [
        "Applied constraint that M and C must be multiples of 8",
        "Substituted M = 8m and C = 8c to reduce 3M + 2C = 96 to 3m + 2c = 12",
        "Formulating the general solution r = 26 + 55 * k from r \u2261 26 (mod 55)",
        "Substituting divisor d with k * m to transform the condition 'd divides N and k divides d' into 'm divides N/k'",
        "Reducing the problem to counting divisors of the quotient M = N / k",
        "Introduced a scaling factor k to represent the final holdings as proportional values (e.g., 3k, 4k, 5k) based on the given ratio.",
        "Converted ratio constraints into algebraic variables to facilitate equation formulation.",
        "Defined candidate as n * multiplier instead of iterating candidate directly",
        "Reduced search space from limit values to limit/multiplier values"
      ],
      "used_in": [
        "cmath_10731",
        "cmath_11055",
        "cmath_4855",
        "cmath_5283",
        "cmath_5477"
      ]
    },
    "Extended Euclidean Algorithm": {
      "name": "Extended Euclidean Algorithm",
      "kind": "algorithm",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "a",
          "typing": "integer",
          "description": "The integer to invert"
        },
        {
          "name": "b",
          "typing": "integer",
          "description": "Second integer input"
        },
        {
          "name": "m",
          "typing": "integer",
          "description": "The modulus (must be coprime to a)"
        }
      ],
      "description": "An extension of the Euclidean algorithm that computes the greatest common divisor of two integers a and b, along with coefficients x and y (B\u00e9zout's identity) such that ax + by = gcd(a, b).",
      "cues": [
        "Need to find integer coefficients for a linear combination of two numbers",
        "Computing modular multiplicative inverses",
        "Solving linear Diophantine equations",
        "Need to compute modular inverse k^(-1) mod p",
        "Prime modulus ensures gcd(k, p) = 1 for k < p",
        "Need to compute gcd(a, m) along with coefficients x and y",
        "Solving linear Diophantine equation ax + by = g"
      ],
      "implementation": [
        "Defined a recursive function `extended_gcd` that returns the tuple (gcd, x, y).",
        "Used the base case where if a=0, the gcd is b and coefficients are (0, 1).",
        "Applied the recursive step updating coefficients using the relation x = y1 - (b // a) * x1.",
        "Implicitly used to compute `inv_k = k^(-1) mod p`",
        "Implicitly used to compute `inv_k1 = (k+1)^(-1) mod p`",
        "Invoked as `ExtendedEuclidean(a, m)` to return tuple (g, x, y)",
        "Provides the raw coefficient x used for the inverse"
      ],
      "used_in": [
        "cmath_10774",
        "cmath_10978",
        "cmath_5195"
      ]
    },
    "Modular Inverse via Extended GCD": {
      "name": "Modular Inverse via Extended GCD",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "a",
          "typing": "integer",
          "description": "The number to invert"
        },
        {
          "name": "m",
          "typing": "integer",
          "description": "The modulus"
        }
      ],
      "description": "A method to compute the multiplicative inverse of an integer 'a' modulo 'm' by utilizing the Extended Euclidean Algorithm to solve ax \u2261 1 (mod m), valid only when gcd(a, m) = 1.",
      "cues": [
        "Problem requires division in modular arithmetic (e.g., finding x such that a*x = 1 mod m)",
        "Modulus is known to be prime or coprime to the numerator",
        "Expression involves fractions in a modular context",
        "Need to divide by a number in modular arithmetic (solve ax \u2261 1 mod m).",
        "Coefficient and modulus are coprime.",
        "Problem requires finding multiplicative inverse modulo m",
        "Modulus m is not guaranteed to be prime"
      ],
      "implementation": [
        "Called `extended_gcd(160, 1399)` to find coefficients.",
        "Included an assertion to verify that the gcd is 1, ensuring the inverse exists.",
        "Normalized the resulting coefficient x using modulo m to ensure the result lies in the range [0, m-1].",
        "Used to find the inverse of the reduced coefficient in Linear Congruence Resolution.",
        "Used to find the inverse of N_i modulo modulus_reduced in CRT construction.",
        "Defines the overall strategy to solve a * x \u2261 1 (mod m)",
        "Transforms the problem into solving the Diophantine equation a * x + m * y = 1"
      ],
      "used_in": [
        "cmath_10774",
        "cmath_5178",
        "cmath_5195"
      ]
    },
    "Perfect Power Divisor Count": {
      "name": "Perfect Power Divisor Count",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "power",
          "typing": "integer",
          "description": "The root of the perfect power (e.g., 2 for squares, 3 for cubes)"
        },
        {
          "name": "exponent",
          "typing": "integer",
          "description": "The exponent of the prime factor in the number's prime factorization"
        },
        {
          "name": "PrimeExponents",
          "typing": "list[int]",
          "description": "The exponents of the prime factors in the integer's prime factorization"
        },
        {
          "name": "RootPower",
          "typing": "int",
          "description": "The power k (e.g., 2 for square, 3 for cube) that the divisors must satisfy"
        }
      ],
      "description": "Calculates the number of divisors that are perfect k-th powers by counting valid exponents divisible by k for each prime factor in the number's factorization.",
      "cues": [
        "Problem asks for the number of perfect square, cube, or k-th power divisors",
        "Solution involves counting multiples of k within the range of prime exponents",
        "Counting divisors that are perfect powers (squares, cubes, etc.)",
        "Prime factorization is known or easily computable",
        "Problem asks for the number of factors satisfying a power constraint"
      ],
      "implementation": [
        "Applied with power=3 to compute choices for each prime exponent as floor(e/3) + 1",
        "Multiplied the counts for each prime factor to get the total number of cube divisors",
        "Applied the formula `Floor(E / RootPower) + 1` to count valid exponents for each prime factor ($6 \\to \\lfloor 6/3 \\rfloor + 1 = 3$, $10 \\to \\lfloor 10/3 \\rfloor + 1 = 4$)",
        "Generalized the logic from perfect squares to perfect cubes (RootPower = 3)"
      ],
      "used_in": [
        "cmath_10860",
        "cmath_10934"
      ]
    },
    "Reciprocal Sum Identity": {
      "name": "Reciprocal Sum Identity",
      "kind": "identity",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Relates the sum of two multiplicative inverses to the inverse of their product scaled by their sum (a^(-1) + b^(-1) = (a+b)(ab)^(-1)).",
      "cues": [
        "Expression involves a sum of inverses (1/a + 1/b)",
        "Need to combine terms with different modular denominators",
        "Given value is related to the product of the variables (ab)"
      ],
      "implementation": [
        "Transformed (a^(-1) + b^(-1)) into (a+b)*(ab)^(-1) to align with the given constraint",
        "Enabled the use of the known value (ab)^(-1) \u2261 2"
      ],
      "used_in": [
        "cmath_10942"
      ]
    },
    "Conditional Summation": {
      "name": "Conditional Summation",
      "kind": "calculation method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Calculating the sum of values in a collection that satisfy a specific boolean predicate.",
      "cues": [
        "Aggregating values based on a condition (e.g., Sum(x where P(x)))",
        "Partitioning a total sum into components based on properties",
        "Accumulating a total based on a boolean predicate",
        "Summing values that satisfy a specific number theoretic condition",
        "Accumulating a total based on a validity predicate",
        "Filtering candidates during aggregation"
      ],
      "implementation": [
        "Computing sum A for coprime residues and sum B for non-coprime residues",
        "Adding \u03bd to Total_Sum only when LCM(\u03bd, Base_Number) == Target_LCM",
        "Adding value to total_sum only if d1 != 0 (leading non-zero constraint)"
      ],
      "used_in": [
        "cmath_10993",
        "cmath_4733",
        "cmath_5349"
      ]
    },
    "Arithmetic Progression Minimum Bound": {
      "name": "Arithmetic Progression Minimum Bound",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Determining the smallest integer parameter in a linear expression (arithmetic progression) that satisfies a given lower bound constraint, typically using ceiling division.",
      "cues": [
        "range constraints (e.g., \"least four-digit number\", \"smallest n > X\")",
        "inequalities involving linear terms with an integer parameter",
        "finding minimum values within a specific residue class",
        "Solution space forms an arithmetic progression (x_0 + k * M).",
        "Requirement to find the smallest solution >= a specific LowerBound."
      ],
      "implementation": [
        "Setting up the inequality 26 + 55 * k \u2265 1000",
        "Solving for minimal integer k using ceiling division on (1000 - 26) / 55",
        "Substituting the minimal k back to find the specific value",
        "Calculated k using ceiling division: Ceiling((LowerBound - x_0) / M_total).",
        "Adjusted base solution x_0 by adding k * M_total."
      ],
      "used_in": [
        "cmath_11055",
        "cmath_5178"
      ]
    },
    "Multiplication Principle": {
      "name": "Multiplication Principle",
      "kind": "counting method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "option_counts",
          "typing": "list of integers",
          "description": "The number of available choices for each independent decision point."
        }
      ],
      "description": "Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.",
      "cues": [
        "Independent choices",
        "Forming combinations from multiple categories",
        "Phrase 'for each...'",
        "Counting ways to form subsets with multiple independent choices",
        "Problem involves selecting elements under constraints",
        "determining total size of sample space",
        "independent choices at each step",
        "Sequence of independent choices (in terms of count)",
        "Total Count = Step 1 * Step 2 * Step 3",
        "Constructive counting strategy",
        "Independent selection tasks",
        "Combining counts from disjoint sets",
        "The counting problem can be decomposed into a sequence of independent choices.",
        "The total count for a specific case is the product of the counts of each choice."
      ],
      "implementation": [
        "Calculating `choices_per_type = count + 1` for each item type",
        "Multiplying `choices_per_type` into `total_combinations`",
        "Foundation for computing Combinations(n-2, k-1)",
        "Counting valid subset configurations by multiplying choice counts",
        "Computed total_sequences as 2^10 (2 choices for each of 10 positions).",
        "Multiplied the counts of options for Units, Hundreds, and Tens to get the total.",
        "Used as the final aggregation step to combine positional counts.",
        "ways_E * ways_M",
        "Calculates the number of ways for a fixed set of excluded targets by multiplying `ways_to_choose_excluded` and `ways_to_assign_to_remaining`.",
        "Combines the selection of excluded targets (binomial coefficient) with the assignment of elements to valid targets (power function)."
      ],
      "used_in": [
        "cmath_1854",
        "cmath_2147",
        "cmath_2190",
        "cmath_2385",
        "cmath_2432",
        "cmath_9112"
      ]
    },
    "Complementary Counting": {
      "name": "Complementary Counting",
      "kind": "counting method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "total",
          "typing": "integer",
          "description": "The total number of possibilities including invalid cases."
        },
        {
          "name": "excluded",
          "typing": "integer",
          "description": "The number of invalid or unwanted possibilities to subtract."
        },
        {
          "name": "total_count",
          "typing": "integer",
          "description": "The total number of elements in the universal set."
        },
        {
          "name": "complement_count",
          "typing": "integer",
          "description": "The number of elements satisfying the negation of the target condition."
        }
      ],
      "description": "Determining the count of elements satisfying a property by subtracting the count of elements that do not satisfy it from the total count.",
      "cues": [
        "Non-empty",
        "At least one",
        "Excluding trivial cases",
        "Problem asks for \"at least one\" or \"not all\".",
        "Direct counting involves complex casework while the complement is uniform.",
        "Phrases like \"none\", \"never\", or \"all distinct\" (when target is \"not all distinct\").",
        "Problem asks for count of items satisfying a property.",
        "Direct counting is complex, but counting the complement (items failing the property) is simpler.",
        "Total set size is easily determined."
      ],
      "implementation": [
        "Subtracting 1 from `total_combinations` to remove the empty selection case",
        "Calculated `ResultCount` by subtracting `DistinctCount` (complement) from `TotalCount`.",
        "Used because counting numbers with repeated digits directly is harder than counting numbers with all distinct digits.",
        "Calculated valid_count by subtracting excluded_count (integers congruent to 2 mod 4) from total_count (upper_bound)."
      ],
      "used_in": [
        "cmath_1854",
        "cmath_1970",
        "cmath_5260"
      ]
    },
    "Positional Digit Counting": {
      "name": "Positional Digit Counting",
      "kind": "counting method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "positions",
          "typing": "list",
          "description": "The digit positions to fill (e.g., [100, 10, 1])."
        },
        {
          "name": "constraints",
          "typing": "list",
          "description": "Rules restricting valid digits at each position (e.g., distinctness, range bounds)."
        }
      ],
      "description": "Counting integers satisfying digit-level constraints by multiplying the number of valid choices for each digit position (Hundreds, Tens, Units, etc.).",
      "cues": [
        "Problem involves properties of decimal digits (distinct, even, odd, specific values).",
        "Fixed number of digits (e.g., 3-digit numbers).",
        "Constraints depend on previous digit choices (e.g., distinctness).",
        "Three-digit number structure",
        "Digit-level constraints (parity, leading zero, distinctness)",
        "Hundreds, Tens, Units positions",
        "count of distinct 3-digit numbers",
        "base b representation",
        "digit constraints (non-zero leading, distinct)"
      ],
      "implementation": [
        "Computed `DistinctCount` as the product of `HundredsChoices`, `TensChoices`, and `UnitsChoices`.",
        "Adjusted choices for Tens and Units based on digits selected for previous positions to enforce distinctness.",
        "Decomposed the number into Hundreds, Tens, and Units positions.",
        "Calculated valid digit choices for each position independently based on constraints.",
        "Derived formula N(b) by multiplying valid choices for each position: (b-1) for first, (b-1) for second, (b-2) for third",
        "Applied multiplication principle across digit positions to get total count"
      ],
      "used_in": [
        "cmath_1970",
        "cmath_2385",
        "cmath_4869"
      ]
    },
    "Range Cardinality": {
      "name": "Range Cardinality",
      "kind": "formula",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "range_min",
          "typing": "integer",
          "description": "The lower bound of the inclusive range."
        },
        {
          "name": "range_max",
          "typing": "integer",
          "description": "The upper bound of the inclusive range."
        }
      ],
      "description": "Computes the number of integers in an inclusive interval [min, max] using the formula max - min + 1.",
      "cues": [
        "Problem asks for the count of numbers within a specific interval.",
        "Bounds are given as explicit integers.",
        "Counting valid parameter values",
        "Inclusive integer range",
        "counting integers in an interval",
        "non-negative range",
        "inclusive bounds"
      ],
      "implementation": [
        "Calculated `TotalCount` as `RangeMax - RangeMin + 1` to establish the universe size for complementary counting.",
        "Calculated count as max_k - min_k + 1",
        "Computed `count` as `max_val + 1`, representing the number of integers in the inclusive range `[0, max_val]`."
      ],
      "used_in": [
        "cmath_1970",
        "cmath_5291",
        "cmath_5330"
      ]
    },
    "Digit Decomposition": {
      "name": "Digit Decomposition",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "number",
          "typing": "integer",
          "description": "The integer to be decomposed into digits"
        },
        {
          "name": "base",
          "typing": "integer",
          "description": "The numerical base for decomposition (default 10)"
        }
      ],
      "description": "Extracting individual digits from an integer in a given base to analyze their values or relationships.",
      "cues": [
        "Problem statement refers to \"digits\", \"decimal representation\", or digit positions",
        "Conditions involve comparisons or arithmetic on individual digits",
        "Extract digits D",
        "decimal expansion",
        "fractional part",
        "digit_sum",
        "Obtain the binary representation of n",
        "ith bit of n",
        "n = \u03a3(b_i * 2^i)"
      ],
      "implementation": [
        "(d1, d2, d3) <- decimal_digits(n)",
        "Extracting the sequence of digits from the decimal representation of 1/5^n",
        "Treating the significant digits of the rational number as a sequence for analysis",
        "Extracted binary digits b_i from the index n to serve as coefficients"
      ],
      "used_in": [
        "cmath_1988",
        "cmath_4689",
        "cmath_5236"
      ]
    },
    "Bell Number": {
      "name": "Bell Number",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The number of distinct elements to partition"
        }
      ],
      "description": "The total number of partitions of a set of n labeled elements into non-empty unlabeled subsets.",
      "cues": [
        "distinct elements",
        "identical containers",
        "unlimited container capacity or count"
      ],
      "implementation": [
        "Returned directly when the number of containers k is greater than or equal to the number of elements n"
      ],
      "used_in": [
        "cmath_2027"
      ]
    },
    "Stirling Numbers of the Second Kind": {
      "name": "Stirling Numbers of the Second Kind",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The number of distinct elements"
        },
        {
          "name": "k",
          "typing": "integer",
          "description": "The exact number of non-empty subsets"
        }
      ],
      "description": "Counts the number of ways to partition a set of n labeled elements into exactly k non-empty unlabeled subsets.",
      "cues": [
        "distinct elements",
        "identical containers",
        "constraint on number of non-empty subsets"
      ],
      "implementation": [
        "Summed from i=1 to k to count partitions with at most k subsets when containers are limited"
      ],
      "used_in": [
        "cmath_2027"
      ]
    },
    "Set Partition Counting": {
      "name": "Set Partition Counting",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Modeling distribution problems where items are distinguishable and bins are indistinguishable as set partition problems.",
      "cues": [
        "distinct elements",
        "identical containers"
      ],
      "implementation": [
        "The initial conditional check identifies this scenario to apply partition counting formulas"
      ],
      "used_in": [
        "cmath_2027"
      ]
    },
    "Gap Method": {
      "name": "Gap Method",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "unrestricted_items",
          "typing": "list",
          "description": "The set of items that have no adjacency constraints."
        },
        {
          "name": "restricted_items",
          "typing": "list",
          "description": "The set of items that must not be adjacent to each other."
        }
      ],
      "description": "A combinatorial technique for counting arrangements where specific items must not be adjacent. It involves first arranging the unrestricted items, identifying the available \"gaps\" (including ends) between them, and then choosing distinct gaps to place the restricted items.",
      "cues": [
        "non-adjacent",
        "no two items together",
        "separated by at least one item",
        "arrangement with separation constraints"
      ],
      "implementation": [
        "ARRANGE non_restricted_items and compute their distinct permutations",
        "GENERATE gaps from non_restricted_arrangement equal to (count + 1)",
        "SELECT positions for restricted_items from gaps using combinations to ensure non-adjacency",
        "COMPUTE valid_permutations = non_restricted_permutations * selection_ways"
      ],
      "used_in": [
        "cmath_2077"
      ]
    },
    "Multinomial Coefficient": {
      "name": "Multinomial Coefficient",
      "kind": "identity",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "total_count",
          "typing": "integer",
          "description": "The total number of items (n)."
        },
        {
          "name": "group_counts",
          "typing": "list of integers",
          "description": "The counts of each identical group (n1, n2, ...)."
        }
      ],
      "description": "A formula used to calculate the number of distinct permutations of a multiset (a set with repeated elements), given by n! / (n1! * n2! * ... * nk!).",
      "cues": [
        "distinct permutations of items with duplicates",
        "arranging a multiset",
        "total permutations with repeated elements"
      ],
      "implementation": [
        "COMPUTE total_permutations using multinomial coefficient for all items combined"
      ],
      "used_in": [
        "cmath_2077"
      ]
    },
    "Probability as Ratio of Counts": {
      "name": "Probability as Ratio of Counts",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "favorable_count",
          "typing": "integer",
          "description": "The number of outcomes satisfying the specific condition."
        },
        {
          "name": "total_count",
          "typing": "integer",
          "description": "The total number of possible outcomes in the sample space."
        }
      ],
      "description": "Calculating the probability of an event in a uniform sample space by dividing the count of favorable outcomes by the count of total possible outcomes.",
      "cues": [
        "probability of an arrangement",
        "ratio of valid to total",
        "likelihood of a configuration",
        "problem asks for probability of an event",
        "uniform sample space implied",
        "discrete uniform sample space",
        "counting favorable vs total outcomes"
      ],
      "implementation": [
        "DERIVE probability = valid_permutations / total_permutations",
        "SIMPLIFY probability to lowest terms m/n",
        "Calculated probability as valid_sequences / total_sequences.",
        "Calculating stopping probability p = 5/6 based on die roll outcomes"
      ],
      "used_in": [
        "cmath_2077",
        "cmath_2190",
        "cmath_2286"
      ]
    },
    "Stars and Bars Theorem": {
      "name": "Stars and Bars Theorem",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "N",
          "typing": "integer",
          "description": "The target sum for the non-negative variables."
        },
        {
          "name": "k",
          "typing": "integer",
          "description": "Number of distinct bins available"
        },
        {
          "name": "n",
          "typing": "integer",
          "description": "Number of identical items to distribute"
        }
      ],
      "description": "Determines the number of non-negative integer solutions to a linear equation x_1 + ... + x_k = N using the binomial coefficient C(N+k-1, k-1).",
      "cues": [
        "sum of variables equals constant",
        "non-negative integer solutions",
        "counting distributions",
        "distributing identical items into distinct bins",
        "constraint that bins may be empty (non-negative integers)",
        "finding total number of distribution ways",
        "linear equation constraint on sum of variables (x_1 + ... + x_k = n)",
        "counting non-negative integer solutions to a linear sum equation",
        "variables represent counts in distinct categories summing to a total"
      ],
      "implementation": [
        "Applied to count solutions for sum(y_i) = N with k variables using BinomialCoefficient(N + k - 1, k - 1).",
        "Mapped problem variables to theorem parameters (identical_items -> n, distinct_bins -> k)",
        "Computed result using BinomialCoefficient(n + k - 1, k - 1)",
        "Verified constraints match non-negative integer solutions requirement",
        "Mapped the problem of 6 identical items and 3 distinct bins to the equation x_1 + x_2 + x_3 = 6",
        "Computed the result using the binomial coefficient formula C(n + k - 1, k - 1)"
      ],
      "used_in": [
        "cmath_2102",
        "cmath_2428",
        "cmath_8896"
      ]
    },
    "Odd Integer Parametrization": {
      "name": "Odd Integer Parametrization",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "count",
          "typing": "integer",
          "description": "The number of odd integers to generate."
        },
        {
          "name": "start",
          "typing": "integer",
          "description": "The starting odd integer (default 1)."
        }
      ],
      "description": "Representing positive odd integers x as 2y + 1 where y >= 0 to transform constraints into standard non-negative integer forms suitable for combinatorial methods.",
      "cues": [
        "positive odd integers",
        "sum of odd numbers",
        "parity constraints",
        "sequence of odd numbers",
        "form 2k + 1",
        "excluding even integers"
      ],
      "implementation": [
        "Substituted x_i = 2*y_i + 1 to transform the sum equation into 2 * sum(y_i) + k = S.",
        "Sequence consists of the first 100 odd integers (1, 3, ..., 199).",
        "Defines the domain of numbers over which the valuation is summed."
      ],
      "used_in": [
        "cmath_2102",
        "cmath_5295"
      ]
    },
    "Parity Feasibility Check": {
      "name": "Parity Feasibility Check",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Verifying that the target sum and variable constraints have compatible parity to ensure integer solutions exist before counting.",
      "cues": [
        "sum of integers",
        "existence of solution",
        "linear Diophantine equation",
        "Variable expression has a fixed parity structure (e.g., 2n - 1 is always odd)",
        "Candidate set contains values with mixed parity",
        "Need to ensure integer solutions exist for the variable"
      ],
      "implementation": [
        "Checked if (S - k) is odd or negative to return 0 early.",
        "Filtered the list of divisors to retain only odd values",
        "Ensured compatibility between the parity of the divisor and the form 2n - 1 to guarantee integer n"
      ],
      "used_in": [
        "cmath_2102",
        "cmath_4759"
      ]
    },
    "Pairwise Combination Formula": {
      "name": "Pairwise Combination Formula",
      "kind": "formula",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The size of the set from which pairs are formed."
        }
      ],
      "description": "Calculates the number of unique pairs that can be formed from a set of n elements, given by the formula n(n-1)/2.",
      "cues": [
        "Round-robin tournament structures",
        "Handshake problems",
        "Counting edges in a complete graph",
        "Problems involving interactions between all distinct pairs of items",
        "Choosing 2 distinct items from a set",
        "Order irrelevant due to sorting constraint",
        "Product of geometric sequence terms",
        "Sum of arithmetic progression in exponent"
      ],
      "implementation": [
        "Calculated `total_games` as `num_teams * (num_teams - 1) / 2` to determine the total number of matches in the tournament.",
        "Computing ways_to_choose_prefix using Binomial_Coefficient(last_digit - 1, 2)",
        "Computed exponent of ratio r as n_terms * (n_terms - 1) / 2"
      ],
      "used_in": [
        "cmath_2104",
        "cmath_2476",
        "cmath_5291"
      ]
    },
    "Legendre's Formula": {
      "name": "Legendre's Formula",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The integer for which the factorial prime exponent is calculated."
        },
        {
          "name": "p",
          "typing": "prime",
          "description": "The prime number for which the exponent in the factorization is sought."
        },
        {
          "name": "prime",
          "typing": "integer",
          "description": "The prime number whose exponent in the prime factorization of n! is desired."
        }
      ],
      "description": "Computes the exponent of a prime p in the prime factorization of n! by summing the floor divisions of n by powers of p (sum_{k>=1} floor(n/p^k)).",
      "cues": [
        "Factorials appearing in numerators or denominators",
        "Need to determine the power of a prime dividing a factorial",
        "Simplifying fractions involving factorials and powers of primes",
        "Problems asking for the number of trailing zeros or specific prime factors",
        "exponent of prime in factorial",
        "largest power of p dividing n!",
        "trailing zeros in factorial",
        "trailing zeroes in factorial",
        "exponent of prime in n!",
        "sum of floor divisions by powers of p",
        "factorial prime exponent",
        "divisibility by prime powers"
      ],
      "implementation": [
        "Used a WHILE loop to iterate through powers of 2 (`divisor`), accumulating `FLOOR(num_teams / divisor)` into `v2_factorial` to find the exponent of 2 in `num_teams!`.",
        "Calculated the exponent of prime 2 in 16! by iteratively summing floor divisions of 16 by powers of 2.",
        "Applied with p=5 to determine the total count of factor 5 in n!",
        "Loop sums floor(n / 5^k) for k >= 1 until 5^k > n",
        "Used to calculate the exponent of 5 in N! to determine the number of trailing zeros.",
        "Iterates powers of 5 (5, 25, 125...) summing floor(N/power) until power exceeds N."
      ],
      "used_in": [
        "cmath_2104",
        "cmath_5031",
        "cmath_5545",
        "cmath_9126"
      ]
    },
    "Triangle Inequality Negation": {
      "name": "Triangle Inequality Negation",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Condition for three sorted lengths a <= b <= c to fail forming a triangle (a + b <= c).",
      "cues": [
        "triangle-free",
        "no triangle",
        "three elements",
        "inequality constraint"
      ],
      "implementation": [
        "Derived the recurrence relation `next_val = sequence[-1] + sequence[-2]` from the condition `a + b <= c`."
      ],
      "used_in": [
        "cmath_2114"
      ]
    },
    "Fibonacci Growth Extremal Bound": {
      "name": "Fibonacci Growth Extremal Bound",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "start_value",
          "typing": "int",
          "description": "The minimum integer value for the set elements."
        },
        {
          "name": "subset_size",
          "typing": "int",
          "description": "The target number of elements in the subset."
        }
      ],
      "description": "Constructing the minimal growth sequence (Fibonacci-like) satisfying a sum constraint to find the maximum range limit before a property becomes unavoidable.",
      "cues": [
        "maximize range",
        "subset size constraint",
        "sum of two elements",
        "avoid property"
      ],
      "implementation": [
        "Initialized sequence with `min_val`, `min_val + 1`.",
        "Iterated Fibonacci recurrence `next = prev1 + prev2`.",
        "Returned `sequence[-1] - 1` as the maximum valid bound."
      ],
      "used_in": [
        "cmath_2114"
      ]
    },
    "Fixed Element Counting": {
      "name": "Fixed Element Counting",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "total_elements",
          "typing": "integer",
          "description": "Total number of elements available (n)"
        },
        {
          "name": "subset_size",
          "typing": "integer",
          "description": "Target size of the subset (k)"
        },
        {
          "name": "fixed_inclusions",
          "typing": "integer",
          "description": "Number of elements that must be included"
        },
        {
          "name": "fixed_exclusions",
          "typing": "integer",
          "description": "Number of elements that must be excluded"
        }
      ],
      "description": "Counting subsets by fixing certain elements as required inclusions or exclusions, then choosing remaining elements from the reduced pool",
      "cues": [
        "Constraints specify certain elements must/must not be in a subset",
        "Problem reduces to choosing remaining elements after fixing some",
        "Counting formula involves C(n-fixed_count, k-fixed_inclusions)"
      ],
      "implementation": [
        "Fixed inclusion: size_B must be in A (1 element)",
        "Fixed exclusion: size_A must not be in A (1 element)",
        "Remaining selection: choose k-1 from n-2 available elements",
        "Formula: Combinations(n-2, k-1)"
      ],
      "used_in": [
        "cmath_2147"
      ]
    },
    "Symmetry Exclusion": {
      "name": "Symmetry Exclusion",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "symmetry_condition",
          "typing": "boolean expression",
          "description": "Condition that identifies the symmetric case to exclude"
        }
      ],
      "description": "Identifying and excluding symmetric or degenerate cases where constraints become contradictory or redundant",
      "cues": [
        "Two complementary structures have equal sizes/parameters",
        "Constraints become impossible to satisfy simultaneously",
        "Special case requires separate handling or exclusion"
      ],
      "implementation": [
        "Excluded case when size_A == size_B (k == n-k)",
        "Both constraints cannot be satisfied when sizes are equal",
        "Continue statement skips this impossible case"
      ],
      "used_in": [
        "cmath_2147"
      ]
    },
    "Law of Total Probability": {
      "name": "Law of Total Probability",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Computes the probability of an event by summing the conditional probabilities of the event given each partition of the sample space, weighted by the probability of each partition.",
      "cues": [
        "Problem involves mutually exclusive scenarios or hypotheses",
        "Need to compute marginal probability from conditional probabilities",
        "Calculating predictive probability by averaging over a distribution of states"
      ],
      "implementation": [
        "Computed total probability of observing two sixes by summing likelihoods weighted by prior probabilities of each die type",
        "Calculated predictive probability of third roll by summing six-probabilities weighted by posterior probabilities"
      ],
      "used_in": [
        "cmath_2163"
      ]
    },
    "Bayes' Theorem": {
      "name": "Bayes' Theorem",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Updates the probability of a hypothesis based on new evidence, relating posterior probability to prior probability and likelihood.",
      "cues": [
        "Problem asks for probability of a cause given an effect",
        "Updating beliefs after observing data",
        "Inverting conditional probability P(E|H) to find P(H|E)"
      ],
      "implementation": [
        "Determined posterior probability of each die type given the evidence of two consecutive sixes"
      ],
      "used_in": [
        "cmath_2163"
      ]
    },
    "Posterior Predictive Calculation": {
      "name": "Posterior Predictive Calculation",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Computes the probability of a future event by averaging the conditional probabilities over the posterior distribution of hypotheses.",
      "cues": [
        "Question asks for probability of next observation given past data",
        "Mixture model or hidden state problem",
        "Sequential probability problems with unknown parameters"
      ],
      "implementation": [
        "Calculated predictive probability of third roll being six using posterior weights of each die type"
      ],
      "used_in": [
        "cmath_2163"
      ]
    },
    "Grid Dynamic Programming": {
      "name": "Grid Dynamic Programming",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "grid_size",
          "typing": "integer",
          "description": "The dimensions of the grid (e.g., N x N)."
        },
        {
          "name": "base_cases",
          "typing": "map",
          "description": "Initial values for boundary conditions (e.g., DP[0][0] = 1)."
        },
        {
          "name": "transition_rule",
          "typing": "function",
          "description": "The recurrence relation defining a cell's value based on neighbors."
        }
      ],
      "description": "Solving problems by defining states on a 2D grid and computing values iteratively based on transitions from previous states (e.g., top, left, diagonal).",
      "cues": [
        "2D state space or grid structure",
        "Sequential dependency where state (i, j) depends on (i-1, j), (i, j-1), etc.",
        "Path counting or probability propagation problems"
      ],
      "implementation": [
        "Initialized a 2D DP table of size (N+1) x (N+1).",
        "Set base cases DP[0][0] = 1 and boundaries to 0.",
        "Filled the table using nested loops with the recurrence DP[i][j] = (1/3) * sum(neighbors)."
      ],
      "used_in": [
        "cmath_2167"
      ]
    },
    "Worst-Case Guarantee Threshold": {
      "name": "Worst-Case Guarantee Threshold",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "target_count",
          "typing": "integer",
          "description": "The number of groups or specific outcomes required."
        },
        {
          "name": "category_count",
          "typing": "integer",
          "description": "The number of distinct categories or bins available."
        },
        {
          "name": "group_size",
          "typing": "integer",
          "description": "The number of items required to form one unit of the target."
        }
      ],
      "description": "Determines the minimum number of items to select to guarantee a property by constructing the maximum possible selection that fails the property and adding one.",
      "cues": [
        "minimum number to guarantee",
        "worst-case scenario",
        "at least k",
        "problems involving drawing items from categories"
      ],
      "implementation": [
        "Calculated maximum socks held with target_pairs - 1 complete pairs.",
        "Added one unpaired sock per color to maximize count without forming additional pairs.",
        "Added 1 to the sum to ensure the target number of pairs is formed."
      ],
      "used_in": [
        "cmath_2185"
      ]
    },
    "Supply Feasibility Check": {
      "name": "Supply Feasibility Check",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "available_counts",
          "typing": "list of integers",
          "description": "The quantity of items available in each category."
        },
        {
          "name": "min_required_per_category",
          "typing": "integer",
          "description": "The minimum number of items needed from any single category to support the target."
        }
      ],
      "description": "Verifies if the available quantity in each category is sufficient to meet the minimum requirements for the target configuration.",
      "cues": [
        "limited supply",
        "is it possible",
        "constraints on individual category counts"
      ],
      "implementation": [
        "Checked if MIN(color_counts) is less than 2 * target_pairs.",
        "Returned an error indicator if the supply was insufficient to form the target pairs."
      ],
      "used_in": [
        "cmath_2185"
      ]
    },
    "Linear Recurrence Counting": {
      "name": "Linear Recurrence Counting",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "state_definition",
          "typing": "string",
          "description": "Definition of what the sequence term dp[i] represents."
        },
        {
          "name": "base_cases",
          "typing": "list",
          "description": "Initial values for the sequence."
        },
        {
          "name": "transition_rule",
          "typing": "equation",
          "description": "The recurrence relation expressing dp[i] in terms of previous terms."
        }
      ],
      "description": "Solving counting problems by defining a sequence where each term depends on previous terms based on how valid configurations can be extended.",
      "cues": [
        "sequences with local constraints",
        "counting valid configurations of length n",
        "problem structure suggests building solution from smaller subproblems"
      ],
      "implementation": [
        "Defined dp[i] as number of binary sequences of length i with no consecutive 1s.",
        "Set base cases dp[1]=2, dp[2]=3.",
        "Applied transition dp[i] = dp[i-1] + dp[i-2] derived from appending '0' or '01'."
      ],
      "used_in": [
        "cmath_2190"
      ]
    },
    "Geometric Distribution Expectation": {
      "name": "Geometric Distribution Expectation",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "p",
          "typing": "float",
          "description": "Probability of success in a single trial"
        }
      ],
      "description": "The expected number of independent Bernoulli trials needed to achieve the first success is the reciprocal of the probability of success (1/p).",
      "cues": [
        "expected number of trials",
        "until first success",
        "repeated independent trials"
      ],
      "implementation": [
        "Computing expected rolls per day E_day = 1 / p"
      ],
      "used_in": [
        "cmath_2286"
      ]
    },
    "Linearity of Expectation": {
      "name": "Linearity of Expectation",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "Number of independent trials or periods"
        },
        {
          "name": "E_single",
          "typing": "float",
          "description": "Expected value of a single trial or period"
        }
      ],
      "description": "The expected value of a sum of random variables is equal to the sum of their individual expected values. For n identical variables, E[Total] = n * E[Single].",
      "cues": [
        "total expected value",
        "sum of expectations",
        "aggregating over independent periods"
      ],
      "implementation": [
        "Computing total expected rolls E_total = 365 * E_day"
      ],
      "used_in": [
        "cmath_2286"
      ]
    },
    "Constraint-Ordered Counting": {
      "name": "Constraint-Ordered Counting",
      "kind": "counting method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "A strategy for constructive counting where variables are assigned values in descending order of constraint strictness. This ensures the number of available choices for subsequent variables remains constant regardless of specific previous choices, avoiding case analysis.",
      "cues": [
        "Multiple overlapping constraints (e.g., distinctness, parity, non-zero)",
        "Dependencies between variable choices",
        "Need to avoid case splitting in counting",
        "Strictly increasing digit constraints",
        "Distinct digit requirements",
        "Fixed order implies combination logic"
      ],
      "implementation": [
        "Selected Units digit first due to strict parity constraint (Odd).",
        "Selected Hundreds digit second to handle non-zero constraint before Tens.",
        "Ensured option counts remained constant (5, 8, 8) by prioritizing strict constraints.",
        "Fixing the last_digit first as it bounds the available pool for preceding digits",
        "Calculating prefix ways as combinations from available pool {1, ..., last_digit - 1} to avoid case analysis on specific digit values"
      ],
      "used_in": [
        "cmath_2385",
        "cmath_2476"
      ]
    },
    "Graph Modeling": {
      "name": "Graph Modeling",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "entities",
          "typing": "set",
          "description": "The objects to be represented as vertices."
        },
        {
          "name": "relationships",
          "typing": "set of pairs",
          "description": "The interactions to be represented as edges."
        }
      ],
      "description": "Translating a problem involving entities and pairwise relationships into a graph structure (vertices and edges) to leverage graph theoretic tools.",
      "cues": [
        "handshakes",
        "connections between people",
        "pairwise interactions",
        "network structure",
        "relationships between entities"
      ],
      "implementation": [
        "Model people as Vertices V and handshakes as Edges E in Graph G"
      ],
      "used_in": [
        "cmath_2462"
      ]
    },
    "Minimum Degree Constraint": {
      "name": "Minimum Degree Constraint",
      "kind": "definition",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "k",
          "typing": "integer",
          "description": "The minimum number of edges incident to each vertex."
        }
      ],
      "description": "A requirement that every vertex in a graph must have a degree greater than or equal to a specified integer k.",
      "cues": [
        "at least k neighbors",
        "everyone connects to k others",
        "degree >= k",
        "minimum interaction requirement"
      ],
      "implementation": [
        "Constraint: degree(v) >= 2 for all v in V"
      ],
      "used_in": [
        "cmath_2462"
      ]
    },
    "Cycle Graph Edge Count": {
      "name": "Cycle Graph Edge Count",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The number of vertices in the cycle."
        }
      ],
      "description": "A simple cycle graph containing n vertices possesses exactly n edges.",
      "cues": [
        "circular arrangement",
        "closed loop",
        "2-regular graph",
        "minimizing edges for degree 2"
      ],
      "implementation": [
        "Property: A cycle graph with n vertices has exactly n edges",
        "min_handshakes = n_people"
      ],
      "used_in": [
        "cmath_2462"
      ]
    },
    "Minimal Square Multiplier": {
      "name": "Minimal Square Multiplier",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Determines the smallest positive integer required to multiply a given number to make it a perfect square by identifying prime factors with odd exponents in its factorization.",
      "cues": [
        "Find the smallest integer k such that n*k is a perfect square",
        "Problems asking to complete a product to a perfect power"
      ],
      "implementation": [
        "Iterating through the aggregated prime exponents",
        "Multiplying the result by the prime base whenever the total exponent is odd"
      ],
      "used_in": [
        "cmath_4681"
      ]
    },
    "LCM Equation Verification": {
      "name": "LCM Equation Verification",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Verifying if a candidate integer satisfies a specific Least Common Multiple equation LCM(x, n) = L.",
      "cues": [
        "Problem asks for integers satisfying an LCM constraint",
        "Equation of the form LCM(x, n) = K"
      ],
      "implementation": [
        "Using the condition LCM(\u03bd, Base_Number) == Target_LCM to filter valid candidates"
      ],
      "used_in": [
        "cmath_4733"
      ]
    },
    "Terminating Decimal Criterion": {
      "name": "Terminating Decimal Criterion",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "A fraction in lowest terms has a terminating decimal representation if and only if its denominator's prime factorization contains only the primes 2 and 5. Otherwise, the decimal representation is repeating.",
      "cues": [
        "Problems involving decimal representations of rational numbers",
        "Questions about whether a fraction terminates or repeats",
        "Analysis of denominator prime factorization in fraction problems"
      ],
      "implementation": [
        "Used to determine that n/(n+1) has a repeating decimal when denominator (n+1) has prime factors other than 2 or 5",
        "Inverted the criterion to count fractions with repeating (non-terminating) decimals"
      ],
      "used_in": [
        "cmath_4771"
      ]
    },
    "Prime Factor Removal Check": {
      "name": "Prime Factor Removal Check",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Method to verify if a number contains prime factors beyond a specified set by repeatedly dividing out those known factors and checking if the remainder exceeds 1.",
      "cues": [
        "Need to check if a number has specific prime factors",
        "Testing divisibility by a subset of primes",
        "Determining if remaining factors exist after removing known ones"
      ],
      "implementation": [
        "Repeatedly divided denominator by 2 until no longer divisible",
        "Repeatedly divided by 5 until no longer divisible",
        "Checked if remaining value > 1 to confirm other prime factors exist"
      ],
      "used_in": [
        "cmath_4771"
      ]
    },
    "Consecutive Integer Coprimality": {
      "name": "Consecutive Integer Coprimality",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Any two consecutive positive integers are relatively prime, i.e., gcd(n, n+1) = 1 for all n \u2265 1.",
      "cues": [
        "Problems involving fractions with consecutive numerator and denominator",
        "GCD calculations with consecutive integers",
        "Simplifying fractions where numerator and denominator differ by 1"
      ],
      "implementation": [
        "Used to establish that n/(n+1) is already in lowest terms without further reduction",
        "Justified applying the terminating decimal criterion directly to denominator n+1"
      ],
      "used_in": [
        "cmath_4771"
      ]
    },
    "Quadratic Residue Enumeration": {
      "name": "Quadratic Residue Enumeration",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "p",
          "typing": "integer",
          "description": "The prime modulus for which residues are computed."
        }
      ],
      "description": "Generates the set of quadratic residues modulo p by iterating through integers in a range, squaring them, and reducing modulo p.",
      "cues": [
        "Problem involves squares modulo n.",
        "Need to find values x such that x = k^2 mod n.",
        "Analysis of quadratic residues properties (sum, count, etc.)."
      ],
      "implementation": [
        "Iterated n from 1 to p - 1.",
        "Computed r = (n^2) mod p.",
        "Collected results to form the set of residues."
      ],
      "used_in": [
        "cmath_4845"
      ]
    },
    "Divisor Counting Formula": {
      "name": "Divisor Counting Formula",
      "kind": "formula",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Computes the total number of positive divisors of an integer given its prime factorization exponents using the product of (exponent + 1).",
      "cues": [
        "Problem asks for the count of divisors",
        "Prime factorization of the number is available or computable",
        "count divisors of a number",
        "prime factorization exponents available"
      ],
      "implementation": [
        "Calculating count as product of (exponent + 1) for each prime factor of M",
        "Applied formula (e1+1)(e2+1)... to exponents 4, 6, 8 of the prime factors of E"
      ],
      "used_in": [
        "cmath_4855",
        "cmath_5532"
      ]
    },
    "Prime Factorization": {
      "name": "Prime Factorization",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Decomposing an integer into a product of prime powers to analyze its arithmetic properties.",
      "cues": [
        "Divisor counting or summing",
        "GCD/LCM calculations",
        "Analyzing multiplicative functions",
        "Need to decompose a composite integer into prime powers",
        "factor of 10",
        "decompose composite number",
        "2 * 5"
      ],
      "implementation": [
        "Calling prime_factorize(M) to retrieve exponents for the divisor count calculation",
        "Computed prime factors of the residual integer 183 to identify its largest prime component",
        "Decomposed 10 into prime factors 2 and 5 to identify requirements for a trailing zero",
        "Used to reason that factors of 2 are more abundant than factors of 5 in n!"
      ],
      "used_in": [
        "cmath_4855",
        "cmath_4950",
        "cmath_5545"
      ]
    },
    "Perfect Square Verification": {
      "name": "Perfect Square Verification",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Checking if a given integer is the square of an integer, often by computing the integer square root and squaring it back.",
      "cues": [
        "Equations involving squares (e.g., a^2 + b^2 = n)",
        "Conditions requiring a value to be a perfect square"
      ],
      "implementation": [
        "Checking if n - a^2 is a perfect square to determine valid b"
      ],
      "used_in": [
        "cmath_4949"
      ]
    },
    "Ordered Pair Symmetry Counting": {
      "name": "Ordered Pair Symmetry Counting",
      "kind": "counting method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Counting ordered pairs (a, b) by iterating through unordered sets {a, b} and applying weights (2 for distinct elements, 1 for identical) to account for permutations.",
      "cues": [
        "Problem asks for ordered pairs but iteration constraints imply unordered generation (e.g., a <= b)",
        "Symmetric equations (e.g., a^2 + b^2 = n)"
      ],
      "implementation": [
        "Adding 2 to count when a != b (accounting for (a,b) and (b,a))",
        "Adding 1 to count when a == b (accounting for (a,a))"
      ],
      "used_in": [
        "cmath_4949"
      ]
    },
    "Incremental Search for Minimum": {
      "name": "Incremental Search for Minimum",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Iterating integers from a theoretical lower bound upwards to find the smallest value satisfying a predicate, allowing early termination.",
      "cues": [
        "Problem asks for the \"smallest\", \"first\", or \"minimum\" integer satisfying a condition",
        "Search space is ordered and starts from a known bound (e.g., 1)",
        "Initialize k = 1",
        "While S(k) \u2262 0 (mod 200)",
        "k \u2190 k + 1",
        "Return k"
      ],
      "implementation": [
        "Looping n from 1 upwards until CountOrderedPairs(n) == 3",
        "Returning n immediately upon finding the first match",
        "Iterates integers starting from the lower bound k=1 upwards.",
        "Terminates immediately upon finding the first k satisfying the divisibility predicate.",
        "Guarantees the returned value is the minimum solution."
      ],
      "used_in": [
        "cmath_4949",
        "cmath_5274"
      ]
    },
    "Factorial Sum Factorization": {
      "name": "Factorial Sum Factorization",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Simplifying a sum of factorials by factoring out the smaller factorial term to convert the expression into a product, facilitating divisibility or prime factor analysis.",
      "cues": [
        "Expression involves a sum of factorials (e.g., n! + m!)",
        "Goal involves finding divisors, prime factors, or simplifying the expression"
      ],
      "implementation": [
        "Factored 12! out of 12! + 14! to obtain 12! * (1 + 14 * 13)"
      ],
      "used_in": [
        "cmath_4950"
      ]
    },
    "Largest Prime Factor of Factorial": {
      "name": "Largest Prime Factor of Factorial",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The integer defining the factorial"
        }
      ],
      "description": "The greatest prime factor of n! is the largest prime number less than or equal to n.",
      "cues": [
        "Analyzing prime factors of a factorial term n!",
        "Determining the greatest prime factor of an expression containing factorials"
      ],
      "implementation": [
        "Determined the largest prime factor of 12! is the largest prime <= 12"
      ],
      "used_in": [
        "cmath_4950"
      ]
    },
    "Modular Power Cycle": {
      "name": "Modular Power Cycle",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "base",
          "typing": "integer",
          "description": "The base of the power (e.g., the prime p)."
        },
        {
          "name": "modulus",
          "typing": "integer",
          "description": "The modulus for the cycle (e.g., 10 for ones digit)."
        },
        {
          "name": "exponent",
          "typing": "integer",
          "description": "The large exponent to be reduced."
        }
      ],
      "description": "Exploits the periodic sequence of powers of an integer modulo m to reduce large exponents by computing the exponent modulo the cycle length.",
      "cues": [
        "ones digit",
        "last digit",
        "large power",
        "find the digit of a^b",
        "Large exponent in modular arithmetic expression",
        "Need to simplify power computation modulo m",
        "large exponents",
        "periodicity of powers",
        "repeating units digits",
        "tower of powers"
      ],
      "implementation": [
        "Identified the cycle length of 2^k mod 10 is 4.",
        "Reduced the calculated Legendre exponent modulo 4 to find the effective exponent.",
        "Handled the case where exponent mod cycle_length is 0 by mapping to the last element of the cycle.",
        "Reduced exponent 1999 modulo phi(25) to simplify calculation",
        "Identified the cycle length of 2^k mod 10 as 4.",
        "Reduced the tower exponent (2^n) modulo the cycle length (4) to simplify computation.",
        "Handled the edge case where the reduced exponent is 0 by mapping it to the cycle length (4), as 2^0 != 2^4 mod 10."
      ],
      "used_in": [
        "cmath_5031",
        "cmath_5177",
        "cmath_5543"
      ]
    },
    "Base-b Digit Count Formula": {
      "name": "Base-b Digit Count Formula",
      "kind": "formula",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The positive integer value to be represented."
        },
        {
          "name": "b",
          "typing": "integer",
          "description": "The target base for representation (b >= 2)."
        }
      ],
      "description": "Calculates the number of digits required to represent a positive integer n in base b using the formula floor(log_b(n)) + 1.",
      "cues": [
        "Calculate the number of base-2 digits",
        "log_base",
        "floor"
      ],
      "implementation": [
        "Applied floor(log_2(min_val)) + 1 to determine the minimum digit count.",
        "Applied floor(log_2(max_val)) + 1 to determine the maximum digit count."
      ],
      "used_in": [
        "cmath_5075"
      ]
    },
    "Euler's Totient Theorem": {
      "name": "Euler's Totient Theorem",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "base",
          "typing": "integer",
          "description": "The integer base 'a' which must be coprime to the modulus"
        },
        {
          "name": "modulus",
          "typing": "integer",
          "description": "The modulus 'n' for the congruence"
        }
      ],
      "description": "States that if gcd(a, n) = 1, then a^phi(n) \u2261 1 (mod n), allowing exponent reduction modulo phi(n).",
      "cues": [
        "Computing a^b mod n where b is large",
        "Base and modulus are coprime",
        "Large exponent in modular expression",
        "Prime modulus involved",
        "Need to simplify exponent"
      ],
      "implementation": [
        "Used to determine that 19^phi(25) \u2261 1 (mod 25), justifying exponent reduction",
        "Used Fermat's Little Theorem variant (phi(P) = P-1)",
        "Reduced exponent 333 modulo 10 (11-1)"
      ],
      "used_in": [
        "cmath_5177",
        "cmath_5421"
      ]
    },
    "Modular Exponentiation": {
      "name": "Modular Exponentiation",
      "kind": "algorithm",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "base",
          "typing": "integer",
          "description": "The base of the power"
        },
        {
          "name": "exponent",
          "typing": "integer",
          "description": "The reduced exponent"
        },
        {
          "name": "modulus",
          "typing": "integer",
          "description": "The modulus for the operation"
        }
      ],
      "description": "Efficiently computes (base^exponent) % modulus using binary exponentiation (square-and-multiply).",
      "cues": [
        "Final computation of a power modulo m",
        "Exponent is manageable after reduction",
        "Computing power with modulus",
        "Base and exponent may be large"
      ],
      "implementation": [
        "Computed 19^reduced_exponent % 25 to get the final result",
        "Computed (3^3) mod 11 after reductions",
        "Final step to obtain result"
      ],
      "used_in": [
        "cmath_5177",
        "cmath_5421"
      ]
    },
    "Linear Congruence Resolution": {
      "name": "Linear Congruence Resolution",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "coeff",
          "typing": "integer",
          "description": "The coefficient 'a' of the variable x."
        },
        {
          "name": "constant",
          "typing": "integer",
          "description": "The constant term 'b' on the RHS."
        },
        {
          "name": "modulus",
          "typing": "integer",
          "description": "The modulus 'm'."
        }
      ],
      "description": "Solves a linear congruence equation ax \u2261 b (mod m) by reducing coefficients via GCD and computing the modular inverse to isolate x.",
      "cues": [
        "Equation of the form ax \u2261 b (mod m).",
        "Need to isolate variable x in a modular equation."
      ],
      "implementation": [
        "Computed g = GCD(coeff, modulus) to reduce the equation.",
        "Divided coeff, constant, and modulus by g.",
        "Computed modular inverse of reduced coefficient to find the residue."
      ],
      "used_in": [
        "cmath_5178"
      ]
    },
    "Chinese Remainder Theorem": {
      "name": "Chinese Remainder Theorem",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "congruences",
          "typing": "list of tuples",
          "description": "List of (residue, modulus) pairs representing x \u2261 residue (mod modulus)."
        }
      ],
      "description": "Constructs a unique solution modulo the product of moduli for a system of linear congruences with pairwise coprime moduli.",
      "cues": [
        "System of multiple modular congruences.",
        "Moduli are pairwise coprime.",
        "Need to find a single integer satisfying all conditions."
      ],
      "implementation": [
        "Computed M_total as the product of all reduced moduli.",
        "Iterated through each congruence to compute partial terms (N_i * y_i * residue).",
        "Summed partial terms modulo M_total to find the base solution x_0."
      ],
      "used_in": [
        "cmath_5178"
      ]
    },
    "Polynomial Divisibility Reduction": {
      "name": "Polynomial Divisibility Reduction",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "polynomial",
          "typing": "expression",
          "description": "The polynomial expression P(n) being divided."
        },
        {
          "name": "linear_divisor",
          "typing": "expression",
          "description": "The linear expression L(n) that divides P(n)."
        },
        {
          "name": "variable",
          "typing": "symbol",
          "description": "The variable n common to both expressions."
        }
      ],
      "description": "Transforms a divisibility condition where a linear polynomial divides another polynomial into a constant divisibility condition using the Polynomial Remainder Theorem.",
      "cues": [
        "Divisibility constraint involving a polynomial and a linear term in the same variable.",
        "Need to find integer values of a variable satisfying a polynomial divisibility condition."
      ],
      "implementation": [
        "Applied to condition (n + 10) | (n^3 + 100).",
        "Evaluated n^3 + 100 at n = -10 (root of divisor) to get remainder -900.",
        "Reduced condition to (n + 10) | 900."
      ],
      "used_in": [
        "cmath_5235"
      ]
    },
    "Binary-to-Base-k Digit Mapping": {
      "name": "Binary-to-Base-k Digit Mapping",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "index",
          "typing": "integer",
          "description": "The position n in the sequence (1-based or 0-based)."
        },
        {
          "name": "target_base",
          "typing": "integer",
          "description": "The base k used for the sequence values (e.g., 3 for sums of distinct powers of 3)."
        }
      ],
      "description": "Determines the n-th term of a sequence formed by integers having only digits 0 and 1 in base k by interpreting the binary representation of n as a number in base k. This relies on the order-preserving bijection between the binary index and the restricted-digit values.",
      "cues": [
        "sequence elements are sums of distinct powers of a base",
        "base-k representation contains only digits 0 and 1",
        "order-preserving bijection between binary integers and this sequence",
        "finding the nth term of such a sequence"
      ],
      "implementation": [
        "Mapped the binary coefficients of n to powers of 3 to compute T_n",
        "Utilized the bijection to avoid brute-force generation of the sequence"
      ],
      "used_in": [
        "cmath_5236"
      ]
    },
    "Leading Digit via Logarithmic Fractional Part": {
      "name": "Leading Digit via Logarithmic Fractional Part",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "number_expression",
          "typing": "mathematical expression",
          "description": "The expression representing the large number (e.g., b^k)."
        },
        {
          "name": "log_base",
          "typing": "integer",
          "description": "The base of the logarithm, typically 10 for decimal leading digits."
        }
      ],
      "description": "Determines the leading digit of a number N by computing the fractional part f of log10(N) and evaluating floor(10^f), avoiding direct computation of N.",
      "cues": [
        "Problem asks for the leading digit of a large power or product.",
        "Direct computation of the number is infeasible due to size."
      ],
      "implementation": [
        "Computed fractional_part as {k * LOG_9} representing the fractional part of log10(9^k).",
        "Derived leading_digit using floor(10 ^ fractional_part)."
      ],
      "used_in": [
        "cmath_5246"
      ]
    },
    "Difference of Squares Characterization": {
      "name": "Difference of Squares Characterization",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The integer to test for representability as a difference of squares."
        }
      ],
      "description": "An integer n can be expressed as the difference of two squares (a^2 - b^2) if and only if n is not congruent to 2 modulo 4. This arises because factors (a+b) and (a-b) must have the same parity.",
      "cues": [
        "Problem involves expressing numbers as a^2 - b^2.",
        "Constraints on parity or modulo 4 appear in the problem statement or derivation.",
        "Need to filter integers based on arithmetic properties rather than brute force."
      ],
      "implementation": [
        "Used algebraic identity n = (a+b)(a-b) to deduce parity constraints on factors.",
        "Derived that n cannot be congruent to 2 (mod 4) because factors must share parity (both odd or both even).",
        "Identified the set of excluded integers as those satisfying k \u2261 2 (mod 4)."
      ],
      "used_in": [
        "cmath_5260"
      ]
    },
    "Arithmetic Progression Count": {
      "name": "Arithmetic Progression Count",
      "kind": "formula",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "start",
          "typing": "integer",
          "description": "The first term of the arithmetic progression."
        },
        {
          "name": "step",
          "typing": "integer",
          "description": "The common difference between consecutive terms."
        },
        {
          "name": "limit",
          "typing": "integer",
          "description": "The upper bound for the terms."
        }
      ],
      "description": "Calculates the number of terms in an arithmetic progression (start, start+step, ...) that are less than or equal to a given limit.",
      "cues": [
        "Need to count integers satisfying a linear congruence (e.g., k \u2261 r mod m).",
        "Excluded or included values form a regular sequence with constant difference.",
        "Range is large, requiring an O(1) formula instead of iteration."
      ],
      "implementation": [
        "Applied to count integers k in [1, upper_bound] where k \u2261 2 (mod 4).",
        "Sequence identified as 2, 6, 10, ... (start=2, step=4).",
        "Computed count using FLOOR((limit - start) / step) + 1."
      ],
      "used_in": [
        "cmath_5260"
      ]
    },
    "Sum of Squares Formula": {
      "name": "Sum of Squares Formula",
      "kind": "formula",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "k",
          "typing": "integer",
          "description": "The number of terms to sum (upper bound of the sequence 1^2 + ... + k^2)"
        }
      ],
      "description": "Expresses the sum of the first k positive squares as a cubic polynomial k(k+1)(2k+1)/6.",
      "cues": [
        "Define S(k) = k(k + 1)(2k + 1) / 6"
      ],
      "implementation": [
        "Replaces the iterative summation of squares with a closed-form polynomial expression.",
        "Allows efficient computation of S(k) for each candidate k during the search."
      ],
      "used_in": [
        "cmath_5274"
      ]
    },
    "Minimal Scaling Factor for Integrality": {
      "name": "Minimal Scaling Factor for Integrality",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "expressions",
          "typing": "list of rational linear forms",
          "description": "The set of expressions in terms of k that must evaluate to integers."
        },
        {
          "name": "k",
          "typing": "integer",
          "description": "The scaling factor to be minimized."
        }
      ],
      "description": "Determines the smallest positive integer parameter k such that a set of linear expressions in k evaluate to integers, typically by computing the LCM of the denominators of the coefficients.",
      "cues": [
        "least positive integer k",
        "quantities ... are integers",
        "minimum total",
        "rational coefficients"
      ],
      "implementation": [
        "Analyzed the expressions for x, y, z in terms of k to identify denominators.",
        "Computed the LCM of the denominators to find the minimal k ensuring all quantities are integers.",
        "Used the minimal k to calculate the minimum total number of bananas."
      ],
      "used_in": [
        "cmath_5283"
      ]
    },
    "Linear Diophantine Non-negative Counting": {
      "name": "Linear Diophantine Non-negative Counting",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "coefficients",
          "typing": "list of integers",
          "description": "Coefficients A and B of the variables in the linear equation"
        },
        {
          "name": "target",
          "typing": "integer",
          "description": "The constant term C on the right hand side"
        }
      ],
      "description": "Counts non-negative integer solutions to a linear equation Ax + By = C by parameterizing the general solution and determining the valid range of the parameter.",
      "cues": [
        "Linear equation on integer variables",
        "Non-negativity constraints",
        "Counting valid solutions"
      ],
      "implementation": [
        "Parameterized solution for y, derived bounds for parameter k from x>=0 and y>=0"
      ],
      "used_in": [
        "cmath_5291"
      ]
    },
    "Balanced Base Contiguous Range": {
      "name": "Balanced Base Contiguous Range",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "powers_count",
          "typing": "integer",
          "description": "The number of digit positions (powers of the base) available."
        },
        {
          "name": "base",
          "typing": "integer",
          "description": "The radix of the number system."
        }
      ],
      "description": "States that a balanced base system with coefficients {-1, 0, 1} uniquely represents all integers within the continuous range [-M, M], where M is the maximum representable value, ensuring no gaps in the representable set.",
      "cues": [
        "balanced base system",
        "counting representable integers",
        "continuous range assumption",
        "symmetric digit set"
      ],
      "implementation": [
        "Used to justify that the count of representable non-negative integers is exactly the cardinality of the range `[0, max_val]` without gaps."
      ],
      "used_in": [
        "cmath_5330"
      ]
    },
    "Consecutive Digit Sum Relation": {
      "name": "Consecutive Digit Sum Relation",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "S_n",
          "typing": "integer",
          "description": "The sum of digits of the integer n"
        },
        {
          "name": "S_next",
          "typing": "integer",
          "description": "The sum of digits of the integer n+1"
        },
        {
          "name": "k",
          "typing": "integer",
          "description": "The number of trailing 9s in the decimal representation of n (number of carries)"
        }
      ],
      "description": "Relates the sum of digits of consecutive integers n and n+1 via the formula S(n+1) = S(n) + 1 - 9k, where k is the number of trailing 9s in n. This implies S(n+1) <= S(n) + 1 and S(n+1) is congruent to S(n) + 1 modulo 9.",
      "cues": [
        "Problems involving digit sums of consecutive integers",
        "Constraints relating S(n) and S(n+1)",
        "Divisibility by 9 in digit sum differences",
        "Inequality constraints between consecutive digit sums"
      ],
      "implementation": [
        "Calculated theoretical maximum digit sum for n+1 as S_n + 1",
        "Validated candidate digit sums by checking if the difference from the maximum is a non-negative multiple of 9"
      ],
      "used_in": [
        "cmath_5334"
      ]
    },
    "Exponential Growth Bounding": {
      "name": "Exponential Growth Bounding",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "exponential_terms",
          "typing": "list of expressions",
          "description": "The terms containing variables in exponents"
        },
        {
          "name": "constant",
          "typing": "integer",
          "description": "The target value the terms sum to or differ by"
        }
      ],
      "description": "Limiting the search space for variables in exponential equations by observing that terms grow rapidly relative to the constant value, ensuring the search space is finite and small.",
      "cues": [
        "Equation involves exponential terms equal to a small constant",
        "Variables appear in exponents"
      ],
      "implementation": [
        "Determining bounds for x and y such that 2^(2x) and 3^(2y) do not excessively exceed 55 before starting iteration"
      ],
      "used_in": [
        "cmath_5342"
      ]
    },
    "Greedy Prime Exponent Assignment": {
      "name": "Greedy Prime Exponent Assignment",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "exponents",
          "typing": "list[int]",
          "description": "The multiset of exponents derived from the problem constraints."
        },
        {
          "name": "prime_sequence",
          "typing": "list[int]",
          "description": "The ordered sequence of distinct primes (e.g., 2, 3, 5...) to be used as bases."
        }
      ],
      "description": "To minimize an integer N = product(p_i ^ e_i) given a fixed multiset of exponents, assign the largest exponents to the smallest distinct prime bases.",
      "cues": [
        "Problem asks for the minimum integer satisfying a condition defined by prime exponents (e.g., divisor count).",
        "The choice of prime bases is flexible (not fixed by the problem).",
        "Exponents are determined by structural constraints (e.g., factors of divisor count)."
      ],
      "implementation": [
        "Sorted the derived exponents E in descending order.",
        "Assigned the largest exponent to the smallest prime (2), the second largest to 3, etc.",
        "Ensured the constructed candidate number was minimized for each partition configuration."
      ],
      "used_in": [
        "cmath_5475"
      ]
    },
    "Consecutive Product Divisibility": {
      "name": "Consecutive Product Divisibility",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "The product of any k consecutive integers is divisible by k!.",
      "cues": [
        "Polynomial expression factors into consecutive integer terms (e.g., (n-1)n(n+1))",
        "Problem involves divisibility of polynomial values over all integers"
      ],
      "implementation": [
        "Used to establish a theoretical baseline divisor (3! = 6) for the factored expression (n-1)n(n+1)"
      ],
      "used_in": [
        "cmath_5540"
      ]
    },
    "Fixed Divisor Determination": {
      "name": "Fixed Divisor Determination",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Determining the largest integer that divides a polynomial's value for all integer inputs by computing the GCD of the polynomial's values at a sufficient set of sample points.",
      "cues": [
        "Problem asks for the largest universal divisor of a polynomial expression over integers",
        "Need to find the tightest bound on a common divisor"
      ],
      "implementation": [
        "Evaluated the expression for specific small integers to generate a set of values",
        "Computed the GCD of these values to find the exact universal divisor"
      ],
      "used_in": [
        "cmath_5540"
      ]
    },
    "Exponent Divisibility Threshold": {
      "name": "Exponent Divisibility Threshold",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "base",
          "typing": "integer",
          "description": "The base of the exponential expression (e.g., 2)."
        },
        {
          "name": "modulus",
          "typing": "integer",
          "description": "The divisor used to check divisibility (e.g., 4)."
        },
        {
          "name": "threshold",
          "typing": "integer",
          "description": "The minimum exponent value n such that base^n is divisible by modulus for all n >= threshold."
        }
      ],
      "description": "Determines the minimum value of an exponent variable beyond which a base raised to that exponent is guaranteed to be divisible by a specific modulus, allowing constant-time reduction of tower exponents.",
      "cues": [
        "power tower exponent reduction",
        "exponent modulo cycle length",
        "conditional exponent simplification",
        "non-coprime base modular arithmetic"
      ],
      "implementation": [
        "Applied the property that 2^n is divisible by 4 for all n >= 2.",
        "Used an IF condition (n >= 2) to bypass modular calculation of the exponent and directly assign the cycle length."
      ],
      "used_in": [
        "cmath_5543"
      ]
    },
    "Complementary Probability": {
      "name": "Complementary Probability",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "p_event",
          "typing": "float",
          "description": "Probability of the event occurring in a single trial."
        }
      ],
      "description": "Calculates the probability of an event occurring at least once by subtracting the probability of it never occurring from 1.",
      "cues": [
        "at least one success",
        "target probability",
        "minimum trials"
      ],
      "implementation": [
        "Step 1 converts target success probability to max allowed failure probability using 1 - p_success."
      ],
      "used_in": [
        "cmath_8735"
      ]
    },
    "Independent Event Probability Product": {
      "name": "Independent Event Probability Product",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "probabilities",
          "typing": "list of float",
          "description": "List of probabilities for each independent event."
        }
      ],
      "description": "The probability of multiple independent events all occurring is the product of their individual probabilities.",
      "cues": [
        "independent trials",
        "repeated experiments",
        "all failures"
      ],
      "implementation": [
        "Step 2 models P(all failures) as (p_failure)^n."
      ],
      "used_in": [
        "cmath_8735"
      ]
    },
    "Logarithmic Exponent Isolation": {
      "name": "Logarithmic Exponent Isolation",
      "kind": "algebraic manipulation",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "base",
          "typing": "float",
          "description": "The base of the exponential term."
        },
        {
          "name": "target",
          "typing": "float",
          "description": "The value the exponential term is compared against."
        }
      ],
      "description": "Solving for an exponent variable in an exponential inequality by applying logarithms to both sides.",
      "cues": [
        "variable in exponent",
        "exponential inequality",
        "base < 1"
      ],
      "implementation": [
        "Step 3 solves n using log(max_allowed) / log(p_failure)."
      ],
      "used_in": [
        "cmath_8735"
      ]
    },
    "Minimum Integer Ceiling": {
      "name": "Minimum Integer Ceiling",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "real_bound",
          "typing": "float",
          "description": "The real-valued solution to the inequality."
        }
      ],
      "description": "Converting a real-valued lower bound derived from an inequality into the minimum satisfying integer using the ceiling function.",
      "cues": [
        "minimum integer",
        "discrete trials",
        "inequality solution"
      ],
      "implementation": [
        "Step 4 applies ceiling to n_real to find n_min."
      ],
      "used_in": [
        "cmath_8735"
      ]
    },
    "Principle of Inclusion-Exclusion": {
      "name": "Principle of Inclusion-Exclusion",
      "kind": "counting method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "A combinatorial technique to calculate the number of elements satisfying none of several properties by alternately adding and subtracting the sizes of intersections of subsets of properties.",
      "cues": [
        "Problem involves counting objects that must satisfy all of a set of conditions (e.g., surjectivity, derangements).",
        "Solution structure involves an alternating summation with terms like (-1)^k.",
        "Constraints are defined by the exclusion of specific properties or subsets."
      ],
      "implementation": [
        "Used to count surjective mappings by summing over the number of excluded targets.",
        "Alternates sign based on the count of excluded targets `i` using `(-1)^i`.",
        "Computes term magnitude as the product of ways to choose excluded targets and ways to map to the rest."
      ],
      "used_in": [
        "cmath_9112"
      ]
    }
  },
  "solutions": {
    "cmath_10550": {
      "problem_id": "cmath_10550",
      "solution": null,
      "summary": "Parametrize integers by their GCD to simplify LCM constraints, fix one factor, and maximize the other under coprimality and bound conditions.",
      "pseudocode": "Function MaximizeSumGivenGCDandLCM(gcd_val, lcm_multiplier, upper_bound):\n    // Parametrize integers as x = gcd_val * a, y = gcd_val * b with gcd(a, b) = 1\n    // LCM condition: LCM(x, y) = lcm_multiplier * x implies b = lcm_multiplier\n    fixed_factor = lcm_multiplier\n    fixed_num = gcd_val * fixed_factor\n    \n    // Determine maximum possible value for factor 'a' based on upper_bound\n    max_a = floor((upper_bound - 1) / gcd_val)\n    \n    // Find largest 'a' <= max_a such that gcd(a, fixed_factor) == 1\n    For a from max_a down to 1:\n        If gcd(a, fixed_factor) == 1:\n            variable_num = gcd_val * a\n            Return variable_num + fixed_num"
    },
    "cmath_10564": {
      "problem_id": "cmath_10564",
      "solution": null,
      "summary": "Compute the summation of the recursively defined sequence terms and extract the units digit via modulo 10.",
      "pseudocode": "DEFINE FUNCTION DoubleFactorial(n):\n    IF n <= 1 RETURN 1\n    RETURN n * DoubleFactorial(n - 2)\n\nINITIALIZE total_sum = 0\nFOR each odd integer i FROM 1 TO 49:\n    total_sum += DoubleFactorial(i)\n\nRETURN total_sum MOD 10"
    },
    "cmath_10590": {
      "problem_id": "cmath_10590",
      "solution": null,
      "summary": "Convert base-specific digit constraints to base-10 value ranges, compute their intersection, and calculate the mean of the resulting consecutive integer sequence.",
      "pseudocode": "FUNCTION get_base_range(num_digits, base):\n    # Smallest number with n digits in base b is b^(n-1)\n    min_val = base^(num_digits - 1)\n    # Largest number with n digits in base b is b^n - 1\n    max_val = base^num_digits - 1\n    RETURN (min_val, max_val)\n\nFUNCTION solve():\n    # Convert base-specific digit constraints to base-10 value ranges\n    range_base3 = get_base_range(4, 3)\n    range_base6 = get_base_range(2, 6)\n    \n    # Find the intersection of the two value ranges\n    intersection_start = MAX(range_base3.min, range_base6.min)\n    intersection_end = MIN(range_base3.max, range_base6.max)\n    \n    # Calculate the average of the consecutive integers in the intersection\n    IF intersection_start <= intersection_end:\n        # Average of an arithmetic progression of consecutive integers\n        average = (intersection_start + intersection_end) / 2\n        RETURN average\n    ELSE:\n        RETURN 0"
    },
    "cmath_10600": {
      "problem_id": "cmath_10600",
      "solution": null,
      "summary": "Convert base-b numerals to polynomials in b and search for the integer root exceeding the maximum digit.",
      "pseudocode": "1. Identify the maximum digit D present in all numbers within the equation\n2. Set the minimum valid base b_min = D + 1\n3. Convert each number from base-b representation to a polynomial in b\n   (e.g., digits d_n...d_0 map to sum(d_i * b^i))\n4. Construct the algebraic equation: Polynomial(operand1) * Polynomial(operand2) = Polynomial(result)\n5. Iterate integer b starting from b_min upwards\n6. Evaluate the equation for each b\n7. Return the first b where the equation holds true"
    },
    "cmath_10604": {
      "problem_id": "cmath_10604",
      "solution": null,
      "summary": "Generate all possible sums via Cartesian product with replacement, collect distinct values, and compute their total.",
      "pseudocode": "Define value_set = {2, 4, 8}\nDefine pick_count = 3\nGenerate all outcomes via Cartesian_Product(value_set, repeat=pick_count)\nMap each outcome to its sum\nStore sums in a Set to ensure uniqueness\nCompute final answer as the Sum of all elements in the Set"
    },
    "cmath_10610": {
      "problem_id": "cmath_10610",
      "solution": null,
      "summary": "Derive the exponent for the product of proper divisors using the divisor count formula, equate coefficients with the given expression, and solve for parameters under GCD constraints.",
      "pseudocode": "Function CalculateParameterSum():\n    // Step 1: Establish the formula for the product of all divisors\n    // Concept: Product of divisors of n with count x is n^(x/2)\n    Let exponent_all = x / 2\n    \n    // Step 2: Adjust for proper divisors (exclude n itself)\n    // Concept: Proper product = Total product / n\n    Let exponent_proper = exponent_all - 1\n    Simplify exponent_proper to (x - 2) / 2\n    \n    // Step 3: Equate derived exponent to the given parameterized form\n    // Given form: (a*x + b) / c\n    Set (a*x + b) / c == (x - 2) / 2\n    \n    // Step 4: Solve for parameters by matching coefficients of x and constants\n    // Concept: Identity in x implies coefficients must match\n    Match coefficient of x: a/c = 1/2  => c = 2a\n    Match constant term: b/c = -1      => b = -c\n    \n    // Step 5: Determine integer values satisfying GCD constraint\n    // Constraint: gcd(a, b, c) = 1 and c > 0\n    Substitute c = 2a into b = -c => b = -2a\n    Ratio a : b : c is 1 : -2 : 2\n    Set a = 1, b = -2, c = 2 (satisfies gcd(1, -2, 2) = 1)\n    \n    // Step 6: Compute final result\n    Return a + b + c"
    },
    "cmath_10619": {
      "problem_id": "cmath_10619",
      "solution": null,
      "summary": "Classify integers with exactly four divisors as prime cubes or products of two distinct primes, generate candidates from small primes, and sum the five smallest.",
      "pseudocode": "FUNCTION SolveSmallestFourFactorSum(k):\n    // Concept: Divisor Count Structure\n    // An integer n has exactly 4 factors iff n = p^3 OR n = p * q (p, q distinct primes)\n    \n    primes = GENERATE_FIRST_N_PRIMES(sufficient_limit)\n    candidates = EMPTY_LIST\n    \n    // Generate Case 1: Cube of a prime\n    FOR EACH p IN primes:\n        APPEND p^3 TO candidates\n        \n    // Generate Case 2: Product of two distinct primes\n    FOR EACH pair (p, q) IN primes WHERE p < q:\n        APPEND p * q TO candidates\n        \n    // Selection and Aggregation\n    SORT candidates ASCENDING\n    smallest_k = TAKE_FIRST(candidates, k)\n    \n    RETURN SUM(smallest_k)"
    },
    "cmath_10621": {
      "problem_id": "cmath_10621",
      "solution": null,
      "summary": "Iterate through the valid range and count integers satisfying the single-digit GCD constraint with 100.",
      "pseudocode": "Initialize count to 0\nFor each integer m from 1 to 99:\n    Compute g = gcd(m, 100)\n    If g is a single-digit number (1 <= g <= 9):\n        Increment count\nReturn count"
    },
    "cmath_10627": {
      "problem_id": "cmath_10627",
      "solution": null,
      "summary": "Use prime valuation properties of LCM to derive the exponent of 2 in $m$, then determine the specific value using the 3-digit constraint.",
      "pseudocode": "Function SolveLCMEquation():\n    Decompose constants into prime factors: 10^10 = 2^10 * 5^10, 8 = 2^3, 4 = 2^2\n    Represent m as 2^a * 5^b * k, where gcd(k, 10) = 1\n    \n    // Apply property: v_p(lcm(x, y)) = max(v_p(x), v_p(y))\n    For prime p in {2, 5}:\n        LHS_val = max(v_p(8m), v_p(10^10))\n        RHS_val = v_p(4) + max(v_p(m), v_p(10^10))\n        Set LHS_val = RHS_val to form exponent equations\n    \n    Solve exponent equation for p=2: max(a + 3, 10) = 2 + max(a, 10)\n        Case 1 (a >= 7): a + 3 = 12 => a = 9\n        Case 2 (a < 7): 10 = a + 2 => a = 8 (Invalid)\n        Determine a = 9\n    \n    Solve exponent equation for p=5: max(b, 10) = max(b, 10)\n        Determine b is unconstrained by equation\n    \n    Construct candidate m = 2^9 * 5^b * k = 512 * 5^b * k\n    Apply constraint: 100 <= m <= 999\n    Find unique integers b >= 0, k >= 1 satisfying range\n    Return m"
    },
    "cmath_10630": {
      "problem_id": "cmath_10630",
      "solution": null,
      "summary": "Compute the prime factorization of the number and multiply the count of valid even exponent choices ($\\lfloor e/2 \\rfloor + 1$) for each prime factor.",
      "pseudocode": "FUNCTION count_perfect_square_factors(N):\n    factorization = get_prime_factorization(N)  // Returns {prime: exponent}\n    total_count = 1\n    FOR each exponent e IN factorization.values():\n        // Exponents in a perfect square factor must be even (0, 2, ..., 2k <= e)\n        num_even_choices = floor(e / 2) + 1\n        total_count = total_count * num_even_choices\n    RETURN total_count"
    },
    "cmath_10637": {
      "problem_id": "cmath_10637",
      "solution": null,
      "summary": "Determine valid bases by counting divisors of the difference between the number and the target digit that exceed the digit value.",
      "pseudocode": "INPUT: Integer N = 2013, Target Digit d = 3\nDERIVE: Condition for last digit d in base b is N mod b = d\nTRANSFORM: This implies b divides (N - d)\nCOMPUTE: Difference M = N - d = 2010\nFIND: Set of all positive divisors D of M\nAPPLY CONSTRAINT: Base b must be strictly greater than digit d (b > 3)\nFILTER: Valid Bases = {b in D | b > d}\nOUTPUT: Count of Valid Bases"
    },
    "cmath_10664": {
      "problem_id": "cmath_10664",
      "solution": null,
      "summary": "Equate the denominator to all integer divisors of the numerator, solve for the variable, and sum the resulting integer solutions.",
      "pseudocode": "1. Identify the condition: For the fraction to be an integer, the Denominator must divide the Numerator\n2. Find all integer divisors D of the Numerator (including negative divisors)\n3. Initialize ValidSum = 0\n4. For each divisor d in D:\n    a. Set Denominator Expression = d\n    b. Solve the resulting equation for x\n    c. Check if x is an integer\n    d. If x is an integer, add x to ValidSum\n5. Return ValidSum"
    },
    "cmath_10691": {
      "problem_id": "cmath_10691",
      "solution": null,
      "summary": "Count multiples of the truth and response divisors and their LCM to calculate correct answers using set difference logic.",
      "pseudocode": "FUNCTION calculate_correct_answers(total_items, true_divisor, mark_false_divisor, lcm_divisor):\n    // Count items satisfying the actual truth condition (multiples of 4)\n    count_actual_true <- FLOOR(total_items / true_divisor)\n    \n    // Count items satisfying the student's false marking condition (multiples of 3)\n    count_marked_false <- FLOOR(total_items / mark_false_divisor)\n    \n    // Count items satisfying both conditions (multiples of 12)\n    count_intersection <- FLOOR(total_items / lcm_divisor)\n    \n    // Correct True: Actually True AND Student marks True (not marked false)\n    correct_true <- count_actual_true - count_intersection\n    \n    // Correct False: Actually False AND Student marks False\n    correct_false <- count_marked_false - count_intersection\n    \n    RETURN correct_true + correct_false"
    },
    "cmath_10695": {
      "problem_id": "cmath_10695",
      "solution": null,
      "summary": "Translate base representations into polynomial equations, derive a linear relationship between the bases, and solve the resulting quadratic equation for positive integer solutions.",
      "pseudocode": "PROCEDURE SolveBaseSystem:\n    // Step 1: Convert base-c representation to algebraic equation\n    // Concept: Base Expansion (Polynomial Form)\n    EQUATION_1 <- b^2 = 1*c^2 + 2*c + 1\n    \n    // Step 2: Simplify to find relationship between b and c\n    // Concept: Factoring Perfect Squares\n    SIMPLIFY EQUATION_1 TO b^2 = (c + 1)^2\n    DERIVE LINEAR_RELATION: b = c + 1 (since b, c > 0)\n    \n    // Step 3: Convert base-b representation to algebraic equation\n    // Concept: Base Expansion (Polynomial Form)\n    EQUATION_2 <- c^2 = 7*b + 1\n    \n    // Step 4: Combine equations to solve for one variable\n    // Concept: Substitution\n    SUBSTITUTE LINEAR_RELATION INTO EQUATION_2\n    FORM_QUADRATIC: c^2 - 7c - 8 = 0\n    \n    // Step 5: Solve quadratic and apply domain constraints\n    // Concept: Quadratic Formula & Integer Constraints\n    ROOTS <- SOLVE(c^2 - 7c - 8 = 0)\n    c <- SELECT root FROM ROOTS WHERE root > 0 AND root IS INTEGER\n    \n    // Step 6: Compute final result\n    b <- c + 1\n    RETURN b + c\nEND PROCEDURE"
    },
    "cmath_10731": {
      "problem_id": "cmath_10731",
      "solution": null,
      "summary": "Model consumption fractions as a linear equation, apply divisibility constraints to simplify variables, and solve the resulting Diophantine equation for the family size.",
      "pseudocode": "Define M as total milk ounces, C as total coffee ounces\nSet up equation based on Angela's consumption: M/4 + C/6 = 8\nSimplify equation to integer coefficients: 3M + 2C = 96\nApply constraint: M and C must be multiples of 8 (let M = 8m, C = 8c)\nSubstitute constraints into simplified equation: 3m + 2c = 12\nIterate through positive integer values for m\n  Calculate c = (12 - 3m) / 2\n  If c is a positive integer:\n    Compute family size n = m + c\n    Return n"
    },
    "cmath_10774": {
      "problem_id": "cmath_10774",
      "solution": null,
      "summary": "Compute the modular multiplicative inverse of 160 modulo 1399 using the Extended Euclidean Algorithm to solve the linear Diophantine equation $160x + 1399y = 1$.",
      "pseudocode": "FUNCTION extended_gcd(a, b):\n    IF a == 0:\n        RETURN (b, 0, 1)\n    (gcd, x1, y1) <- extended_gcd(b MOD a, a)\n    x <- y1 - (b DIV a) * x1\n    y <- x1\n    RETURN (gcd, x, y)\n\nFUNCTION mod_inverse(a, m):\n    (gcd, x, y) <- extended_gcd(a, m)\n    ASSERT gcd == 1  // Verify existence of inverse\n    RETURN (x MOD m) // Normalize to range [0, m-1]\n\nFUNCTION solve():\n    n <- mod_inverse(160, 1399)\n    RETURN n"
    },
    "cmath_10816": {
      "problem_id": "cmath_10816",
      "solution": null,
      "summary": "Exhaustively enumerate all permutations and count those satisfying the pairwise consecutive coprime constraint.",
      "pseudocode": "Define digit set D = {1, 2, 3, 4, 5, 6}\nInitialize valid_count = 0\nGenerate all permutations P of D\nFor each permutation p in P:\n    is_valid = True\n    For each adjacent pair (u, v) in p:\n        If gcd(u, v) > 1:\n            is_valid = False\n            Break\n    If is_valid:\n        valid_count = valid_count + 1\nReturn valid_count"
    },
    "cmath_10822": {
      "problem_id": "cmath_10822",
      "solution": null,
      "summary": "Convert base-specific digit constraints to base 10 intervals, find their intersection, and compute the average of the resulting consecutive integers using the arithmetic mean property.",
      "pseudocode": "function solve():\n    // Determine base 10 range for 3-digit base 5 numbers\n    min_5 = value of smallest 3-digit number in base 5 (100_5)\n    max_5 = value of largest 3-digit number in base 5 (444_5)\n    \n    // Determine base 10 range for 2-digit base 8 numbers\n    min_8 = value of smallest 2-digit number in base 8 (10_8)\n    max_8 = value of largest 2-digit number in base 8 (77_8)\n    \n    // Find intersection of valid integer ranges\n    valid_min = max(min_5, min_8)\n    valid_max = min(max_5, max_8)\n    \n    // Calculate average of consecutive integers [valid_min, valid_max]\n    // Concept: Mean of arithmetic progression is (first + last) / 2\n    result = (valid_min + valid_max) / 2\n    \n    return result"
    },
    "cmath_10860": {
      "problem_id": "cmath_10860",
      "solution": null,
      "summary": "Compute the prime factorization exponents of the product and multiply (floor(e/3) + 1) for each exponent to count valid cube divisors.",
      "pseudocode": "1. Compute N = 3! * 5! * 7!\n2. Determine the prime factorization of N to get the set of exponents {e_1, e_2, ..., e_k}\n3. Initialize cube_divisor_count = 1\n4. For each exponent e in {e_1, ..., e_k}:\n    cube_divisor_count *= (floor(e / 3) + 1)\n5. Return cube_divisor_count"
    },
    "cmath_10934": {
      "problem_id": "cmath_10934",
      "solution": null,
      "summary": "Determine the number of multiples of the root power within each prime exponent's range and multiply these counts.",
      "pseudocode": "Function CountPerfectPowerFactors(PrimeExponents, RootPower):\n    TotalCombinations = 1\n    For each exponent E in PrimeExponents:\n        # A factor's exponent x must satisfy 0 <= x <= E\n        # For a perfect RootPower, x must be a multiple of RootPower\n        # Valid x values are {0, RootPower, 2*RootPower, ...}\n        NumValidChoices = Floor(E / RootPower) + 1\n        TotalCombinations = TotalCombinations * NumValidChoices\n    Return TotalCombinations\n\n# Problem Application\nExponents = [6, 10]  # From 3^6 * 5^10\nRootPower = 3        # Perfect cube\nResult = CountPerfectPowerFactors(Exponents, RootPower)"
    },
    "cmath_10942": {
      "problem_id": "cmath_10942",
      "solution": null,
      "summary": "Apply the identity $a^{-1}+b^{-1}=(a+b)(ab)^{-1}$ to simplify the expression and cancel the $(a+b)$ term.",
      "pseudocode": "Function SolveModularExpression(n, a, b):\n    Input: n >= 3, (ab) invertible mod n, (ab)^(-1) \u2261 2 mod n, (a+b) invertible mod n\n    Target: Compute E = (a+b)^(-1) * (a^(-1) + b^(-1)) mod n\n\n    // Step 1: Simplify sum of inverses using algebraic identity\n    // Identity: 1/a + 1/b = (a+b)/(ab)\n    Transform: (a^(-1) + b^(-1)) \u2261 (a + b) * (ab)^(-1) mod n\n\n    // Step 2: Substitute the given value for the inverse of the product\n    Substitute: (ab)^(-1) \u2192 2\n    Result: (a^(-1) + b^(-1)) \u2261 2 * (a + b) mod n\n\n    // Step 3: Evaluate the target expression\n    Substitute: E \u2261 (a + b)^(-1) * [2 * (a + b)] mod n\n\n    // Step 4: Cancel terms using the inverse property\n    // Property: x^(-1) * x \u2261 1 mod n\n    Rearrange: E \u2261 2 * [(a + b)^(-1) * (a + b)] mod n\n    Simplify: E \u2261 2 * 1 mod n\n\n    Return 2"
    },
    "cmath_10978": {
      "problem_id": "cmath_10978",
      "solution": null,
      "summary": "Directly evaluate the sum of products of consecutive modular inverses modulo p by iterating through all terms.",
      "pseudocode": "Function EvaluateInverseSum(p):\n    Input: Prime integer p >= 7\n    Verify p satisfies constraints (p >= 7, p is prime)\n    Initialize Sum S = 0\n    For each integer k from 1 to p-2:\n        Compute modular inverse inv_k = k^(-1) mod p\n        Compute modular inverse inv_k1 = (k+1)^(-1) mod p\n        Term = (inv_k * inv_k1) mod p\n        S = (S + Term) mod p\n    Return S"
    },
    "cmath_10993": {
      "problem_id": "cmath_10993",
      "solution": null,
      "summary": "Partition the residue system modulo $n$ based on coprimality to compute the difference between the sums of invertible and non-invertible elements.",
      "pseudocode": "Define modulus n = 2^4\nDefine ResidueSystem = {0, 1, ..., n-1}\nDefine Condition(x): gcd(x, n) == 1  // Invertibility check\nA = Sum(x for x in ResidueSystem where Condition(x) is True)\nB = Sum(x for x in ResidueSystem where Condition(x) is False)\nResult = A - B\nReturn Result"
    },
    "cmath_10998": {
      "problem_id": "cmath_10998",
      "solution": null,
      "summary": "Parameterize $a$ and $b$ via GCD to reduce the problem to counting ordered coprime factor pairs of the quotient $\\text{lcm}/\\gcd$.",
      "pseudocode": "Function CountValidValues(gcd_val, lcm_val):\n    // Mathematical Reduction:\n    // Let a = gcd_val * m and b = gcd_val * n\n    // Condition gcd(a, b) = gcd_val implies gcd(m, n) = 1\n    // Condition lcm(a, b) = lcm_val implies m * n = lcm_val / gcd_val\n    \n    target_product = lcm_val / gcd_val\n    count = 0\n    \n    // Algorithmic Pattern: Iterate divisors up to square root to find pairs (m, n)\n    For m from 1 to floor(sqrt(target_product)):\n        If target_product % m == 0:\n            n = target_product / m\n            \n            // Check Properties: Coprimality and Order (a < b => m < n)\n            If gcd(m, n) == 1 AND m < n:\n                count = count + 1\n                \n    Return count"
    },
    "cmath_11055": {
      "problem_id": "cmath_11055",
      "solution": null,
      "summary": "Simplify the modular equation to a linear congruence, derive the general solution, and calculate the smallest value meeting the digit constraint.",
      "pseudocode": "Simplify congruence: Subtract r^2 and combine terms to get 2r \u2261 -3 (mod 55)\nNormalize residue: Convert -3 to 52 mod 55, yielding 2r \u2261 52 (mod 55)\nSolve linear congruence: Divide by 2 (valid since gcd(2, 55)=1) to get r \u2261 26 (mod 55)\nFormulate general solution: r = 26 + 55 * k for integer k\nApply range constraint: Set inequality 26 + 55 * k \u2265 1000 for least four-digit number\nDetermine minimal k: Solve k \u2265 (1000 - 26) / 55 and take ceiling integer\nCompute final solution: Substitute minimal k back into general solution formula"
    },
    "cmath_1854": {
      "problem_id": "cmath_1854",
      "solution": null,
      "summary": "Calculate the product of possible quantities for each identical item type and subtract the empty selection case.",
      "pseudocode": "FUNCTION count_non_empty_selections(item_counts):\n    total_combinations = 1\n    FOR count IN item_counts:\n        // For identical items, possible choices range from 0 to count\n        choices_per_type = count + 1\n        // Apply multiplication principle for independent choices\n        total_combinations = total_combinations * choices_per_type\n    // Apply exclusion principle to remove the empty set case (all zeros)\n    RETURN total_combinations - 1"
    },
    "cmath_1970": {
      "problem_id": "cmath_1970",
      "solution": null,
      "summary": "Apply complementary counting by subtracting the combinatorial count of integers with distinct digits from the total number of integers in the specified range.",
      "pseudocode": "FUNCTION Solve(RangeMin, RangeMax):\n    // Step 1: Calculate Total Integers in Range\n    TotalCount = RangeMax - RangeMin + 1\n    \n    // Step 2: Calculate Integers with All Distinct Digits (Complementary Set)\n    // Using Multiplication Principle for Permutations\n    HundredsChoices = CountValidDigitsForPlace(Place=100, Constraint=RangeMax) // e.g., 1-4\n    TensChoices = 10 - 1 // Any digit 0-9 except Hundreds digit\n    UnitsChoices = 10 - 2 // Any digit 0-9 except Hundreds and Tens digits\n    \n    DistinctCount = HundredsChoices * TensChoices * UnitsChoices\n    \n    // Step 3: Apply Complementary Counting\n    // Target = Total - (Count where condition is NOT met)\n    ResultCount = TotalCount - DistinctCount\n    \n    RETURN ResultCount\nEND FUNCTION"
    },
    "cmath_1988": {
      "problem_id": "cmath_1988",
      "solution": null,
      "summary": "Exhaustively iterate through all 3-digit numbers and count those where the middle digit is strictly greater than the outer digits.",
      "pseudocode": "count <- 0\nDEFINE domain D = {n | 100 <= n <= 999}\nFOR each n IN D:\n    (d1, d2, d3) <- decimal_digits(n)\n    IF d2 > d1 AND d2 > d3:\n        count <- count + 1\nRETURN count"
    },
    "cmath_2027": {
      "problem_id": "cmath_2027",
      "solution": null,
      "summary": "Model the distribution of distinct items into identical containers as a set partition problem solved using Bell numbers.",
      "pseudocode": "FUNCTION count_distributions(distinct_elements, identical_containers):\n    n = size(distinct_elements)\n    k = size(identical_containers)\n    IF containers are identical AND elements are distinct:\n        IF k >= n:\n            # Sufficient containers allow all set partitions\n            RETURN Bell_Number(n)\n        ELSE:\n            # Limit partitions to at most k non-empty subsets\n            RETURN SUM(Stirling_Second_Kind(n, i) for i in 1 to k)\n    RETURN 0"
    },
    "cmath_2077": {
      "problem_id": "cmath_2077",
      "solution": null,
      "summary": "Use the gap method by arranging non-restricted items to create slots for restricted items to ensure non-adjacency, then calculate the probability ratio.",
      "pseudocode": "IDENTIFY restricted_items and non_restricted_items with their respective counts\nCOMPUTE total_permutations using multinomial coefficient for all items combined\nARRANGE non_restricted_items and compute their distinct permutations\nGENERATE gaps from non_restricted_arrangement equal to (count + 1)\nSELECT positions for restricted_items from gaps using combinations to ensure non-adjacency\nCOMPUTE valid_permutations = non_restricted_permutations * selection_ways\nDERIVE probability = valid_permutations / total_permutations\nSIMPLIFY probability to lowest terms m/n\nOUTPUT m + n"
    },
    "cmath_2100": {
      "problem_id": "cmath_2100",
      "solution": null,
      "summary": "Generate candidates satisfying local constraints and filter by global constraints.",
      "pseudocode": "1. Precompute the set of all valid rows satisfying the local row sum constraint.\n2. Initialize a counter for valid matrices to 0.\n3. Iterate through all possible matrices formed by combining valid rows (Cartesian product).\n4. For each matrix, verify if it satisfies the global column sum constraints.\n5. If constraints are met, increment the counter.\n6. Return the final count."
    },
    "cmath_2102": {
      "problem_id": "cmath_2102",
      "solution": null,
      "summary": "Transform positive odd integer variables into non-negative integers via linear substitution, then apply the stars and bars combinatorial theorem to count the solutions.",
      "pseudocode": "Function SolveOddSumPartition(TargetSum S, NumVariables k):\n    // Step 1: Transform Constraints\n    // Each x_i is a positive odd integer, so let x_i = 2*y_i + 1 where y_i >= 0\n    // Substitute into equation: sum(2*y_i + 1) = S\n    // Simplify: 2 * sum(y_i) + k = S\n    \n    // Step 2: Determine New Target Sum\n    If (S - k) is odd or (S - k) < 0:\n        Return 0 // No valid integer solution\n    NewSum N = (S - k) / 2\n    \n    // Step 3: Count Non-Negative Solutions\n    // Apply Stars and Bars theorem for sum(y_i) = N with k variables\n    // Count = C(N + k - 1, k - 1)\n    n = BinomialCoefficient(N + k - 1, k - 1)\n    \n    // Step 4: Final Computation\n    Return n / 100\nEnd Function\n\n// Execute for specific problem\nResult = SolveOddSumPartition(98, 4)\nPrint Result"
    },
    "cmath_2104": {
      "problem_id": "cmath_2104",
      "solution": null,
      "summary": "Calculate total games to determine the probability space, treat unique win distributions as team permutations, and use Legendre's formula to compute the exponent of 2 in the simplified denominator.",
      "pseudocode": "FUNCTION CalculateLog2Denominator(num_teams):\n    // 1. Determine total games in a round-robin tournament\n    total_games <- num_teams * (num_teams - 1) / 2\n    \n    // 2. Identify probability structure: P = num_teams! / 2^(total_games)\n    // The denominator n in simplified form m/n depends on factors of 2\n    \n    // 3. Calculate the exponent of 2 in num_teams! using Legendre's Formula\n    v2_factorial <- 0\n    divisor <- 2\n    WHILE divisor <= num_teams:\n        v2_factorial <- v2_factorial + FLOOR(num_teams / divisor)\n        divisor <- divisor * 2\n    END WHILE\n    \n    // 4. Compute log2(n) by subtracting cancelled factors from total games\n    log2_n <- total_games - v2_factorial\n    \n    RETURN log2_n\nEND FUNCTION"
    },
    "cmath_2114": {
      "problem_id": "cmath_2114",
      "solution": null,
      "summary": "Construct the minimal triangle-free sequence starting from the lower bound to identify the threshold where a triangle-free subset of the target size becomes possible.",
      "pseudocode": "function solve_triangle_property_limit(min_val, subset_size):\n    # Initialize the smallest possible triangle-free sequence\n    # To avoid triangles, each element must be >= sum of previous two\n    sequence = [min_val, min_val + 1]\n    \n    # Extend the sequence until it reaches the target subset size\n    while length(sequence) < subset_size:\n        next_val = sequence[-1] + sequence[-2]\n        append next_val to sequence\n    \n    # The largest n is the value just before a triangle-free subset of size k can exist\n    # This corresponds to the largest element of the minimal triangle-free sequence minus 1\n    max_n = sequence[-1] - 1\n    \n    return max_n\n\n# Problem parameters\nstart_integer = 4\ntarget_subset_size = 10\n\n# Compute and return result\nresult = solve_triangle_property_limit(start_integer, target_subset_size)\nprint(result)"
    },
    "cmath_2147": {
      "problem_id": "cmath_2147",
      "solution": null,
      "summary": "Iterate over partition sizes and sum the counts of subsets satisfying cardinality exclusion constraints.",
      "pseudocode": "Set n = 12\nInitialize total_count = 0\nFor k from 1 to n - 1:\n    size_A = k\n    size_B = n - k\n    // Constraint 1: size_A is not an element of A\n    // Constraint 2: size_B is not an element of B (implies size_B is in A)\n    If size_A == size_B:\n        Continue // Impossible to satisfy both constraints simultaneously\n    // Count subsets A of size k that contain size_B but not size_A\n    // Fix 2 elements (include size_B, exclude size_A), choose remaining k-1 from n-2\n    ways = Combinations(n - 2, k - 1)\n    total_count = total_count + ways\nReturn total_count"
    },
    "cmath_2163": {
      "problem_id": "cmath_2163",
      "solution": null,
      "summary": "Use Bayes' theorem to find the posterior probabilities of each die given two sixes, then calculate the total probability of a third six.",
      "pseudocode": "Define prior probabilities for selecting Fair and Biased dice\nDefine probability of rolling a six for each die type\nCalculate likelihood of observing two consecutive sixes for each die type\nCompute total probability of observing two sixes using Law of Total Probability\nApply Bayes' Theorem to determine posterior probability of each die type given the evidence\nCalculate predictive probability of third roll being six using posterior weights\nSimplify the resulting fraction p/q and return p + q"
    },
    "cmath_2167": {
      "problem_id": "cmath_2167",
      "solution": null,
      "summary": "Apply dynamic programming with axis boundary conditions to compute the probability fraction, then extract and sum the numerator and denominator's exponent of 3.",
      "pseudocode": "Function ComputeHitProbability(N):\n    Initialize DP table of size (N+1) x (N+1)\n    Set DP[0][0] = 1\n    Set DP[i][0] = 0 and DP[0][i] = 0 for i from 1 to N\n    For i from 1 to N:\n        For j from 1 to N:\n            DP[i][j] = (1/3) * (DP[i-1][j] + DP[i][j-1] + DP[i-1][j-1])\n    Return DP[N][N]\n\nFunction Solve():\n    Probability = ComputeHitProbability(4)\n    Express Probability as m / 3^n where m is not divisible by 3\n    Return m + n"
    },
    "cmath_2185": {
      "problem_id": "cmath_2185",
      "solution": null,
      "summary": "Use the Pigeonhole Principle to calculate the worst-case selection by maximizing unpaired socks across all colors before completing the target number of pairs.",
      "pseudocode": "FUNCTION MinSocksForPairs(color_counts, target_pairs):\n    num_colors = COUNT(color_counts)\n    \n    # Verify supply is sufficient for the target (e.g., min(40) >= 2*10)\n    IF MIN(color_counts) < 2 * target_pairs:\n        RETURN \"Insufficient Socks\"\n    \n    # Worst-case analysis: Maximize socks held while having only (target_pairs - 1) pairs\n    # Each complete pair consumes 2 socks\n    socks_from_pairs = 2 * (target_pairs - 1)\n    \n    # To maximize count without forming extra pairs, keep 1 unpaired sock per color\n    max_unpaired_socks = num_colors\n    \n    # Maximum socks one can draw without guaranteeing the target number of pairs\n    threshold = socks_from_pairs + max_unpaired_socks\n    \n    # Drawing one additional sock forces the completion of the target_pairs\n    RETURN threshold + 1\nEND FUNCTION"
    },
    "cmath_2190": {
      "problem_id": "cmath_2190",
      "solution": null,
      "summary": "Count valid sequences using a Fibonacci-like recurrence relation, compute the simplified probability fraction, and sum its numerator and denominator.",
      "pseudocode": "DEFINE dp[i] AS number of binary sequences of length i with no consecutive 1s\nSET BASE CASES: dp[1] = 2, dp[2] = 3\nFOR i FROM 3 TO 10:\n    dp[i] = dp[i-1] + dp[i-2]\n    // Derivation: Append '0' to valid seqs of length i-1 OR append '01' to valid seqs of length i-2\nvalid_sequences = dp[10]\ntotal_sequences = 2^10\nprobability = valid_sequences / total_sequences\nREDUCE probability TO irreducible fraction m/n\nRETURN m + n"
    },
    "cmath_2286": {
      "problem_id": "cmath_2286",
      "solution": null,
      "summary": "Model the daily rolling process as a geometric distribution to find the expected rolls per day, then multiply by the number of days in a year.",
      "pseudocode": "Identify daily stopping condition (outcome != 1)\nCalculate probability of stopping p = 5/6\nCompute expected rolls per day E_day = 1 / p using geometric distribution mean\nCompute total expected rolls E_total = 365 * E_day using linearity of expectation\nReturn E_total"
    },
    "cmath_2385": {
      "problem_id": "cmath_2385",
      "solution": null,
      "summary": "Apply the multiplication principle by sequentially counting valid digit choices for each position while satisfying parity, distinctness, and leading non-zero constraints.",
      "pseudocode": "Function CountDistinctOddThreeDigitNumbers():\n    Define Constraints:\n        1. Structure: 3 digits (Hundreds, Tens, Units)\n        2. Parity: Units digit must be Odd {1, 3, 5, 7, 9}\n        3. Leading Zero: Hundreds digit cannot be 0\n        4. Distinctness: All digits must be unique\n\n    // Constructive Counting Strategy (Multiplication Principle)\n    // Order selection by strictness of constraints to manage dependencies\n    \n    Step 1: Determine choices for Units digit\n        Options = Count({1, 3, 5, 7, 9}) = 5\n    \n    Step 2: Determine choices for Hundreds digit\n        Options = Count({1..9} excluding chosen Units digit) = 8\n    \n    Step 3: Determine choices for Tens digit\n        Options = Count({0..9} excluding chosen Units and Hundreds digits) = 8\n    \n    Total Count = Step 1 Options * Step 2 Options * Step 3 Options\n    Return Total Count"
    },
    "cmath_2428": {
      "problem_id": "cmath_2428",
      "solution": null,
      "summary": "Apply the stars and bars theorem to calculate the number of ways to distribute n identical items into k distinct bins using the combination formula C(n + k - 1, k - 1).",
      "pseudocode": "FUNCTION CountDistributions(identical_items, distinct_bins):\n    // Identify Combinatorial Model: Distributing identical items into distinct bins\n    // Constraint: All items must be distributed, bins may be empty (non-negative integers)\n    // Technique: Stars and Bars Theorem\n    \n    n <- identical_items\n    k <- distinct_bins\n    \n    // Theorem Application: Number of ways is given by choosing positions for bars among stars\n    // Formula: BinomialCoefficient(n + k - 1, k - 1)\n    ways <- BinomialCoefficient(n + k - 1, k - 1)\n    \n    RETURN ways\nEND FUNCTION"
    },
    "cmath_2432": {
      "problem_id": "cmath_2432",
      "solution": null,
      "summary": "Iterate through feasible counts of the higher-cost item, derive the corresponding count of the lower-cost item from the budget constraint, and sum the products of their respective binomial coefficients.",
      "pseudocode": "SET count_E = 5, cost_E = 2\nSET count_M = 6, cost_M = 1\nSET total_budget = 12\nINITIALIZE total_ways = 0\n\nFOR num_E FROM 0 TO count_E:\n    required_cost_M = total_budget - (num_E * cost_E)\n    num_M = required_cost_M / cost_M\n    \n    IF num_M is integer AND 0 <= num_M <= count_M:\n        ways_E = BINOMIAL(count_E, num_E)\n        ways_M = BINOMIAL(count_M, num_M)\n        total_ways += ways_E * ways_M\n\nRETURN total_ways"
    },
    "cmath_2462": {
      "problem_id": "cmath_2462",
      "solution": null,
      "summary": "Model the scenario as a graph and minimize edges by constructing a 2-regular cycle graph satisfying the minimum degree constraint.",
      "pseudocode": "Function MinHandshakes(n_people):\n    Model people as Vertices V and handshakes as Edges E in Graph G\n    Constraint: degree(v) >= 2 for all v in V\n    Objective: Minimize |E|\n    Strategy: Construct a 2-regular graph (Cycle Graph) to satisfy constraint minimally\n    Property: A cycle graph with n vertices has exactly n edges\n    min_handshakes = n_people\n    Return min_handshakes"
    },
    "cmath_2476": {
      "problem_id": "cmath_2476",
      "solution": null,
      "summary": "Iterate over valid even last digits and sum the combinations of choosing two strictly smaller preceding digits.",
      "pseudocode": "Initialize total_count = 0\nDefine valid_last_digits = {2, 4, 6, 8}\nFor each last_digit in valid_last_digits:\n    // Preceding digits must be strictly smaller and non-zero (to ensure 3-digit number)\n    // Available pool for first two digits is {1, ..., last_digit - 1}\n    // Order is fixed by strictly increasing constraint, so use combinations\n    ways_to_choose_prefix = Binomial_Coefficient(last_digit - 1, 2)\n    total_count = total_count + ways_to_choose_prefix\nReturn total_count"
    },
    "cmath_4681": {
      "problem_id": "cmath_4681",
      "solution": null,
      "summary": "Decompose the number into prime factorization, sum exponents for each prime, and multiply the primes with odd total exponents to make all exponents even.",
      "pseudocode": "Function FindSmallestSquareMultiplier(ProductExpression):\n    // Concept: Aggregate total exponents for each prime base\n    Initialize prime_exponent_map\n    \n    For each term (base, exponent) in ProductExpression:\n        prime_factors = PrimeFactorize(base)\n        For each (prime, power) in prime_factors:\n            prime_exponent_map[prime] += power * exponent\n            \n    // Concept: Perfect square condition requires all exponents to be even\n    multiplier = 1\n    For each (prime, total_exponent) in prime_exponent_map:\n        If total_exponent is Odd:\n            // Multiply by prime once to make exponent even\n            multiplier *= prime\n            \n    Return multiplier"
    },
    "cmath_4689": {
      "problem_id": "cmath_4689",
      "solution": null,
      "summary": "Iteratively compute the sum of the decimal digits of $1/5^n$ for increasing $n$ until the sum exceeds 10.",
      "pseudocode": "Function FindSmallestN():\n    Initialize n = 1\n    Loop:\n        Compute value = 1 / 5^n\n        Extract digits D from the fractional part of the decimal expansion of value\n        Calculate digit_sum = Sum(D)\n        If digit_sum > 10:\n            Return n\n        Increment n"
    },
    "cmath_4733": {
      "problem_id": "cmath_4733",
      "solution": null,
      "summary": "Bounded iteration to sum all integers satisfying a specific least common multiple constraint with a base number.",
      "pseudocode": "Define Target_LCM \u2190 60\nDefine Base_Number \u2190 20\nInitialize Total_Sum \u2190 0\nFor each integer \u03bd from 1 to Target_LCM:\n    If LCM(\u03bd, Base_Number) == Target_LCM:\n        Total_Sum \u2190 Total_Sum + \u03bd\nReturn Total_Sum"
    },
    "cmath_4759": {
      "problem_id": "cmath_4759",
      "solution": null,
      "summary": "Filter integer divisors of the numerator by the denominator's parity constraint to determine valid variable values and compute their sum.",
      "pseudocode": "condition <- (2n - 1) must divide 20\ndivisors <- all_integer_divisors(20)\nvalid_divisors <- filter(divisors, is_odd)  // Enforce parity constraint of 2n - 1\nsolutions <- map(valid_divisors, d -> solve(2n - 1 = d))\nreturn sum(solutions)"
    },
    "cmath_4771": {
      "problem_id": "cmath_4771",
      "solution": null,
      "summary": "Count integers $n$ where the denominator $n+1$ contains prime factors other than 2 or 5, as this condition ensures the irreducible fraction $\\frac{n}{n+1}$ produces a repeating decimal.",
      "pseudocode": "Function has_prime_factors_other_than_2_or_5(num):\n    // Remove all factors of 2 and 5 from the number\n    While num is divisible by 2:\n        num = num / 2\n    While num is divisible by 5:\n        num = num / 5\n    // If remaining value > 1, other prime factors exist\n    Return num != 1\n\nInitialize count = 0\nFor n from 1 to 100:\n    denominator = n + 1\n    // Fraction n/(n+1) is irreducible since gcd(n, n+1) = 1\n    // A simplified fraction has a repeating decimal iff denominator has prime factors other than 2 or 5\n    If has_prime_factors_other_than_2_or_5(denominator):\n        count = count + 1\nReturn count"
    },
    "cmath_4818": {
      "problem_id": "cmath_4818",
      "solution": null,
      "summary": "Iterative search for the minimal integer $n$ where $n^2-n$ is divisible by a proper non-empty subset of $\\{1, \\dots, n\\}$.",
      "pseudocode": "n <- 1\nwhile true:\n    D <- {k : 1 <= k <= n and k divides (n^2 - n)}\n    if 0 < |D| < n:\n        return n\n    n <- n + 1"
    },
    "cmath_4845": {
      "problem_id": "cmath_4845",
      "solution": null,
      "summary": "Compute the sum of distinct quadratic residues modulo 11 generated by integers 1 to 10 and determine the integer quotient when divided by 11.",
      "pseudocode": "Set modulus p = 11\nInitialize set quadratic_residues = {}\nFor n from 1 to p - 1:\n    Compute residue r = (n^2) mod p\n    Add r to quadratic_residues\nCalculate m = sum of elements in quadratic_residues\nReturn floor(m / p)"
    },
    "cmath_4855": {
      "problem_id": "cmath_4855",
      "solution": null,
      "summary": "Count divisors of N divisible by k by calculating the total number of divisors of N/k using prime factorization.",
      "pseudocode": "function count_divisors_multiple(N, k):\n    if N % k != 0:\n        return 0\n    \n    # A divisor d of N is a multiple of k iff d = k * m, where m divides N/k\n    M = N / k\n    \n    # Get prime factorization of M: M = p1^e1 * p2^e2 * ...\n    factors = prime_factorize(M)\n    \n    # Apply divisor counting formula: product of (exponent + 1)\n    count = 1\n    for exponent in factors.values():\n        count *= (exponent + 1)\n        \n    return count"
    },
    "cmath_4869": {
      "problem_id": "cmath_4869",
      "solution": null,
      "summary": "Derive a combinatorial formula for the count of distinct-digit numbers in base $b$ and solve the resulting polynomial equation for the integer base.",
      "pseudocode": "Derive combinatorial formula for count of distinct 3-digit numbers in base b:\n    First digit choices: b - 1 (cannot be 0)\n    Second digit choices: b - 1 (cannot match first)\n    Third digit choices: b - 2 (cannot match first or second)\n    Total Count N(b) = (b - 1) * (b - 1) * (b - 2)\n\nSet equation N(b) = 100\nIterate integer b starting from 3\nReturn b where N(b) equals 100"
    },
    "cmath_4949": {
      "problem_id": "cmath_4949",
      "solution": null,
      "summary": "Iteratively search for the smallest positive integer n by counting its representations as a sum of two positive squares until the target count is met.",
      "pseudocode": "Function CountOrderedPairs(n):\n    count <- 0\n    For a from 1 to floor(sqrt(n)):\n        b_squared <- n - a^2\n        If b_squared is a perfect square:\n            b <- sqrt(b_squared)\n            If b > 0:\n                If a == b:\n                    count <- count + 1  // (a, a) is unique\n                Else:\n                    count <- count + 2  // (a, b) and (b, a) are distinct\n    Return count\n\nn <- 1\nWhile True:\n    If CountOrderedPairs(n) == 3:\n        Return n\n    n <- n + 1"
    },
    "cmath_4950": {
      "problem_id": "cmath_4950",
      "solution": null,
      "summary": "Factor out the smaller factorial to simplify the sum into a product, then determine the largest prime factor by comparing the factorial's prime limit with the residual term's factors.",
      "pseudocode": "# Represent the sum of factorials\nexpression = 12! + 14!\n\n# Algebraic Simplification: Factor out the smaller factorial\n# 12! + 14! = 12! * (1 + 14 * 13)\ncommon_factor = 12!\nresidual_integer = 1 + (14 * 13)\n\n# Analyze prime factors of the common factorial component\n# The prime factors of n! are all primes <= n\nmax_prime_from_factorial = largest_prime_less_than_or_equal(12)\n\n# Analyze prime factors of the residual integer component\nresidual_prime_factors = prime_factorization(residual_integer)\nmax_prime_from_residual = max(residual_prime_factors)\n\n# The greatest prime factor of the total sum is the maximum of the components\ngreatest_prime = max(max_prime_from_factorial, max_prime_from_residual)\nreturn greatest_prime"
    },
    "cmath_4974": {
      "problem_id": "cmath_4974",
      "solution": null,
      "summary": "Iterate through candidate bases, evaluate the base-n polynomial representation, and count instances satisfying the modular divisibility condition.",
      "pseudocode": "Define Polynomial P(n) = 2n^5 + 3n^4 + 5n^3 + 2n^2 + 3n + 6\nInitialize count = 0\nFor n from 2 to 100:\n    If P(n) \u2261 0 (mod 7):\n        count = count + 1\nReturn count"
    },
    "cmath_5031": {
      "problem_id": "cmath_5031",
      "solution": null,
      "summary": "Apply Legendre's Formula to find the exponent of 2 in 16!, then use the cyclic pattern of powers of 2 modulo 10 to determine the final ones digit.",
      "pseudocode": "FUNCTION find_ones_digit_of_largest_power(n, p):\n    // Step 1: Calculate the exponent of prime p in n! using Legendre's Formula\n    exponent <- 0\n    power_of_p <- p\n    WHILE power_of_p <= n:\n        exponent <- exponent + FLOOR(n / power_of_p)\n        power_of_p <- power_of_p * p\n    \n    // Step 2: Determine the cycle length of ones digits for powers of p\n    // For p=2, the cycle of ones digits [2, 4, 8, 6] has length 4\n    cycle_length <- 4 \n    \n    // Step 3: Map the large exponent to the corresponding position in the cycle\n    // Note: If exponent % cycle_length == 0, it corresponds to the last element of the cycle\n    effective_exponent <- exponent MOD cycle_length\n    IF effective_exponent == 0:\n        effective_exponent <- cycle_length\n        \n    // Step 4: Compute the ones digit\n    result <- (p ^ effective_exponent) MOD 10\n    \n    RETURN result\nEND FUNCTION\n\n// Application to specific problem\nn_val <- 2^4  // 16\np_val <- 2\nanswer <- find_ones_digit_of_largest_power(n_val, p_val)"
    },
    "cmath_5075": {
      "problem_id": "cmath_5075",
      "solution": null,
      "summary": "Convert the base-8 digit constraint into a decimal value range, compute the minimum and maximum base-2 digit counts for this range, and sum all integers between these counts.",
      "pseudocode": "FUNCTION SolveBaseConversionDigitSum():\n    // 1. Determine the decimal range for a 4-digit base-8 integer\n    // Smallest 4-digit base-8 number is 1000_8 = 8^3\n    min_val <- 8^(4 - 1)\n    // Largest 4-digit base-8 number is 7777_8 = 8^4 - 1\n    max_val <- 8^4 - 1\n    \n    // 2. Calculate the number of base-2 digits (d) for the bounds\n    // Formula: digits = floor(log_base(value)) + 1\n    min_d <- floor(log_2(min_val)) + 1\n    max_d <- floor(log_2(max_val)) + 1\n    \n    // 3. Sum all possible integer values for d within the calculated range\n    total_sum <- 0\n    FOR d FROM min_d TO max_d INCLUSIVE:\n        total_sum <- total_sum + d\n        \n    RETURN total_sum\nEND FUNCTION"
    },
    "cmath_5177": {
      "problem_id": "cmath_5177",
      "solution": null,
      "summary": "Apply Euler's Totient Theorem to reduce the exponent modulo $\\phi(25)$, then compute the result using binary modular exponentiation.",
      "pseudocode": "Function Solve():\n    Define base = 19, exponent = 1999, modulus = 25\n    \n    // Concept: Euler's Totient Theorem Application\n    // Requires gcd(base, modulus) == 1\n    phi = Calculate_Euler_Totient(modulus)\n    \n    // Concept: Exponent Reduction\n    reduced_exponent = exponent % phi\n    \n    // Concept: Binary Modular Exponentiation\n    result = Modular_Exponentiation(base, reduced_exponent, modulus)\n    \n    Return result"
    },
    "cmath_5178": {
      "problem_id": "cmath_5178",
      "solution": null,
      "summary": "Simplify linear congruences to standard residue form, combine using the Chinese Remainder Theorem, and shift by the modulus period to satisfy the minimum value constraint.",
      "pseudocode": "Function FindLeastConstrainedSolution(LinearCongruences, LowerBound):\n    SimplifiedPairs = []\n    For each (coeff, constant, modulus) in LinearCongruences:\n        // Step 1: Simplify ax \u2261 b (mod m) to x \u2261 r (mod m')\n        g = GCD(coeff, modulus)\n        modulus_reduced = modulus / g\n        coeff_reduced = coeff / g\n        constant_reduced = constant / g\n        inverse = ModularInverse(coeff_reduced, modulus_reduced)\n        residue = (constant_reduced * inverse) % modulus_reduced\n        Add (residue, modulus_reduced) to SimplifiedPairs\n    \n    // Step 2: Combine congruences using Chinese Remainder Theorem\n    M_total = Product of all modulus_reduced in SimplifiedPairs\n    x_0 = 0\n    For each (residue, modulus_reduced) in SimplifiedPairs:\n        N_i = M_total / modulus_reduced\n        y_i = ModularInverse(N_i, modulus_reduced)\n        x_0 = (x_0 + residue * N_i * y_i) % M_total\n    \n    // Step 3: Adjust base solution to meet range constraint\n    k = Ceiling((LowerBound - x_0) / M_total)\n    Return x_0 + k * M_total"
    },
    "cmath_5195": {
      "problem_id": "cmath_5195",
      "solution": null,
      "summary": "Apply the Extended Euclidean Algorithm to solve the Bezout identity for the modular inverse and normalize the resulting coefficient.",
      "pseudocode": "Function ModularInverse(a, m):\n    // Problem: Find x such that a * x \u2261 1 (mod m)\n    // Equivalent to solving Diophantine equation: a * x + m * y = 1\n    \n    // 1. Apply Extended Euclidean Algorithm to find gcd(a, m) and coefficients x, y\n    (g, x, y) = ExtendedEuclidean(a, m)\n    \n    // 2. Check existence condition: inverse exists iff gcd(a, m) = 1\n    If g != 1:\n        Return \"No Inverse\"\n    \n    // 3. The coefficient x satisfies a * x \u2261 1 (mod m)\n    // 4. Normalize x to the canonical range [0, m-1]\n    result = (x % m + m) % m\n    \n    Return result"
    },
    "cmath_5235": {
      "problem_id": "cmath_5235",
      "solution": null,
      "summary": "Apply the Polynomial Remainder Theorem to reduce the divisibility condition to a constant divisor constraint, then maximize the divisor to solve for n.",
      "pseudocode": "Define polynomial f(n) = n^3 + 100\nDefine divisor term d = n + 10\nApply Polynomial Remainder Theorem: evaluate f(-10) to determine constant remainder C\nCalculate C = -900\nReformulate divisibility condition: d must divide C (equivalently d divides |C|)\nTo maximize n, maximize d by setting d = |C|\nSolve linear equation n + 10 = 900 for n\nReturn n"
    },
    "cmath_5236": {
      "problem_id": "cmath_5236",
      "solution": null,
      "summary": "Interpret the binary representation of the index as a base-3 number to compute the term.",
      "pseudocode": "Input: index n\n// Key Insight: Sequence elements are sums of distinct powers of 3.\n// This implies their base-3 representation contains only digits 0 and 1.\n// There is an order-preserving bijection between binary integers and this sequence.\n\n1. Obtain the binary representation of n: n = \u03a3(b_i * 2^i) where b_i \u2208 {0, 1}\n2. Map the binary coefficients to powers of 3 to find the nth term: T_n = \u03a3(b_i * 3^i)\n3. Calculate the sum of 3^i for every position i where the ith bit of n is 1\nOutput: T_n"
    },
    "cmath_5240": {
      "problem_id": "cmath_5240",
      "solution": null,
      "summary": "Iteratively search for integers satisfying the nice number definition by enumerating proper divisors and verifying their product equals the number.",
      "pseudocode": "Initialize empty list nice_numbers\nSet candidate n = 2\nWhile length(nice_numbers) < 10:\n    Determine set D of proper divisors of n (divisors d where 1 < d < n)\n    Compute product P = \u220f_{d in D} d\n    If P == n:\n        Append n to nice_numbers\n    Increment n\nReturn sum of elements in nice_numbers"
    },
    "cmath_5246": {
      "problem_id": "cmath_5246",
      "solution": null,
      "summary": "Count powers of 9 with leading digit 9 by evaluating the fractional part of their base-10 logarithms.",
      "pseudocode": "Define LOG_9 = log10(9)\nInitialize count = 0\nFor k from 0 to 4000:\n    // Calculate fractional part of the logarithm of 9^k\n    fractional_part = {k * LOG_9}\n    // Determine leading digit from the fractional part\n    leading_digit = floor(10 ^ fractional_part)\n    If leading_digit == 9:\n        Increment count\nReturn count"
    },
    "cmath_5260": {
      "problem_id": "cmath_5260",
      "solution": null,
      "summary": "Characterize integers expressible as a difference of squares using parity arguments to exclude numbers congruent to 2 modulo 4, then apply complementary counting.",
      "pseudocode": "FUNCTION CountDifferenceOfSquares(upper_bound):\n    // Step 1: Algebraic Characterization\n    // Express n = a^2 - b^2 as n = (a+b)(a-b)\n    // Let x = a+b, y = a-b. Note x and y must have same parity.\n    \n    // Step 2: Derive Modular Constraint\n    // If x, y both odd => n is odd\n    // If x, y both even => n is divisible by 4\n    // Therefore, n cannot be congruent to 2 modulo 4\n    \n    // Step 3: Complementary Counting\n    total_count \u2190 upper_bound\n    \n    // Count integers k in [1, upper_bound] where k \u2261 2 (mod 4)\n    // Sequence forms arithmetic progression: 2, 6, 10, ...\n    excluded_count \u2190 FLOOR((upper_bound - 2) / 4) + 1\n    \n    valid_count \u2190 total_count - excluded_count\n    \n    RETURN valid_count"
    },
    "cmath_5271": {
      "problem_id": "cmath_5271",
      "solution": null,
      "summary": "Use the integer mean property to establish modular congruence among elements, constrain the set size using divisors of the difference between known elements, and validate the maximum size via sum divisibility.",
      "pseudocode": "1. Let n be the number of elements and S be the sum of elements in set S.\n2. From the condition that (S - x) / (n - 1) is an integer for all x, deduce that all elements are congruent modulo (n - 1).\n3. Since 1 and 2002 are in the set, require (2002 - 1) to be divisible by (n - 1).\n4. Find all divisors of 2001 and sort them in descending order.\n5. For each divisor d:\n    a. Set candidate size n = d + 1.\n    b. Verify if a valid set of size n exists (checking if a constructed sum S is divisible by n).\n    c. If verification passes, return n as the maximum size."
    },
    "cmath_5274": {
      "problem_id": "cmath_5274",
      "solution": null,
      "summary": "Exhaustively search integers k starting from 1 until the sum of squares formula yields a multiple of 200.",
      "pseudocode": "Define S(k) = k(k + 1)(2k + 1) / 6\nInitialize k = 1\nWhile S(k) \u2262 0 (mod 200):\n    k \u2190 k + 1\nReturn k"
    },
    "cmath_5283": {
      "problem_id": "cmath_5283",
      "solution": null,
      "summary": "Model the sequential distribution as a linear system linking initial takes to final holdings, then minimize the total subject to integer constraints derived from the target ratio.",
      "pseudocode": "1. Define variables x, y, z for the quantity of bananas taken by the first, second, and third monkey respectively.\n2. Formulate linear expressions for the final holdings of each monkey based on the fractions kept and distributed at each step.\n3. Set the final holdings proportional to the given ratio using a common scaling factor k.\n4. Substitute the ratio-based holdings into the distribution expressions to generate a system of linear equations.\n5. Solve the system to express the taken quantities x, y, z in terms of the scaling factor k.\n6. Determine the least positive integer k such that x, y, z and all intermediate shared amounts are integers.\n7. Compute the total bananas B = x + y + z using the minimal valid k.\n8. Return the minimum total B."
    },
    "cmath_5291": {
      "problem_id": "cmath_5291",
      "solution": null,
      "summary": "Transform the logarithmic sum of a geometric sequence into a linear Diophantine equation on the exponents of the base's prime factor and count the non-negative integer solutions.",
      "pseudocode": "FUNCTION count_geometric_log_pairs(n_terms, log_sum, log_base):\n    // 1. Derive exponents from the product of geometric sequence terms\n    // Product = a^n * r^(0+1+...+n-1) = a^n * r^(n*(n-1)/2)\n    exp_a <- n_terms\n    exp_r <- n_terms * (n_terms - 1) / 2\n    \n    // 2. Simplify logarithmic equation to linear form\n    // log_base(a^exp_a * r^exp_r) = log_sum\n    // exp_a * log_base(a) + exp_r * log_base(r) = log_sum\n    \n    // 3. Convert to prime base p (where log_base = p^k) to enforce integer constraints\n    // log_base(x) = log_p(x) / k\n    k <- log_p(log_base)\n    coeff_a <- exp_a / k\n    coeff_r <- exp_r / k\n    target <- log_sum\n    \n    // 4. Form Linear Diophantine Equation: coeff_a * x + coeff_r * y = target\n    // where x = log_p(a), y = log_p(r) must be non-negative integers\n    \n    // 5. Determine valid integer solutions\n    // Analyze parity/modulo to parameterize one variable (e.g., y = step * k_param + offset)\n    // Calculate bounds for k_param such that x >= 0 and y >= 0\n    max_k <- floor((target - coeff_r * offset) / (coeff_r * step))\n    min_k <- 0\n    \n    // 6. Return count of valid parameters\n    RETURN max_k - min_k + 1\nEND FUNCTION"
    },
    "cmath_5295": {
      "problem_id": "cmath_5295",
      "solution": null,
      "summary": "Sum the 3-adic valuations of each integer in the sequence of the first 100 positive odd numbers to find the total exponent of 3 in their product.",
      "pseudocode": "Function CountPrimeValuation(n, p):\n    exponent <- 0\n    While n is divisible by p:\n        n <- n / p\n        exponent <- exponent + 1\n    Return exponent\n\nFunction Solve():\n    total_k <- 0\n    Sequence <- GenerateFirstNOddIntegers(100)  // Yields 1, 3, 5, ..., 199\n    For each number n in Sequence:\n        total_k <- total_k + CountPrimeValuation(n, 3)\n    Return total_k"
    },
    "cmath_5330": {
      "problem_id": "cmath_5330",
      "solution": null,
      "summary": "Calculate the maximum representable value in the balanced ternary system and count the non-negative integers up to that limit.",
      "pseudocode": "FUNCTION CountBalancedRepresentation(powers_count, base):\n    // Calculate the maximum magnitude representable with coefficients {-1, 0, 1}\n    max_val = 0\n    FOR i FROM 0 TO powers_count - 1:\n        max_val += base^i\n    \n    // Mathematical Property: A balanced base system uniquely represents \n    // all integers in the continuous range [-max_val, max_val]\n    \n    // Count the non-negative integers in the range [0, max_val]\n    count = max_val + 1\n    \n    RETURN count"
    },
    "cmath_5334": {
      "problem_id": "cmath_5334",
      "solution": null,
      "summary": "Check which candidate value satisfies the digit sum transition property $S(n+1) = S(n) + 1 - 9k$ for some non-negative integer $k$.",
      "pseudocode": "function find_valid_digit_sum(S_n, options):\n    # When incrementing n by 1, the digit sum changes based on trailing 9s.\n    # If there are k trailing 9s, S(n+1) = S(n) + 1 - 9*k.\n    # This implies S(n+1) <= S(n) + 1 and (S(n) + 1 - S(n+1)) is divisible by 9.\n    \n    base_sum = S_n + 1\n    \n    for option in options:\n        difference = base_sum - option\n        \n        # Check if the difference corresponds to a valid number of carries (k >= 0)\n        if difference >= 0 AND difference is divisible by 9:\n            return option\n            \n    return None"
    },
    "cmath_5342": {
      "problem_id": "cmath_5342",
      "solution": null,
      "summary": "Apply bounded exhaustive search to identify integer pairs satisfying the exponential Diophantine equation.",
      "pseudocode": "FUNCTION count_integer_solutions():\n    Initialize solution_count = 0\n    # Concept: Limit search space based on exponential growth relative to the constant\n    DETERMINE bounds for x and y such that 2^(2x) and 3^(2y) do not excessively exceed 55\n    FOR x FROM 1 TO bound_x:\n        FOR y FROM 1 TO bound_y:\n            # Concept: Direct verification of the Diophantine condition\n            IF 2^(2*x) - 3^(2*y) == 55:\n                INCREMENT solution_count\n    RETURN solution_count\nEND FUNCTION"
    },
    "cmath_5349": {
      "problem_id": "cmath_5349",
      "solution": null,
      "summary": "Enumerate all valid distinct-digit permutations, construct integers via place value expansion, accumulate the sum, and compute the remainder modulo 1000.",
      "pseudocode": "Define digit set D = {0, 1, ..., 9}\nInitialize total_sum = 0\nFor each ordered triple (d1, d2, d3) from Permutations(D, 3):\n    If d1 != 0:  // Constraint: leading digit cannot be zero\n        value = 100 * d1 + 10 * d2 + d3  // Place value construction\n        total_sum = total_sum + value\nReturn total_sum mod 1000"
    },
    "cmath_5421": {
      "problem_id": "cmath_5421",
      "solution": null,
      "summary": "Utilizes Fermat's Little Theorem to reduce the base modulo 11 and exponent modulo 10 before calculating the final modular exponentiation.",
      "pseudocode": "Define prime modulus P = 11\nDefine base A = 333, exponent B = 333\nReduce base: A_reduced = A mod P\nReduce exponent: B_reduced = B mod (P - 1) using Fermat's Little Theorem\nCompute result: Result = (A_reduced ^ B_reduced) mod P\nReturn Result"
    },
    "cmath_5475": {
      "problem_id": "cmath_5475",
      "solution": null,
      "summary": "Convert restricted divisor count to total divisors, decompose into multiplicative factors for exponent structures, and minimize by assigning smallest primes to largest exponents.",
      "pseudocode": "1. Calculate total divisors D = restricted_count + 2 (accounting for exclusions of 1 and N)\n2. Generate all multiplicative partitions of D (sets of integers whose product is D)\n3. For each partition, derive prime exponents E = [factor - 1 for factor in partition]\n4. Construct candidate number by assigning smallest distinct primes to largest exponents in E\n5. Return the minimum value across all constructed candidates"
    },
    "cmath_5477": {
      "problem_id": "cmath_5477",
      "solution": null,
      "summary": "Find the maximum value satisfying an upper bound and modular congruence by iterating downwards from the theoretical maximum.",
      "pseudocode": "SET limit = 1000\nSET multiplier = 20\nSET modulus = 26\nSET remainder = 4\nCALCULATE max_n = floor(limit / multiplier)\nFOR n FROM max_n DOWN TO 1:\n    candidate = n * multiplier\n    IF candidate < limit AND candidate % modulus == remainder:\n        RETURN candidate"
    },
    "cmath_5532": {
      "problem_id": "cmath_5532",
      "solution": null,
      "summary": "Characterize inputs as squares of distinct primes to determine the prime factorization of the target expression, then apply the divisor counting formula.",
      "pseudocode": "FUNCTION solve_factor_count():\n    IDENTIFY property: natural number has exactly 3 factors iff it is square of a prime (p^2)\n    REPRESENT x, y, z as squares of distinct primes: p1^2, p2^2, p3^2\n    SUBSTITUTE into target expression: E = (p1^2)^2 * (p2^2)^3 * (p3^2)^4\n    SIMPLIFY exponents: E = p1^4 * p2^6 * p3^8\n    APPLY divisor counting formula: product of (exponent + 1) for each prime factor\n    COMPUTE result: (4 + 1) * (6 + 1) * (8 + 1)\n    RETURN result"
    },
    "cmath_5540": {
      "problem_id": "cmath_5540",
      "solution": null,
      "summary": "Factor the polynomial to establish a baseline divisor, then compute the GCD of the expression evaluated at small composite integers to find the largest universal divisor.",
      "pseudocode": "Function FindLargestUniversalDivisor():\n    // 1. Algebraic Factorization\n    Expression <- n^3 - n\n    FactoredForm <- (n - 1) * n * (n + 1)\n    \n    // 2. Establish Theoretical Baseline\n    // Product of k consecutive integers is divisible by k!\n    // Here k=3, so divisible by 3! = 6 for all integers n\n    BaselineDivisor <- 6\n    \n    // 3. Empirical Verification on Domain\n    // Evaluate expression for the smallest composite integers to find constraints\n    Values <- []\n    For n in SmallestCompositeIntegers:\n        Values.append(Evaluate(Expression, n))\n    \n    // 4. Compute Tight Bound\n    // The largest integer dividing all cases is the GCD of the generated values\n    MaxDivisor <- GCD(Values)\n    \n    Return MaxDivisor\nEnd Function"
    },
    "cmath_5543": {
      "problem_id": "cmath_5543",
      "solution": null,
      "summary": "Compute the units digit by reducing the exponent tower modulo the periodicity of powers of 2 modulo 10.",
      "pseudocode": "FUNCTION find_Fermat_units_digit(n):\n    // Goal: Compute (2^(2^n) + 1) mod 10\n    modulus = 10\n    base = 2\n    cycle_length = 4  // Periodicity of 2^k mod 10\n\n    // Reduce the tower exponent (2^n) modulo the cycle length\n    // Mathematical Property: 2^n is divisible by 4 for all n >= 2\n    IF n >= 2:\n        reduced_exponent = cycle_length\n    ELSE:\n        reduced_exponent = (2^n) mod cycle_length\n\n    // Compute units digit of the power term using the reduced exponent\n    power_units_digit = (base^reduced_exponent) mod modulus\n\n    // Apply Fermat number definition offset\n    result = (power_units_digit + 1) mod modulus\n\n    RETURN result"
    },
    "cmath_5545": {
      "problem_id": "cmath_5545",
      "solution": null,
      "summary": "Determine the number of trailing zeroes in n! by calculating the total multiplicity of the prime factor 5 using Legendre's Formula.",
      "pseudocode": "Function CountTrailingZeroes(n):\n    // A trailing zero is produced by a factor of 10 = 2 * 5\n    // In n!, factors of 2 are more abundant than factors of 5\n    // Thus, the count of zeroes equals the exponent of 5 in the prime factorization of n!\n    // Apply Legendre's Formula for prime p = 5\n    count = 0\n    power_of_5 = 5\n    While power_of_5 <= n:\n        // Add the number of multiples of 5^k in the range [1, n]\n        count += floor(n / power_of_5)\n        power_of_5 *= 5\n    Return count"
    },
    "cmath_8735": {
      "problem_id": "cmath_8735",
      "solution": null,
      "summary": "Transform the \"at least one success\" condition into a complementary \"all failures\" probability inequality and solve for the minimum integer $n$ using logarithms.",
      "pseudocode": "Function MinTrialsForSuccess(p_success, target_probability):\n    // Step 1: Use Complementary Probability\n    // P(at least one success) = 1 - P(all failures)\n    p_failure <- 1 - p_success\n    max_allowed_failure_prob <- 1 - target_probability\n    \n    // Step 2: Model Independent Events\n    // P(all failures in n trials) = (p_failure)^n\n    // Inequality: (p_failure)^n <= max_allowed_failure_prob\n    \n    // Step 3: Solve Exponential Inequality using Logarithms\n    n_real <- log(max_allowed_failure_prob) / log(p_failure)\n    \n    // Step 4: Discretize to Minimum Integer\n    n_min <- ceiling(n_real)\n    \n    Return n_min\nEnd Function"
    },
    "cmath_8896": {
      "problem_id": "cmath_8896",
      "solution": null,
      "summary": "Apply the stars and bars theorem to count distributions of identical items into distinct bins.",
      "pseudocode": "IDENTIFY n = 6 // number of identical items\nIDENTIFY k = 3 // number of distinct bins\n// Recognize combinatorial pattern: distributing identical items into distinct bins\n// Equivalent to finding non-negative integer solutions to x_1 + ... + x_k = n\nAPPLY Stars_and_Bars_Theorem\nCALCULATE result = BinomialCoefficient(n + k - 1, k - 1)\nRETURN result"
    },
    "cmath_9094": {
      "problem_id": "cmath_9094",
      "solution": null,
      "summary": "Enumerate all subsets of size at least 2, calculate their sums, and count the number of unique results.",
      "pseudocode": "Let S be the input set of numbers\nInitialize U as an empty set to store unique sums\nFor each cardinality k from 2 to |S|:\n    For each subset C \u2286 S where |C| = k:\n        Compute s = \u03a3_{x \u2208 C} x\n        Insert s into U\nReturn |U|"
    },
    "cmath_9112": {
      "problem_id": "cmath_9112",
      "solution": null,
      "summary": "Calculate the number of surjective functions from the set of cars to the set of lanes using the Principle of Inclusion-Exclusion.",
      "pseudocode": "function count_surjective_mappings(num_elements, num_targets):\n    total_ways = 0\n    for i from 0 to num_targets:\n        # Apply Principle of Inclusion-Exclusion\n        # i is the number of targets excluded (forced to be empty)\n        sign = (-1) ^ i\n        ways_to_choose_excluded = binomial_coefficient(num_targets, i)\n        ways_to_assign_to_remaining = (num_targets - i) ^ num_elements\n        term = sign * ways_to_choose_excluded * ways_to_assign_to_remaining\n        total_ways += term\n    return total_ways"
    },
    "cmath_9126": {
      "problem_id": "cmath_9126",
      "solution": null,
      "summary": "Determine trailing zeros by summing the counts of factor 5 in each factorial using Legendre's Formula.",
      "pseudocode": "Function Legendre_Count(n, prime):\n    count <- 0\n    power <- prime\n    While power <= n:\n        count <- count + floor(n / power)\n        power <- power * prime\n    Return count\n\nTotal_Zeros <- 0\nFor each N in [100, 200, 300]:\n    // Trailing zeros determined by exponent of 5 in prime factorization\n    Total_Zeros <- Total_Zeros + Legendre_Count(N, 5)\n\nReturn Total_Zeros"
    }
  },
  "custom_types": {}
}