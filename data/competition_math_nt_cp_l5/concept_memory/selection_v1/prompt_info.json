{
  "cmath_10546": {
    "hint": "## algorithm\n- concept: Extended Euclidean Algorithm\n  description: An extension of the Euclidean algorithm that computes the greatest common divisor of two integers a and b, along with coefficients x and y (B\u00e9zout's identity) such that ax + by = gcd(a, b).\n  parameters:\n    - a (type: integer): The integer to invert\n    - b (type: integer): Second integer input\n    - m (type: integer): The modulus (must be coprime to a)\n  cues:\n    - Computing GCD with B\u00e9zout coefficients (ax + by = gcd(a, b)) or solving linear Diophantine equations\n    - Computing modular multiplicative inverses (e.g., k^(-1) mod p), especially when the modulus is prime ensuring gcd(k, p) = 1\n  implementation:\n    - Define a recursive function `extended_gcd(a, b)` returning (gcd, x, y) with base case (b, 0, 1) when a=0\n    - Update coefficients in the recursive step using x = y1 - (b // a) * x1 derived from the previous call\n    - Extract coefficient x from the result to compute the modular inverse, adjusting for negative values if necessary\n\n## number theory tool\n- concept: Coprimality Check\n  description: Verifying two numbers are relatively prime by checking if their greatest common divisor is 1.\n  parameters:\n    - num1 (type: integer): First integer\n    - num2 (type: integer): Second integer\n  cues:\n    - Constraint explicitly requires gcd(a, b) = 1 or gcd(x, n) == 1\n    - Requirement for a modular inverse to exist or justification for division in congruences\n    - Problem involves reduced fractions, canonical representation, or numerators coprime to denominators\n    - Conditions requiring adjacent elements, derived variables, or factor pairs to be relatively prime\n    - Application of Euler's Totient Theorem\n  implementation:\n    - Check `if gcd(a, m) == 1` to validate precondition for modular inverse or division, returning error if failed\n    - Iterate through candidates, pairs, or residue systems, computing gcd to filter non-coprime elements or ensure coprimality (e.g., numerators/denominators)\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n\n## technique\n- concept: Modular Inverse via Extended GCD\n  description: A method to compute the multiplicative inverse of an integer 'a' modulo 'm' by utilizing the Extended Euclidean Algorithm to solve ax \u2261 1 (mod m), valid only when gcd(a, m) = 1.\n  parameters:\n    - a (type: integer): The number to invert\n    - m (type: integer): The modulus\n  cues:\n    - Problem requires division in modular arithmetic or finding a multiplicative inverse (solving ax \u2261 1 (mod m))\n    - The coefficient and modulus are coprime (gcd(a, m) = 1), but the modulus is not guaranteed to be prime\n  implementation:\n    - Transform the problem into solving the Diophantine equation a * x + m * y = 1 using Extended GCD\n    - Include an assertion to verify that the gcd is 1, ensuring the inverse exists\n    - Normalize the resulting coefficient x using modulo m to ensure the result lies in the range [0, m-1]\n    - Used to find inverses in algorithms such as Linear Congruence Resolution or CRT construction\n- concept: Linear Congruence Resolution\n  description: Solves a linear congruence equation ax \u2261 b (mod m) by reducing coefficients via GCD and computing the modular inverse to isolate x.\n  parameters:\n    - coeff (type: integer): The coefficient 'a' of the variable x.\n    - constant (type: integer): The constant term 'b' on the RHS.\n    - modulus (type: integer): The modulus 'm'.\n  cues:\n    - Linear congruence equation ax \u2261 b (mod m) requiring isolation of x.\n  implementation:\n    - Reduced equation by dividing coeff, constant, and modulus by g = GCD(coeff, modulus).\n    - Computed modular inverse of reduced coefficient to find the residue.\n\n## theorem\n- concept: Euler's Totient Theorem\n  description: States that if gcd(a, n) = 1, then a^phi(n) \u2261 1 (mod n), allowing exponent reduction modulo phi(n).\n  parameters:\n    - base (type: integer): The integer base 'a' which must be coprime to the modulus\n    - modulus (type: integer): The modulus 'n' for the congruence\n  cues:\n    - Computing a^b mod n where b is large\n    - Base and modulus are coprime (especially if modulus is prime)\n  implementation:\n    - Reduce exponent modulo phi(n) using a^phi(n) \u2261 1 (mod n) (use n-1 if modulus is prime)"
  },
  "cmath_10571": {
    "hint": "## technique\n- concept: GCD Pair Parametrization\n  description: Representing two integers x, y with gcd(x, y) = g as x = g*a, y = g*b where gcd(a, b) = 1 to simplify GCD/LCM constraints.\n  parameters:\n    - gcd_val (type: integer): The known greatest common divisor of the pair\n    - factors (type: pair of integers): The coprime coefficients a and b\n  cues:\n    - Problem involves finding integer pairs with specified GCD/LCM values or constraints linking them (e.g., LCM related to one of the numbers).\n  implementation:\n    - Parametrize integers as x = gcd_val * a, y = gcd_val * b with gcd(a, b) = 1.\n    - Reduce constraints to the product equation a * b = lcm_val / gcd_val.\n- concept: Algebraic Substitution\n  description: Replacing a variable in an equation with an equivalent expression derived from another equation to reduce the system to a single variable.\n  parameters:\n    - target_equation (type: equation): The equation into which substitution is performed\n    - substitution_expression (type: expression): The expression replacing the variable\n    - variable (type: symbol): The variable being eliminated\n  cues:\n    - Systems of equations with shared variables, especially where linear constraints allow easy isolation\n    - Expressions containing matching sub-expressions or derived forms where substitution simplifies structure or utilizes given values\n    - Problems involving ratio-based holdings or distribution expressions\n  implementation:\n    - Substitute isolated variables into other equations to reduce the system to a single variable (e.g., quadratic)\n    - Substitute sub-expressions or definitions into expressions to simplify computation or reveal structure (e.g., prime factorization)\n    - Substitute parameterized ratios into distribution expressions to link quantities to scaling factors"
  },
  "cmath_10620": {
    "hint": "## identity\n- concept: arithmetic_progression_mean\n  description: The mean of a finite set of consecutive integers is equal to the average of the first and last terms.\n  parameters:\n    - start (type: integer): The first integer in the sequence\n    - end (type: integer): The last integer in the sequence\n  cues:\n    - Problem asks for the average, mean, or sum of a set of integers\n    - The integers form a consecutive sequence or arithmetic progression\n  implementation:\n    - Compute the average as (first_term + last_term) / 2\n    - Avoid explicit summation or counting of elements\n\n## number theory tool\n- concept: GCD Computation\n  description: Calculating the greatest common divisor of two integers to analyze their divisibility relationship.\n  parameters:\n    - a (type: int): The first integer.\n    - b (type: int): The second integer.\n  cues:\n    - Problem involves common factors, simplification, or divisibility\n    - Explicit mention of gcd or greatest common divisor\n    - reducing fractions to irreducible form\n    - analyzing divisibility relationship\n    - Need to find the common divisor of multiple generated values\n    - Determining the greatest integer satisfying multiple divisibility constraints\n  implementation:\n    - Compute `g = gcd(m, 100)`\n    - Used to reduce probability fraction to irreducible form m/n.\n    - Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)\n\n## technique\n- concept: Odd Integer Parametrization\n  description: Representing positive odd integers x as 2y + 1 where y >= 0 to transform constraints into standard non-negative integer forms suitable for combinatorial methods.\n  parameters:\n    - count (type: integer): The number of odd integers to generate.\n    - start (type: integer): The starting odd integer (default 1).\n  cues:\n    - positive odd integers or sequences of odd numbers\n    - sum of odd numbers with parity constraints\n    - variables in the form 2k + 1\n  implementation:\n    - Substitute x_i = 2*y_i + 1 to transform the sum equation into 2 * sum(y_i) + k = S, converting constraints to standard non-negative integer forms.\n    - {'Generate sequences of odd integers (e.g., first 100 odds': '1, 3, ..., 199) to define the domain for valuation or summation.'}\n- concept: Fixed Divisor Determination\n  description: Determining the largest integer that divides a polynomial's value for all integer inputs by computing the GCD of the polynomial's values at a sufficient set of sample points.\n  cues:\n    - Problem asks for the largest integer that divides a polynomial's value for all integer inputs\n  implementation:\n    - Evaluate the polynomial at a sufficient set of small integer points and compute the GCD of the resulting values to determine the universal divisor"
  },
  "cmath_10622": {
    "hint": "## algorithmic pattern\n- concept: Constructive Enumeration\n  description: Generates valid instances by composing fundamental building blocks (e.g., primes) according to structural rules instead of brute-force checking.\n  parameters:\n    - primitives (type: list): Fundamental elements to build from (e.g., list of primes)\n    - construction_rules (type: list): Mathematical forms to apply to primitives (e.g., p^3, p*q)\n  cues:\n    - Search space consists of discrete structural configurations (e.g., partitions, subsets) or sequences rather than a numeric range, requiring generation via structural rules or primitives.\n    - Objective is to find an optimal value (min/max) or smallest k numbers with a property among valid configurations.\n  implementation:\n    - Generate candidates by composing primitives (e.g., primes) or iterating structural configurations (e.g., partitions, subsets, recurrence sequences).\n    - Iterate through generated candidates to compute derived values and identify the optimal result.\n\n## calculation method\n- concept: Summation of Distinct Values\n  description: Calculating the arithmetic sum of all unique values in a collection.\n  parameters:\n    - distinct_values (type: set): The set of unique numbers to sum\n  cues:\n    - Problem asks for the sum of all distinct/unique valid solutions or outcomes.\n    - Collected numbers are distinct by virtue of the search process.\n  implementation:\n    - Compute the final answer as the arithmetic sum of all elements in the collected set of valid values, typically by iterating and accumulating into a total sum variable.\n\n## formula\n- concept: Divisor Counting Formula\n  description: Computes the total number of positive divisors of an integer given its prime factorization exponents using the product of (exponent + 1).\n  cues:\n    - Problem asks for the count of divisors and prime factorization (or its exponents) is available or computable\n  implementation:\n    - Calculate the total number of divisors as the product of (exponent + 1) for each prime factor in the factorization\n\n## technique\n- concept: Exponential Growth Bounding\n  description: Limiting the search space for variables in exponential equations by observing that terms grow rapidly relative to the constant value, ensuring the search space is finite and small.\n  parameters:\n    - exponential_terms (type: list of expressions): The terms containing variables in exponents\n    - constant (type: integer): The target value the terms sum to or differ by\n  cues:\n    - Variables appear in exponents in an equation equal to a small constant\n  implementation:\n    - Determining bounds for x and y such that 2^(2x) and 3^(2y) do not excessively exceed 55 before starting iteration\n\n## theorem\n- concept: Divisor Count Structure\n  description: Characterizes the prime factorization form of an integer based on its total number of divisors using the divisor function formula tau(n).\n  parameters:\n    - target_divisors (type: integer): The exact number of divisors the integer must have\n  cues:\n    - Problem specifies an exact count of divisors (total or restricted) and requires determining the number's prime factorization structure (exponents).\n  implementation:\n    - Apply the relation tau(N) = product(e_i + 1) to derive prime exponents from the target divisor count (e.g., 3 factors implies p^2, 4 factors implies p^3 or p*q).\n    - If given a restricted divisor count (excluding 1 and N), infer the total divisor count D by adding 2.\n    - Validate that candidate numbers constructed from the derived exponents satisfy the original divisor count requirement."
  },
  "cmath_10677": {
    "hint": "## algorithm\n- concept: Modular Exponentiation\n  description: Efficiently computes (base^exponent) % modulus using binary exponentiation (square-and-multiply).\n  parameters:\n    - base (type: integer): The base of the power\n    - exponent (type: integer): The reduced exponent\n    - modulus (type: integer): The modulus for the operation\n  cues:\n    - Computing a power modulo m\n    - Base and exponent may be large\n    - Exponent is manageable after reduction\n  implementation:\n    - Compute base^exponent % modulus as the final step to obtain the result\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n\n## theorem\n- concept: Euler's Totient Theorem\n  description: States that if gcd(a, n) = 1, then a^phi(n) \u2261 1 (mod n), allowing exponent reduction modulo phi(n).\n  parameters:\n    - base (type: integer): The integer base 'a' which must be coprime to the modulus\n    - modulus (type: integer): The modulus 'n' for the congruence\n  cues:\n    - Computing a^b mod n where b is large\n    - Base and modulus are coprime (especially if modulus is prime)\n  implementation:\n    - Reduce exponent modulo phi(n) using a^phi(n) \u2261 1 (mod n) (use n-1 if modulus is prime)"
  },
  "cmath_10753": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## number theory tool\n- concept: Coprimality Check\n  description: Verifying two numbers are relatively prime by checking if their greatest common divisor is 1.\n  parameters:\n    - num1 (type: integer): First integer\n    - num2 (type: integer): Second integer\n  cues:\n    - Constraint explicitly requires gcd(a, b) = 1 or gcd(x, n) == 1\n    - Requirement for a modular inverse to exist or justification for division in congruences\n    - Problem involves reduced fractions, canonical representation, or numerators coprime to denominators\n    - Conditions requiring adjacent elements, derived variables, or factor pairs to be relatively prime\n    - Application of Euler's Totient Theorem\n  implementation:\n    - Check `if gcd(a, m) == 1` to validate precondition for modular inverse or division, returning error if failed\n    - Iterate through candidates, pairs, or residue systems, computing gcd to filter non-coprime elements or ensure coprimality (e.g., numerators/denominators)\n- concept: Divisor Enumeration\n  description: Computing the complete set of positive divisors for a given integer to identify candidate values satisfying divisibility conditions.\n  parameters:\n    - n (type: Integer): The integer to find divisors for\n    - target_number (type: integer): The integer whose divisors are being computed\n  cues:\n    - Problem involves divisibility constraints or checking if k divides N.\n    - Search space or conditions require finding all divisors or specific subsets (e.g., proper divisors) of a specific or derived integer.\n  implementation:\n    - Iterate from 1 to sqrt(N) to construct the set of all positive divisors of the target integer by checking divisibility.\n    - Filter divisors to exclude 1 and n if proper divisors are required.\n\n## technique\n- concept: GCD Pair Parametrization\n  description: Representing two integers x, y with gcd(x, y) = g as x = g*a, y = g*b where gcd(a, b) = 1 to simplify GCD/LCM constraints.\n  parameters:\n    - gcd_val (type: integer): The known greatest common divisor of the pair\n    - factors (type: pair of integers): The coprime coefficients a and b\n  cues:\n    - Problem involves finding integer pairs with specified GCD/LCM values or constraints linking them (e.g., LCM related to one of the numbers).\n  implementation:\n    - Parametrize integers as x = gcd_val * a, y = gcd_val * b with gcd(a, b) = 1.\n    - Reduce constraints to the product equation a * b = lcm_val / gcd_val."
  },
  "cmath_10821": {
    "hint": "## algorithm\n- concept: Extended Euclidean Algorithm\n  description: An extension of the Euclidean algorithm that computes the greatest common divisor of two integers a and b, along with coefficients x and y (B\u00e9zout's identity) such that ax + by = gcd(a, b).\n  parameters:\n    - a (type: integer): The integer to invert\n    - b (type: integer): Second integer input\n    - m (type: integer): The modulus (must be coprime to a)\n  cues:\n    - Computing GCD with B\u00e9zout coefficients (ax + by = gcd(a, b)) or solving linear Diophantine equations\n    - Computing modular multiplicative inverses (e.g., k^(-1) mod p), especially when the modulus is prime ensuring gcd(k, p) = 1\n  implementation:\n    - Define a recursive function `extended_gcd(a, b)` returning (gcd, x, y) with base case (b, 0, 1) when a=0\n    - Update coefficients in the recursive step using x = y1 - (b // a) * x1 derived from the previous call\n    - Extract coefficient x from the result to compute the modular inverse, adjusting for negative values if necessary\n\n## algorithmic pattern\n- concept: Arithmetic Progression Minimum Bound\n  description: Determining the smallest integer parameter in a linear expression (arithmetic progression) that satisfies a given lower bound constraint, typically using ceiling division.\n  cues:\n    - Requirement to find the smallest solution >= a specific LowerBound (e.g., \"least four-digit number\", \"smallest n > X\")\n    - Solution space forms an arithmetic progression or specific residue class defined by linear terms with an integer parameter (x_0 + k * M)\n  implementation:\n    - {'Calculate minimal integer k using ceiling division': 'k = Ceiling((LowerBound - x_0) / M)'}\n    - {'Compute the final value by adjusting the base solution': 'x_0 + k * M'}\n\n## number theory tool\n- concept: Coprimality Check\n  description: Verifying two numbers are relatively prime by checking if their greatest common divisor is 1.\n  parameters:\n    - num1 (type: integer): First integer\n    - num2 (type: integer): Second integer\n  cues:\n    - Constraint explicitly requires gcd(a, b) = 1 or gcd(x, n) == 1\n    - Requirement for a modular inverse to exist or justification for division in congruences\n    - Problem involves reduced fractions, canonical representation, or numerators coprime to denominators\n    - Conditions requiring adjacent elements, derived variables, or factor pairs to be relatively prime\n    - Application of Euler's Totient Theorem\n  implementation:\n    - Check `if gcd(a, m) == 1` to validate precondition for modular inverse or division, returning error if failed\n    - Iterate through candidates, pairs, or residue systems, computing gcd to filter non-coprime elements or ensure coprimality (e.g., numerators/denominators)\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n\n## technique\n- concept: Modular Inverse via Extended GCD\n  description: A method to compute the multiplicative inverse of an integer 'a' modulo 'm' by utilizing the Extended Euclidean Algorithm to solve ax \u2261 1 (mod m), valid only when gcd(a, m) = 1.\n  parameters:\n    - a (type: integer): The number to invert\n    - m (type: integer): The modulus\n  cues:\n    - Problem requires division in modular arithmetic or finding a multiplicative inverse (solving ax \u2261 1 (mod m))\n    - The coefficient and modulus are coprime (gcd(a, m) = 1), but the modulus is not guaranteed to be prime\n  implementation:\n    - Transform the problem into solving the Diophantine equation a * x + m * y = 1 using Extended GCD\n    - Include an assertion to verify that the gcd is 1, ensuring the inverse exists\n    - Normalize the resulting coefficient x using modulo m to ensure the result lies in the range [0, m-1]\n    - Used to find inverses in algorithms such as Linear Congruence Resolution or CRT construction\n- concept: Linear Congruence Resolution\n  description: Solves a linear congruence equation ax \u2261 b (mod m) by reducing coefficients via GCD and computing the modular inverse to isolate x.\n  parameters:\n    - coeff (type: integer): The coefficient 'a' of the variable x.\n    - constant (type: integer): The constant term 'b' on the RHS.\n    - modulus (type: integer): The modulus 'm'.\n  cues:\n    - Linear congruence equation ax \u2261 b (mod m) requiring isolation of x.\n  implementation:\n    - Reduced equation by dividing coeff, constant, and modulus by g = GCD(coeff, modulus).\n    - Computed modular inverse of reduced coefficient to find the residue."
  },
  "cmath_10854": {
    "hint": "## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: GCD Computation\n  description: Calculating the greatest common divisor of two integers to analyze their divisibility relationship.\n  parameters:\n    - a (type: int): The first integer.\n    - b (type: int): The second integer.\n  cues:\n    - Problem involves common factors, simplification, or divisibility\n    - Explicit mention of gcd or greatest common divisor\n    - reducing fractions to irreducible form\n    - analyzing divisibility relationship\n    - Need to find the common divisor of multiple generated values\n    - Determining the greatest integer satisfying multiple divisibility constraints\n  implementation:\n    - Compute `g = gcd(m, 100)`\n    - Used to reduce probability fraction to irreducible form m/n.\n    - Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)\n- concept: Divisibility Substitution\n  description: Replacing variables with parameterized forms based on known divisibility constraints (e.g., if x must be divisible by k, set x = k\u00b7t for integer t)\n  parameters:\n    - variable (type: symbol): The original variable subject to divisibility constraint\n    - divisor (type: integer): The known divisor that the variable must be a multiple of\n    - parameter (type: symbol): The new integer parameter representing the quotient\n  cues:\n    - Variable constrained by divisibility, congruences, or multiple conditions (e.g., multiple of k or mk + r)\n    - Problem involves partitioning or grouping with fixed sizes\n    - Need to reduce search space using structural constraints or density reduction\n    - Counting divisors subject to a multiple constraint (e.g., divisors of N that are multiples of k)\n    - Problem involves ratios, proportional holdings, or a common scaling factor\n  implementation:\n    - Substitute variables with divisor multiples or congruence forms (e.g., M = 8m or r = a + m\u00b7k) to simplify equations and reduce coefficients\n    - Substitute divisor d = k\u00b7m to transform 'd divides N and k divides d' into counting divisors of N/k\n    - Introduce a scaling factor k to represent proportional values (e.g., 3k, 4k, 5k) based on given ratios to facilitate equation formulation\n    - Define candidates as n * multiplier to reduce search space from limit values to limit/multiplier values\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: Valuation Analysis\n  description: Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.\n  parameters:\n    - p (type: prime): The prime base for the valuation.\n    - n (type: integer): The number to analyze for prime valuation.\n  cues:\n    - Equations involving multiplicative operations (LCM, GCD, division) or determining the exact prime power dividing quotients/rational expressions\n    - Constraints or properties applied independently to each prime factor (e.g., perfect powers, divisor counts, exponent divisibility)\n    - Logarithmic equations with integer constraints or base conversion involving primes\n  implementation:\n    - Extract exponents via full prime factorization or specific p-adic valuation calculations (repeated division/subtraction)\n    - Convert constraints (logarithms, perfect powers) into linear equations on exponents, solving for each prime independently before combining results\n- concept: Fixed Divisor Determination\n  description: Determining the largest integer that divides a polynomial's value for all integer inputs by computing the GCD of the polynomial's values at a sufficient set of sample points.\n  cues:\n    - Problem asks for the largest integer that divides a polynomial's value for all integer inputs\n  implementation:\n    - Evaluate the polynomial at a sufficient set of small integer points and compute the GCD of the resulting values to determine the universal divisor"
  },
  "cmath_10984": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## number theory tool\n- concept: Coprimality Check\n  description: Verifying two numbers are relatively prime by checking if their greatest common divisor is 1.\n  parameters:\n    - num1 (type: integer): First integer\n    - num2 (type: integer): Second integer\n  cues:\n    - Constraint explicitly requires gcd(a, b) = 1 or gcd(x, n) == 1\n    - Requirement for a modular inverse to exist or justification for division in congruences\n    - Problem involves reduced fractions, canonical representation, or numerators coprime to denominators\n    - Conditions requiring adjacent elements, derived variables, or factor pairs to be relatively prime\n    - Application of Euler's Totient Theorem\n  implementation:\n    - Check `if gcd(a, m) == 1` to validate precondition for modular inverse or division, returning error if failed\n    - Iterate through candidates, pairs, or residue systems, computing gcd to filter non-coprime elements or ensure coprimality (e.g., numerators/denominators)\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: Divisor Enumeration\n  description: Computing the complete set of positive divisors for a given integer to identify candidate values satisfying divisibility conditions.\n  parameters:\n    - n (type: Integer): The integer to find divisors for\n    - target_number (type: integer): The integer whose divisors are being computed\n  cues:\n    - Problem involves divisibility constraints or checking if k divides N.\n    - Search space or conditions require finding all divisors or specific subsets (e.g., proper divisors) of a specific or derived integer.\n  implementation:\n    - Iterate from 1 to sqrt(N) to construct the set of all positive divisors of the target integer by checking divisibility.\n    - Filter divisors to exclude 1 and n if proper divisors are required.\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: Algebraic Substitution\n  description: Replacing a variable in an equation with an equivalent expression derived from another equation to reduce the system to a single variable.\n  parameters:\n    - target_equation (type: equation): The equation into which substitution is performed\n    - substitution_expression (type: expression): The expression replacing the variable\n    - variable (type: symbol): The variable being eliminated\n  cues:\n    - Systems of equations with shared variables, especially where linear constraints allow easy isolation\n    - Expressions containing matching sub-expressions or derived forms where substitution simplifies structure or utilizes given values\n    - Problems involving ratio-based holdings or distribution expressions\n  implementation:\n    - Substitute isolated variables into other equations to reduce the system to a single variable (e.g., quadratic)\n    - Substitute sub-expressions or definitions into expressions to simplify computation or reveal structure (e.g., prime factorization)\n    - Substitute parameterized ratios into distribution expressions to link quantities to scaling factors"
  },
  "cmath_10994": {
    "hint": "## algebraic manipulation\n- concept: Base-b Polynomial Representation\n  description: Interpreting a number represented by digits in an unknown base b as a polynomial expression in b, where each digit is a coefficient corresponding to a power of b.\n  parameters:\n    - digits (type: list of integers): The sequence of digits d_n...d_0 representing the number.\n    - base_variable (type: symbol): The variable representing the unknown base (e.g., b).\n  cues:\n    - Problem involves numbers represented by digits in unspecified, variable, or multiple bases using positional notation (e.g., $121_c$ or equations mixing bases).\n    - Problem involves sums of distinct powers of 3 (equivalent to base-3 representation with digits 0 and 1).\n  implementation:\n    - Convert numbers from base-b representation to a polynomial in b (e.g., digits d_n...d_0 map to sum(d_i * b^i)); for sums of distinct powers, treat as base-b polynomials with binary coefficients.\n\n## number theory tool\n- concept: Minimum Valid Base Constraint\n  description: A constraint determining the lower bound for a valid base, which must be strictly greater than the largest digit value appearing in the number representations.\n  parameters:\n    - digits (type: set of integers): All unique digits appearing in the numbers within the problem.\n  cues:\n    - The base of the number system is unknown or represented by a variable.\n    - Numbers are expressed in standard positional notation involving specific digit values or distinct digit constraints.\n    - Solutions to equations yield multiple candidates (e.g., quadratic roots) requiring validation against digit constraints.\n  implementation:\n    - Identify the maximum digit value D across all numbers, establish the minimum valid base as max(D + 1, count of unique digits), and filter candidate solutions to satisfy this lower bound.\n\n## technique\n- concept: Digit Decomposition\n  description: Extracting individual digits from an integer in a given base to analyze their values or relationships.\n  parameters:\n    - number (type: integer): The integer to be decomposed into digits\n    - base (type: integer): The numerical base for decomposition (default 10)\n  cues:\n    - Problem involves extracting, analyzing, or performing arithmetic on individual digits, bits, or positional values in a specific base (e.g., decimal, binary, digit_sum, ith bit)\n    - References to decimal/fractional expansion or positional representation formulas (e.g., n = \u03a3(b_i * 2^i))\n  implementation:\n    - Decompose the number (integer or rational) into a sequence of digits or bits in the target base (e.g., via `decimal_digits(n)` or bit extraction)\n    - Treat the extracted digits for analysis or as coefficients in a summation"
  },
  "cmath_10997": {
    "hint": "## algebraic manipulation\n- concept: Base-b Polynomial Representation\n  description: Interpreting a number represented by digits in an unknown base b as a polynomial expression in b, where each digit is a coefficient corresponding to a power of b.\n  parameters:\n    - digits (type: list of integers): The sequence of digits d_n...d_0 representing the number.\n    - base_variable (type: symbol): The variable representing the unknown base (e.g., b).\n  cues:\n    - Problem involves numbers represented by digits in unspecified, variable, or multiple bases using positional notation (e.g., $121_c$ or equations mixing bases).\n    - Problem involves sums of distinct powers of 3 (equivalent to base-3 representation with digits 0 and 1).\n  implementation:\n    - Convert numbers from base-b representation to a polynomial in b (e.g., digits d_n...d_0 map to sum(d_i * b^i)); for sums of distinct powers, treat as base-b polynomials with binary coefficients.\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n\n## technique\n- concept: Digit Decomposition\n  description: Extracting individual digits from an integer in a given base to analyze their values or relationships.\n  parameters:\n    - number (type: integer): The integer to be decomposed into digits\n    - base (type: integer): The numerical base for decomposition (default 10)\n  cues:\n    - Problem involves extracting, analyzing, or performing arithmetic on individual digits, bits, or positional values in a specific base (e.g., decimal, binary, digit_sum, ith bit)\n    - References to decimal/fractional expansion or positional representation formulas (e.g., n = \u03a3(b_i * 2^i))\n  implementation:\n    - Decompose the number (integer or rational) into a sequence of digits or bits in the target base (e.g., via `decimal_digits(n)` or bit extraction)\n    - Treat the extracted digits for analysis or as coefficients in a summation\n- concept: Linear Congruence Resolution\n  description: Solves a linear congruence equation ax \u2261 b (mod m) by reducing coefficients via GCD and computing the modular inverse to isolate x.\n  parameters:\n    - coeff (type: integer): The coefficient 'a' of the variable x.\n    - constant (type: integer): The constant term 'b' on the RHS.\n    - modulus (type: integer): The modulus 'm'.\n  cues:\n    - Linear congruence equation ax \u2261 b (mod m) requiring isolation of x.\n  implementation:\n    - Reduced equation by dividing coeff, constant, and modulus by g = GCD(coeff, modulus).\n    - Computed modular inverse of reduced coefficient to find the residue."
  },
  "cmath_11021": {
    "hint": "## algebraic manipulation\n- concept: Base-b Polynomial Representation\n  description: Interpreting a number represented by digits in an unknown base b as a polynomial expression in b, where each digit is a coefficient corresponding to a power of b.\n  parameters:\n    - digits (type: list of integers): The sequence of digits d_n...d_0 representing the number.\n    - base_variable (type: symbol): The variable representing the unknown base (e.g., b).\n  cues:\n    - Problem involves numbers represented by digits in unspecified, variable, or multiple bases using positional notation (e.g., $121_c$ or equations mixing bases).\n    - Problem involves sums of distinct powers of 3 (equivalent to base-3 representation with digits 0 and 1).\n  implementation:\n    - Convert numbers from base-b representation to a polynomial in b (e.g., digits d_n...d_0 map to sum(d_i * b^i)); for sums of distinct powers, treat as base-b polynomials with binary coefficients.\n\n## technique\n- concept: Digit Decomposition\n  description: Extracting individual digits from an integer in a given base to analyze their values or relationships.\n  parameters:\n    - number (type: integer): The integer to be decomposed into digits\n    - base (type: integer): The numerical base for decomposition (default 10)\n  cues:\n    - Problem involves extracting, analyzing, or performing arithmetic on individual digits, bits, or positional values in a specific base (e.g., decimal, binary, digit_sum, ith bit)\n    - References to decimal/fractional expansion or positional representation formulas (e.g., n = \u03a3(b_i * 2^i))\n  implementation:\n    - Decompose the number (integer or rational) into a sequence of digits or bits in the target base (e.g., via `decimal_digits(n)` or bit extraction)\n    - Treat the extracted digits for analysis or as coefficients in a summation\n- concept: Binary-to-Base-k Digit Mapping\n  description: Determines the n-th term of a sequence formed by integers having only digits 0 and 1 in base k by interpreting the binary representation of n as a number in base k. This relies on the order-preserving bijection between the binary index and the restricted-digit values.\n  parameters:\n    - index (type: integer): The position n in the sequence (1-based or 0-based).\n    - target_base (type: integer): The base k used for the sequence values (e.g., 3 for sums of distinct powers of 3).\n  cues:\n    - Sequence elements are sums of distinct powers of a base (digits 0/1), forming an order-preserving bijection with binary integers\n    - Finding the n-th term of such a sequence\n  implementation:\n    - Map binary coefficients of n to powers of the target base to compute the term directly, avoiding brute-force generation"
  },
  "cmath_11032": {
    "hint": "## algorithmic pattern\n- concept: Constructive Enumeration\n  description: Generates valid instances by composing fundamental building blocks (e.g., primes) according to structural rules instead of brute-force checking.\n  parameters:\n    - primitives (type: list): Fundamental elements to build from (e.g., list of primes)\n    - construction_rules (type: list): Mathematical forms to apply to primitives (e.g., p^3, p*q)\n  cues:\n    - Search space consists of discrete structural configurations (e.g., partitions, subsets) or sequences rather than a numeric range, requiring generation via structural rules or primitives.\n    - Objective is to find an optimal value (min/max) or smallest k numbers with a property among valid configurations.\n  implementation:\n    - Generate candidates by composing primitives (e.g., primes) or iterating structural configurations (e.g., partitions, subsets, recurrence sequences).\n    - Iterate through generated candidates to compute derived values and identify the optimal result.\n\n## calculation method\n- concept: Summation of Distinct Values\n  description: Calculating the arithmetic sum of all unique values in a collection.\n  parameters:\n    - distinct_values (type: set): The set of unique numbers to sum\n  cues:\n    - Problem asks for the sum of all distinct/unique valid solutions or outcomes.\n    - Collected numbers are distinct by virtue of the search process.\n  implementation:\n    - Compute the final answer as the arithmetic sum of all elements in the collected set of valid values, typically by iterating and accumulating into a total sum variable.\n\n## number theory tool\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: Valuation Analysis\n  description: Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.\n  parameters:\n    - p (type: prime): The prime base for the valuation.\n    - n (type: integer): The number to analyze for prime valuation.\n  cues:\n    - Equations involving multiplicative operations (LCM, GCD, division) or determining the exact prime power dividing quotients/rational expressions\n    - Constraints or properties applied independently to each prime factor (e.g., perfect powers, divisor counts, exponent divisibility)\n    - Logarithmic equations with integer constraints or base conversion involving primes\n  implementation:\n    - Extract exponents via full prime factorization or specific p-adic valuation calculations (repeated division/subtraction)\n    - Convert constraints (logarithms, perfect powers) into linear equations on exponents, solving for each prime independently before combining results\n\n## theorem\n- concept: LCM Valuation Identity\n  description: The p-adic valuation of the least common multiple of two numbers is the maximum of their individual p-adic valuations.\n  cues:\n    - Problem involves LCM or GCD operations\n    - Need to simplify LCM expressions algebraically\n  implementation:\n    - Applied property v_p(lcm(x, y)) = max(v_p(x), v_p(y)) to transform the LCM equation into exponent equations."
  },
  "cmath_11038": {
    "hint": "## algorithmic pattern\n- concept: Iterative Accumulation\n  description: Accumulating a result by iterating through a sequence of values and updating a running total\n  parameters:\n    - sequence (type: list): The collection of values to iterate over.\n    - accumulator (type: variable): The variable storing the running sum or product\n    - start (type: integer): Starting value of the loop counter\n    - end (type: integer): Ending value of the loop counter\n    - update_rule (type: function): The function applied to the current element to update the sum\n    - operation (type: function): The transformation applied to each element before accumulation.\n  cues:\n    - Problem asks for an aggregate value (sum, product, count, digit sums) derived from a sequence, range, or enumerated items.\n    - Solution involves a loop iterating through a collection (list, range, or components like prime factors) where a running total or product variable is updated in each iteration.\n    - Aggregating results from multiple independent choices or cases (e.g., combinatorial products, inclusion-exclusion terms).\n    - Building a frequency map, histogram, or global metric by sequentially processing input data.\n  implementation:\n    - Initialize an accumulator variable to the identity value (0 for sums, 1 for products).\n    - Iterate through the sequence (range of integers, list of items, or prime factors).\n    - In each iteration, compute the contribution based on the current element and update the accumulator using the appropriate operation (addition, multiplication, modular arithmetic).\n    - If applicable, apply conditions before updating (e.g., only add if a value is valid/integer).\n    - Return the final accumulated value after the loop completes.\n\n## calculation method\n- concept: Summation of Distinct Values\n  description: Calculating the arithmetic sum of all unique values in a collection.\n  parameters:\n    - distinct_values (type: set): The set of unique numbers to sum\n  cues:\n    - Problem asks for the sum of all distinct/unique valid solutions or outcomes.\n    - Collected numbers are distinct by virtue of the search process.\n  implementation:\n    - Compute the final answer as the arithmetic sum of all elements in the collected set of valid values, typically by iterating and accumulating into a total sum variable.\n\n## number theory tool\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: Valuation Analysis\n  description: Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.\n  parameters:\n    - p (type: prime): The prime base for the valuation.\n    - n (type: integer): The number to analyze for prime valuation.\n  cues:\n    - Equations involving multiplicative operations (LCM, GCD, division) or determining the exact prime power dividing quotients/rational expressions\n    - Constraints or properties applied independently to each prime factor (e.g., perfect powers, divisor counts, exponent divisibility)\n    - Logarithmic equations with integer constraints or base conversion involving primes\n  implementation:\n    - Extract exponents via full prime factorization or specific p-adic valuation calculations (repeated division/subtraction)\n    - Convert constraints (logarithms, perfect powers) into linear equations on exponents, solving for each prime independently before combining results"
  },
  "cmath_1803": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Reverse Search for Maximum\n  description: Iterating from the theoretical upper bound downwards to find the largest value satisfying a predicate, allowing early termination.\n  parameters:\n    - start_val (type: integer): The maximum possible value to start searching from\n    - condition (type: predicate function): The boolean condition that the value must satisfy\n  cues:\n    - Objective is to find the largest discrete value satisfying a condition\n    - Search space consists of bounded, ordered discrete candidates\n    - Existence of a calculable theoretical upper bound\n    - Validity check is computationally feasible\n  implementation:\n    - Compute starting value as floor(upper_bound / divisor) to establish search start\n    - Iterate candidates from maximum possible value downwards\n    - Return immediately upon finding the first valid candidate\n- concept: Constructive Enumeration\n  description: Generates valid instances by composing fundamental building blocks (e.g., primes) according to structural rules instead of brute-force checking.\n  parameters:\n    - primitives (type: list): Fundamental elements to build from (e.g., list of primes)\n    - construction_rules (type: list): Mathematical forms to apply to primitives (e.g., p^3, p*q)\n  cues:\n    - Search space consists of discrete structural configurations (e.g., partitions, subsets) or sequences rather than a numeric range, requiring generation via structural rules or primitives.\n    - Objective is to find an optimal value (min/max) or smallest k numbers with a property among valid configurations.\n  implementation:\n    - Generate candidates by composing primitives (e.g., primes) or iterating structural configurations (e.g., partitions, subsets, recurrence sequences).\n    - Iterate through generated candidates to compute derived values and identify the optimal result.\n\n## calculation method\n- concept: Conditional Summation\n  description: Calculating the sum of values in a collection that satisfy a specific boolean predicate.\n  cues:\n    - Aggregating values based on a condition (e.g., Sum(x where P(x)))\n    - Partitioning a total sum into components based on properties\n  implementation:\n    - Computing separate sums for disjoint components based on properties (e.g., coprime vs non-coprime residues)\n    - Adding value to total_sum only when a specific condition is met (e.g., LCM match, leading non-zero constraint)\n\n## counting method\n- concept: Constraint-Ordered Counting\n  description: A strategy for constructive counting where variables are assigned values in descending order of constraint strictness. This ensures the number of available choices for subsequent variables remains constant regardless of specific previous choices, avoiding case analysis.\n  cues:\n    - Multiple overlapping constraints creating dependencies (e.g., distinctness, parity, non-zero, strictly increasing)\n    - Need to avoid case splitting by leveraging fixed order for combination logic\n  implementation:\n    - Assign variables in descending order of constraint strictness (e.g., parity, non-zero) to ensure constant option counts, enabling calculation via combinations from the available pool without case analysis"
  },
  "cmath_1817": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n- concept: Positional Digit Counting\n  description: Counting integers satisfying digit-level constraints by multiplying the number of valid choices for each digit position (Hundreds, Tens, Units, etc.).\n  parameters:\n    - positions (type: list): The digit positions to fill (e.g., [100, 10, 1]).\n    - constraints (type: list): Rules restricting valid digits at each position (e.g., distinctness, range bounds).\n  cues:\n    - Counting integers with fixed digit length or base b representation (e.g., Hundreds, Tens, Units)\n    - Digit-level constraints (parity, leading zero, specific values) or dependencies between positions (e.g., distinctness)\n  implementation:\n    - Decompose the number into positional components (e.g., Hundreds, Tens, Units or base b positions)\n    - Calculate valid digit choices for each position, adjusting for dependencies like distinctness based on previous selections, and apply the multiplication principle to compute total count\n- concept: Constraint-Ordered Counting\n  description: A strategy for constructive counting where variables are assigned values in descending order of constraint strictness. This ensures the number of available choices for subsequent variables remains constant regardless of specific previous choices, avoiding case analysis.\n  cues:\n    - Multiple overlapping constraints creating dependencies (e.g., distinctness, parity, non-zero, strictly increasing)\n    - Need to avoid case splitting by leveraging fixed order for combination logic\n  implementation:\n    - Assign variables in descending order of constraint strictness (e.g., parity, non-zero) to ensure constant option counts, enabling calculation via combinations from the available pool without case analysis\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks"
  },
  "cmath_1882": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Constructive Enumeration\n  description: Generates valid instances by composing fundamental building blocks (e.g., primes) according to structural rules instead of brute-force checking.\n  parameters:\n    - primitives (type: list): Fundamental elements to build from (e.g., list of primes)\n    - construction_rules (type: list): Mathematical forms to apply to primitives (e.g., p^3, p*q)\n  cues:\n    - Search space consists of discrete structural configurations (e.g., partitions, subsets) or sequences rather than a numeric range, requiring generation via structural rules or primitives.\n    - Objective is to find an optimal value (min/max) or smallest k numbers with a property among valid configurations.\n  implementation:\n    - Generate candidates by composing primitives (e.g., primes) or iterating structural configurations (e.g., partitions, subsets, recurrence sequences).\n    - Iterate through generated candidates to compute derived values and identify the optimal result.\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n\n## technique\n- concept: Graph Modeling\n  description: Translating a problem involving entities and pairwise relationships into a graph structure (vertices and edges) to leverage graph theoretic tools.\n  parameters:\n    - entities (type: set): The objects to be represented as vertices.\n    - relationships (type: set of pairs): The interactions to be represented as edges.\n  cues:\n    - handshakes\n    - network structure or pairwise relationships between entities\n  implementation:\n    - Model entities as Vertices V and relationships as Edges in Graph G"
  },
  "cmath_1923": {
    "hint": "## counting method\n- concept: Complementary Counting\n  description: Determining the count of elements satisfying a property by subtracting the count of elements that do not satisfy it from the total count.\n  parameters:\n    - total (type: integer): The total number of possibilities including invalid cases.\n    - excluded (type: integer): The number of invalid or unwanted possibilities to subtract.\n    - total_count (type: integer): The total number of elements in the universal set.\n    - complement_count (type: integer): The number of elements satisfying the negation of the target condition.\n  cues:\n    - Problem asks for \"at least one\", \"non-empty\", or \"not all\", or involves phrases like \"none\", \"never\", or \"all distinct\".\n    - Direct counting involves complex casework, but counting the complement is simpler.\n    - Total set size is easily determined.\n  implementation:\n    - Calculate result by subtracting the complement count from the total count.\n    - Subtract 1 from total_combinations to remove the empty selection case.\n- concept: Positional Digit Counting\n  description: Counting integers satisfying digit-level constraints by multiplying the number of valid choices for each digit position (Hundreds, Tens, Units, etc.).\n  parameters:\n    - positions (type: list): The digit positions to fill (e.g., [100, 10, 1]).\n    - constraints (type: list): Rules restricting valid digits at each position (e.g., distinctness, range bounds).\n  cues:\n    - Counting integers with fixed digit length or base b representation (e.g., Hundreds, Tens, Units)\n    - Digit-level constraints (parity, leading zero, specific values) or dependencies between positions (e.g., distinctness)\n  implementation:\n    - Decompose the number into positional components (e.g., Hundreds, Tens, Units or base b positions)\n    - Calculate valid digit choices for each position, adjusting for dependencies like distinctness based on previous selections, and apply the multiplication principle to compute total count\n- concept: Constraint-Ordered Counting\n  description: A strategy for constructive counting where variables are assigned values in descending order of constraint strictness. This ensures the number of available choices for subsequent variables remains constant regardless of specific previous choices, avoiding case analysis.\n  cues:\n    - Multiple overlapping constraints creating dependencies (e.g., distinctness, parity, non-zero, strictly increasing)\n    - Need to avoid case splitting by leveraging fixed order for combination logic\n  implementation:\n    - Assign variables in descending order of constraint strictness (e.g., parity, non-zero) to ensure constant option counts, enabling calculation via combinations from the available pool without case analysis\n\n## identity\n- concept: Multinomial Coefficient\n  description: A formula used to calculate the number of distinct permutations of a multiset (a set with repeated elements), given by n! / (n1! * n2! * ... * nk!).\n  parameters:\n    - total_count (type: integer): The total number of items (n).\n    - group_counts (type: list of integers): The counts of each identical group (n1, n2, ...).\n  cues:\n    - distinct permutations of a multiset or items with repeated elements\n  implementation:\n    - COMPUTE total_permutations using multinomial coefficient for all items combined"
  },
  "cmath_1937": {
    "hint": "## counting method\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n- concept: Constraint-Ordered Counting\n  description: A strategy for constructive counting where variables are assigned values in descending order of constraint strictness. This ensures the number of available choices for subsequent variables remains constant regardless of specific previous choices, avoiding case analysis.\n  cues:\n    - Multiple overlapping constraints creating dependencies (e.g., distinctness, parity, non-zero, strictly increasing)\n    - Need to avoid case splitting by leveraging fixed order for combination logic\n  implementation:\n    - Assign variables in descending order of constraint strictness (e.g., parity, non-zero) to ensure constant option counts, enabling calculation via combinations from the available pool without case analysis\n\n## technique\n- concept: Probability as Ratio of Counts\n  description: Calculating the probability of an event in a uniform sample space by dividing the count of favorable outcomes by the count of total possible outcomes.\n  parameters:\n    - favorable_count (type: integer): The number of outcomes satisfying the specific condition.\n    - total_count (type: integer): The total number of possible outcomes in the sample space.\n  cues:\n    - problem asks for probability of an event, arrangement, or configuration\n    - discrete uniform sample space implied\n    - ratio of favorable to total outcomes\n  implementation:\n    - DERIVE probability = favorable_outcomes / total_outcomes\n    - SIMPLIFY probability to lowest terms m/n"
  },
  "cmath_1941": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Set Deduplication\n  description: Using a set data structure to store results of a transformation to automatically filter duplicates, useful for identifying distinct outcomes.\n  parameters:\n    - values (type: iterable): The sequence of values to deduplicate\n  cues:\n    - Goal is to count the number of *unique* or *distinct* outcomes.\n    - Multiple different inputs may produce the same output value.\n  implementation:\n    - Initialize an empty set to store unique outcomes.\n    - Compute the value for each input and insert into the set to automatically filter duplicates.\n    - Return the cardinality of the set as the final answer.\n\n## technique\n- concept: Exponential Growth Bounding\n  description: Limiting the search space for variables in exponential equations by observing that terms grow rapidly relative to the constant value, ensuring the search space is finite and small.\n  parameters:\n    - exponential_terms (type: list of expressions): The terms containing variables in exponents\n    - constant (type: integer): The target value the terms sum to or differ by\n  cues:\n    - Variables appear in exponents in an equation equal to a small constant\n  implementation:\n    - Determining bounds for x and y such that 2^(2x) and 3^(2y) do not excessively exceed 55 before starting iteration"
  },
  "cmath_2000": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Constructive Enumeration\n  description: Generates valid instances by composing fundamental building blocks (e.g., primes) according to structural rules instead of brute-force checking.\n  parameters:\n    - primitives (type: list): Fundamental elements to build from (e.g., list of primes)\n    - construction_rules (type: list): Mathematical forms to apply to primitives (e.g., p^3, p*q)\n  cues:\n    - Search space consists of discrete structural configurations (e.g., partitions, subsets) or sequences rather than a numeric range, requiring generation via structural rules or primitives.\n    - Objective is to find an optimal value (min/max) or smallest k numbers with a property among valid configurations.\n  implementation:\n    - Generate candidates by composing primitives (e.g., primes) or iterating structural configurations (e.g., partitions, subsets, recurrence sequences).\n    - Iterate through generated candidates to compute derived values and identify the optimal result.\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication."
  },
  "cmath_2078": {
    "hint": "## algorithmic pattern\n- concept: Iterative Accumulation\n  description: Accumulating a result by iterating through a sequence of values and updating a running total\n  parameters:\n    - sequence (type: list): The collection of values to iterate over.\n    - accumulator (type: variable): The variable storing the running sum or product\n    - start (type: integer): Starting value of the loop counter\n    - end (type: integer): Ending value of the loop counter\n    - update_rule (type: function): The function applied to the current element to update the sum\n    - operation (type: function): The transformation applied to each element before accumulation.\n  cues:\n    - Problem asks for an aggregate value (sum, product, count, digit sums) derived from a sequence, range, or enumerated items.\n    - Solution involves a loop iterating through a collection (list, range, or components like prime factors) where a running total or product variable is updated in each iteration.\n    - Aggregating results from multiple independent choices or cases (e.g., combinatorial products, inclusion-exclusion terms).\n    - Building a frequency map, histogram, or global metric by sequentially processing input data.\n  implementation:\n    - Initialize an accumulator variable to the identity value (0 for sums, 1 for products).\n    - Iterate through the sequence (range of integers, list of items, or prime factors).\n    - In each iteration, compute the contribution based on the current element and update the accumulator using the appropriate operation (addition, multiplication, modular arithmetic).\n    - If applicable, apply conditions before updating (e.g., only add if a value is valid/integer).\n    - Return the final accumulated value after the loop completes.\n\n## technique\n- concept: Probability as Ratio of Counts\n  description: Calculating the probability of an event in a uniform sample space by dividing the count of favorable outcomes by the count of total possible outcomes.\n  parameters:\n    - favorable_count (type: integer): The number of outcomes satisfying the specific condition.\n    - total_count (type: integer): The total number of possible outcomes in the sample space.\n  cues:\n    - problem asks for probability of an event, arrangement, or configuration\n    - discrete uniform sample space implied\n    - ratio of favorable to total outcomes\n  implementation:\n    - DERIVE probability = favorable_outcomes / total_outcomes\n    - SIMPLIFY probability to lowest terms m/n\n- concept: Linear Recurrence Counting\n  description: Solving counting problems by defining a sequence where each term depends on previous terms based on how valid configurations can be extended.\n  parameters:\n    - state_definition (type: string): Definition of what the sequence term dp[i] represents.\n    - base_cases (type: list): Initial values for the sequence.\n    - transition_rule (type: equation): The recurrence relation expressing dp[i] in terms of previous terms.\n  cues:\n    - counting valid sequences of length n with local constraints where solutions can be built from smaller subproblems\n  implementation:\n    - Define dp[i] as the count of valid configurations of length i, establish base cases, and derive a transition rule based on how valid configurations can be extended (e.g., dp[i] = dp[i-1] + dp[i-2] for appending '0' or '01').\n- concept: Graph Modeling\n  description: Translating a problem involving entities and pairwise relationships into a graph structure (vertices and edges) to leverage graph theoretic tools.\n  parameters:\n    - entities (type: set): The objects to be represented as vertices.\n    - relationships (type: set of pairs): The interactions to be represented as edges.\n  cues:\n    - handshakes\n    - network structure or pairwise relationships between entities\n  implementation:\n    - Model entities as Vertices V and relationships as Edges in Graph G\n\n## theorem\n- concept: Law of Total Probability\n  description: Computes the probability of an event by summing the conditional probabilities of the event given each partition of the sample space, weighted by the probability of each partition.\n  cues:\n    - Problem involves mutually exclusive scenarios or hypotheses\n    - Need to compute marginal or predictive probability by averaging conditional probabilities over a distribution of states\n  implementation:\n    - Computed total or predictive probability by summing conditional probabilities weighted by prior or posterior probabilities of each scenario\n- concept: Independent Event Probability Product\n  description: The probability of multiple independent events all occurring is the product of their individual probabilities.\n  parameters:\n    - probabilities (type: list of float): List of probabilities for each independent event.\n  cues:\n    - independent trials\n    - repeated experiments\n    - all failures\n  implementation:\n    - Step 2 models P(all failures) as (p_failure)^n."
  },
  "cmath_2084": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Iterative Accumulation\n  description: Accumulating a result by iterating through a sequence of values and updating a running total\n  parameters:\n    - sequence (type: list): The collection of values to iterate over.\n    - accumulator (type: variable): The variable storing the running sum or product\n    - start (type: integer): Starting value of the loop counter\n    - end (type: integer): Ending value of the loop counter\n    - update_rule (type: function): The function applied to the current element to update the sum\n    - operation (type: function): The transformation applied to each element before accumulation.\n  cues:\n    - Problem asks for an aggregate value (sum, product, count, digit sums) derived from a sequence, range, or enumerated items.\n    - Solution involves a loop iterating through a collection (list, range, or components like prime factors) where a running total or product variable is updated in each iteration.\n    - Aggregating results from multiple independent choices or cases (e.g., combinatorial products, inclusion-exclusion terms).\n    - Building a frequency map, histogram, or global metric by sequentially processing input data.\n  implementation:\n    - Initialize an accumulator variable to the identity value (0 for sums, 1 for products).\n    - Iterate through the sequence (range of integers, list of items, or prime factors).\n    - In each iteration, compute the contribution based on the current element and update the accumulator using the appropriate operation (addition, multiplication, modular arithmetic).\n    - If applicable, apply conditions before updating (e.g., only add if a value is valid/integer).\n    - Return the final accumulated value after the loop completes.\n\n## formula\n- concept: Arithmetic Progression Count\n  description: Calculates the number of terms in an arithmetic progression (start, start+step, ...) that are less than or equal to a given limit.\n  parameters:\n    - start (type: integer): The first term of the arithmetic progression.\n    - step (type: integer): The common difference between consecutive terms.\n    - limit (type: integer): The upper bound for the terms.\n  cues:\n    - Need to count integers (included or excluded) in a range that form a regular sequence with constant difference (e.g., satisfying a linear congruence).\n    - Range is large, requiring an O(1) formula instead of iteration.\n  implementation:\n    - Identify sequence parameters (start, step) from the condition (e.g., k \u2261 2 mod 4 implies start=2, step=4).\n    - {'Compute count using formula': 'FLOOR((limit - start) / step) + 1.'}\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n\n## technique\n- concept: Graph Modeling\n  description: Translating a problem involving entities and pairwise relationships into a graph structure (vertices and edges) to leverage graph theoretic tools.\n  parameters:\n    - entities (type: set): The objects to be represented as vertices.\n    - relationships (type: set of pairs): The interactions to be represented as edges.\n  cues:\n    - handshakes\n    - network structure or pairwise relationships between entities\n  implementation:\n    - Model entities as Vertices V and relationships as Edges in Graph G\n\n## theorem\n- concept: Cycle Graph Edge Count\n  description: A simple cycle graph containing n vertices possesses exactly n edges.\n  parameters:\n    - n (type: integer): The number of vertices in the cycle.\n  cues:\n    - circular arrangement or closed loop structure\n    - 2-regular graph constraints (every vertex has degree 2) or minimizing edges to maintain degree 2 for all vertices\n  implementation:\n    - A simple cycle graph with n vertices has exactly n edges (e.g., min_handshakes = n_people where each person shakes hands with exactly two others in a circle)"
  },
  "cmath_2092": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n\n## number theory tool\n- concept: GCD Computation\n  description: Calculating the greatest common divisor of two integers to analyze their divisibility relationship.\n  parameters:\n    - a (type: int): The first integer.\n    - b (type: int): The second integer.\n  cues:\n    - Problem involves common factors, simplification, or divisibility\n    - Explicit mention of gcd or greatest common divisor\n    - reducing fractions to irreducible form\n    - analyzing divisibility relationship\n    - Need to find the common divisor of multiple generated values\n    - Determining the greatest integer satisfying multiple divisibility constraints\n  implementation:\n    - Compute `g = gcd(m, 100)`\n    - Used to reduce probability fraction to irreducible form m/n.\n    - Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)\n\n## technique\n- concept: Probability as Ratio of Counts\n  description: Calculating the probability of an event in a uniform sample space by dividing the count of favorable outcomes by the count of total possible outcomes.\n  parameters:\n    - favorable_count (type: integer): The number of outcomes satisfying the specific condition.\n    - total_count (type: integer): The total number of possible outcomes in the sample space.\n  cues:\n    - problem asks for probability of an event, arrangement, or configuration\n    - discrete uniform sample space implied\n    - ratio of favorable to total outcomes\n  implementation:\n    - DERIVE probability = favorable_outcomes / total_outcomes\n    - SIMPLIFY probability to lowest terms m/n"
  },
  "cmath_2096": {
    "hint": "## algorithmic pattern\n- concept: Iterative Accumulation\n  description: Accumulating a result by iterating through a sequence of values and updating a running total\n  parameters:\n    - sequence (type: list): The collection of values to iterate over.\n    - accumulator (type: variable): The variable storing the running sum or product\n    - start (type: integer): Starting value of the loop counter\n    - end (type: integer): Ending value of the loop counter\n    - update_rule (type: function): The function applied to the current element to update the sum\n    - operation (type: function): The transformation applied to each element before accumulation.\n  cues:\n    - Problem asks for an aggregate value (sum, product, count, digit sums) derived from a sequence, range, or enumerated items.\n    - Solution involves a loop iterating through a collection (list, range, or components like prime factors) where a running total or product variable is updated in each iteration.\n    - Aggregating results from multiple independent choices or cases (e.g., combinatorial products, inclusion-exclusion terms).\n    - Building a frequency map, histogram, or global metric by sequentially processing input data.\n  implementation:\n    - Initialize an accumulator variable to the identity value (0 for sums, 1 for products).\n    - Iterate through the sequence (range of integers, list of items, or prime factors).\n    - In each iteration, compute the contribution based on the current element and update the accumulator using the appropriate operation (addition, multiplication, modular arithmetic).\n    - If applicable, apply conditions before updating (e.g., only add if a value is valid/integer).\n    - Return the final accumulated value after the loop completes.\n\n## counting method\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n- concept: Ordered Pair Symmetry Counting\n  description: Counting ordered pairs (a, b) by iterating through unordered sets {a, b} and applying weights (2 for distinct elements, 1 for identical) to account for permutations.\n  cues:\n    - Problem asks for ordered pairs but iteration constraints imply unordered generation (e.g., a <= b)\n    - Symmetric equations (e.g., a^2 + b^2 = n)\n  implementation:\n    - Add 2 to count when a != b (accounting for (a,b) and (b,a)), or 1 when a == b (accounting for (a,a))\n\n## formula\n- concept: Sum of Squares Formula\n  description: Expresses the sum of the first k positive squares as a cubic polynomial k(k+1)(2k+1)/6.\n  parameters:\n    - k (type: integer): The number of terms to sum (upper bound of the sequence 1^2 + ... + k^2)\n  cues:\n    - Define S(k) = k(k + 1)(2k + 1) / 6\n  implementation:\n    - Replaces the iterative summation of squares with a closed-form polynomial expression.\n    - Allows efficient computation of S(k) for each candidate k during the search.\n\n## number theory tool\n- concept: GCD Computation\n  description: Calculating the greatest common divisor of two integers to analyze their divisibility relationship.\n  parameters:\n    - a (type: int): The first integer.\n    - b (type: int): The second integer.\n  cues:\n    - Problem involves common factors, simplification, or divisibility\n    - Explicit mention of gcd or greatest common divisor\n    - reducing fractions to irreducible form\n    - analyzing divisibility relationship\n    - Need to find the common divisor of multiple generated values\n    - Determining the greatest integer satisfying multiple divisibility constraints\n  implementation:\n    - Compute `g = gcd(m, 100)`\n    - Used to reduce probability fraction to irreducible form m/n.\n    - Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)\n\n## technique\n- concept: Probability as Ratio of Counts\n  description: Calculating the probability of an event in a uniform sample space by dividing the count of favorable outcomes by the count of total possible outcomes.\n  parameters:\n    - favorable_count (type: integer): The number of outcomes satisfying the specific condition.\n    - total_count (type: integer): The total number of possible outcomes in the sample space.\n  cues:\n    - problem asks for probability of an event, arrangement, or configuration\n    - discrete uniform sample space implied\n    - ratio of favorable to total outcomes\n  implementation:\n    - DERIVE probability = favorable_outcomes / total_outcomes\n    - SIMPLIFY probability to lowest terms m/n\n\n## theorem\n- concept: Linearity of Expectation\n  description: The expected value of a sum of random variables is equal to the sum of their individual expected values. For n identical variables, E[Total] = n * E[Single].\n  parameters:\n    - n (type: integer): Number of independent trials or periods\n    - E_single (type: float): Expected value of a single trial or period\n  cues:\n    - Total expected value via sum of expectations\n    - Aggregating over independent periods\n  implementation:\n    - Computing total expected value E_total = n * E_single"
  },
  "cmath_2098": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Cartesian Product Enumeration\n  description: Generating all ordered tuples of a fixed length from a base set, allowing repetition.\n  parameters:\n    - base_set (type: set): The set of values to pick from\n    - length (type: int): The number of elements to pick\n  cues:\n    - Enumerating fixed-length sequences or composite objects where each component is independently chosen from a set of valid options (exhaustive search space)\n  implementation:\n    - Generate all outcomes via Cartesian product of the base set (or valid rows) with fixed repetition\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n\n## formula\n- concept: Pairwise Combination Formula\n  description: Calculates the number of unique pairs that can be formed from a set of n elements, given by the formula n(n-1)/2.\n  parameters:\n    - n (type: integer): The size of the set from which pairs are formed.\n  cues:\n    - Round-robin tournament structures\n    - Handshake problems\n    - Counting edges in a complete graph\n    - Problems involving interactions between all distinct pairs of items\n    - Choosing 2 distinct items from a set\n    - Order irrelevant due to sorting constraint\n    - Product of geometric sequence terms\n    - Sum of arithmetic progression in exponent\n  implementation:\n    - Calculated `total_games` as `num_teams * (num_teams - 1) / 2` to determine the total number of matches in the tournament.\n    - Computing ways_to_choose_prefix using Binomial_Coefficient(last_digit - 1, 2)\n    - Computed exponent of ratio r as n_terms * (n_terms - 1) / 2\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks"
  },
  "cmath_2106": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n\n## number theory tool\n- concept: Coprimality Check\n  description: Verifying two numbers are relatively prime by checking if their greatest common divisor is 1.\n  parameters:\n    - num1 (type: integer): First integer\n    - num2 (type: integer): Second integer\n  cues:\n    - Constraint explicitly requires gcd(a, b) = 1 or gcd(x, n) == 1\n    - Requirement for a modular inverse to exist or justification for division in congruences\n    - Problem involves reduced fractions, canonical representation, or numerators coprime to denominators\n    - Conditions requiring adjacent elements, derived variables, or factor pairs to be relatively prime\n    - Application of Euler's Totient Theorem\n  implementation:\n    - Check `if gcd(a, m) == 1` to validate precondition for modular inverse or division, returning error if failed\n    - Iterate through candidates, pairs, or residue systems, computing gcd to filter non-coprime elements or ensure coprimality (e.g., numerators/denominators)\n\n## technique\n- concept: Probability as Ratio of Counts\n  description: Calculating the probability of an event in a uniform sample space by dividing the count of favorable outcomes by the count of total possible outcomes.\n  parameters:\n    - favorable_count (type: integer): The number of outcomes satisfying the specific condition.\n    - total_count (type: integer): The total number of possible outcomes in the sample space.\n  cues:\n    - problem asks for probability of an event, arrangement, or configuration\n    - discrete uniform sample space implied\n    - ratio of favorable to total outcomes\n  implementation:\n    - DERIVE probability = favorable_outcomes / total_outcomes\n    - SIMPLIFY probability to lowest terms m/n"
  },
  "cmath_2115": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Grid Dynamic Programming\n  description: Solving problems by defining states on a 2D grid and computing values iteratively based on transitions from previous states (e.g., top, left, diagonal).\n  parameters:\n    - grid_size (type: integer): The dimensions of the grid (e.g., N x N).\n    - base_cases (type: map): Initial values for boundary conditions (e.g., DP[0][0] = 1).\n    - transition_rule (type: function): The recurrence relation defining a cell's value based on neighbors.\n  cues:\n    - 2D state space or grid structure\n    - Sequential dependency where state (i, j) depends on (i-1, j), (i, j-1), etc.\n    - Path counting or probability propagation problems\n  implementation:\n    - Initialized a 2D DP table of size (N+1) x (N+1).\n    - Set base cases DP[0][0] = 1 and boundaries to 0.\n    - Filled the table using nested loops with the recurrence DP[i][j] = (1/3) * sum(neighbors).\n\n## counting method\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n- concept: Complementary Counting\n  description: Determining the count of elements satisfying a property by subtracting the count of elements that do not satisfy it from the total count.\n  parameters:\n    - total (type: integer): The total number of possibilities including invalid cases.\n    - excluded (type: integer): The number of invalid or unwanted possibilities to subtract.\n    - total_count (type: integer): The total number of elements in the universal set.\n    - complement_count (type: integer): The number of elements satisfying the negation of the target condition.\n  cues:\n    - Problem asks for \"at least one\", \"non-empty\", or \"not all\", or involves phrases like \"none\", \"never\", or \"all distinct\".\n    - Direct counting involves complex casework, but counting the complement is simpler.\n    - Total set size is easily determined.\n  implementation:\n    - Calculate result by subtracting the complement count from the total count.\n    - Subtract 1 from total_combinations to remove the empty selection case.\n- concept: Principle of Inclusion-Exclusion\n  description: A combinatorial technique to calculate the number of elements satisfying none of several properties by alternately adding and subtracting the sizes of intersections of subsets of properties.\n  cues:\n    - Problem involves counting objects satisfying conditions (e.g., surjectivity, derangements) where constraints are defined by the exclusion of specific properties.\n    - Solution structure involves an alternating summation with terms like (-1)^k.\n  implementation:\n    - Sum over the number of excluded properties `i`, alternating signs using `(-1)^i`.\n    - Compute term magnitude as the product of ways to choose excluded properties and ways to satisfy the remaining constraints.\n\n## number theory tool\n- concept: GCD Computation\n  description: Calculating the greatest common divisor of two integers to analyze their divisibility relationship.\n  parameters:\n    - a (type: int): The first integer.\n    - b (type: int): The second integer.\n  cues:\n    - Problem involves common factors, simplification, or divisibility\n    - Explicit mention of gcd or greatest common divisor\n    - reducing fractions to irreducible form\n    - analyzing divisibility relationship\n    - Need to find the common divisor of multiple generated values\n    - Determining the greatest integer satisfying multiple divisibility constraints\n  implementation:\n    - Compute `g = gcd(m, 100)`\n    - Used to reduce probability fraction to irreducible form m/n.\n    - Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)\n\n## technique\n- concept: Probability as Ratio of Counts\n  description: Calculating the probability of an event in a uniform sample space by dividing the count of favorable outcomes by the count of total possible outcomes.\n  parameters:\n    - favorable_count (type: integer): The number of outcomes satisfying the specific condition.\n    - total_count (type: integer): The total number of possible outcomes in the sample space.\n  cues:\n    - problem asks for probability of an event, arrangement, or configuration\n    - discrete uniform sample space implied\n    - ratio of favorable to total outcomes\n  implementation:\n    - DERIVE probability = favorable_outcomes / total_outcomes\n    - SIMPLIFY probability to lowest terms m/n"
  },
  "cmath_2116": {
    "hint": "## counting method\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n- concept: Positional Digit Counting\n  description: Counting integers satisfying digit-level constraints by multiplying the number of valid choices for each digit position (Hundreds, Tens, Units, etc.).\n  parameters:\n    - positions (type: list): The digit positions to fill (e.g., [100, 10, 1]).\n    - constraints (type: list): Rules restricting valid digits at each position (e.g., distinctness, range bounds).\n  cues:\n    - Counting integers with fixed digit length or base b representation (e.g., Hundreds, Tens, Units)\n    - Digit-level constraints (parity, leading zero, specific values) or dependencies between positions (e.g., distinctness)\n  implementation:\n    - Decompose the number into positional components (e.g., Hundreds, Tens, Units or base b positions)\n    - Calculate valid digit choices for each position, adjusting for dependencies like distinctness based on previous selections, and apply the multiplication principle to compute total count\n\n## number theory tool\n- concept: Coprimality Check\n  description: Verifying two numbers are relatively prime by checking if their greatest common divisor is 1.\n  parameters:\n    - num1 (type: integer): First integer\n    - num2 (type: integer): Second integer\n  cues:\n    - Constraint explicitly requires gcd(a, b) = 1 or gcd(x, n) == 1\n    - Requirement for a modular inverse to exist or justification for division in congruences\n    - Problem involves reduced fractions, canonical representation, or numerators coprime to denominators\n    - Conditions requiring adjacent elements, derived variables, or factor pairs to be relatively prime\n    - Application of Euler's Totient Theorem\n  implementation:\n    - Check `if gcd(a, m) == 1` to validate precondition for modular inverse or division, returning error if failed\n    - Iterate through candidates, pairs, or residue systems, computing gcd to filter non-coprime elements or ensure coprimality (e.g., numerators/denominators)\n\n## technique\n- concept: Probability as Ratio of Counts\n  description: Calculating the probability of an event in a uniform sample space by dividing the count of favorable outcomes by the count of total possible outcomes.\n  parameters:\n    - favorable_count (type: integer): The number of outcomes satisfying the specific condition.\n    - total_count (type: integer): The total number of possible outcomes in the sample space.\n  cues:\n    - problem asks for probability of an event, arrangement, or configuration\n    - discrete uniform sample space implied\n    - ratio of favorable to total outcomes\n  implementation:\n    - DERIVE probability = favorable_outcomes / total_outcomes\n    - SIMPLIFY probability to lowest terms m/n\n\n## theorem\n- concept: Complementary Probability\n  description: Calculates the probability of an event occurring at least once by subtracting the probability of it never occurring from 1.\n  parameters:\n    - p_event (type: float): Probability of the event occurring in a single trial.\n  cues:\n    - at least one success\n    - target probability\n    - minimum trials\n  implementation:\n    - Step 1 converts target success probability to max allowed failure probability using 1 - p_success.\n- concept: Independent Event Probability Product\n  description: The probability of multiple independent events all occurring is the product of their individual probabilities.\n  parameters:\n    - probabilities (type: list of float): List of probabilities for each independent event.\n  cues:\n    - independent trials\n    - repeated experiments\n    - all failures\n  implementation:\n    - Step 2 models P(all failures) as (p_failure)^n."
  },
  "cmath_2119": {
    "hint": "## counting method\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n- concept: Complementary Counting\n  description: Determining the count of elements satisfying a property by subtracting the count of elements that do not satisfy it from the total count.\n  parameters:\n    - total (type: integer): The total number of possibilities including invalid cases.\n    - excluded (type: integer): The number of invalid or unwanted possibilities to subtract.\n    - total_count (type: integer): The total number of elements in the universal set.\n    - complement_count (type: integer): The number of elements satisfying the negation of the target condition.\n  cues:\n    - Problem asks for \"at least one\", \"non-empty\", or \"not all\", or involves phrases like \"none\", \"never\", or \"all distinct\".\n    - Direct counting involves complex casework, but counting the complement is simpler.\n    - Total set size is easily determined.\n  implementation:\n    - Calculate result by subtracting the complement count from the total count.\n    - Subtract 1 from total_combinations to remove the empty selection case.\n- concept: Ordered Pair Symmetry Counting\n  description: Counting ordered pairs (a, b) by iterating through unordered sets {a, b} and applying weights (2 for distinct elements, 1 for identical) to account for permutations.\n  cues:\n    - Problem asks for ordered pairs but iteration constraints imply unordered generation (e.g., a <= b)\n    - Symmetric equations (e.g., a^2 + b^2 = n)\n  implementation:\n    - Add 2 to count when a != b (accounting for (a,b) and (b,a)), or 1 when a == b (accounting for (a,a))\n- concept: Principle of Inclusion-Exclusion\n  description: A combinatorial technique to calculate the number of elements satisfying none of several properties by alternately adding and subtracting the sizes of intersections of subsets of properties.\n  cues:\n    - Problem involves counting objects satisfying conditions (e.g., surjectivity, derangements) where constraints are defined by the exclusion of specific properties.\n    - Solution structure involves an alternating summation with terms like (-1)^k.\n  implementation:\n    - Sum over the number of excluded properties `i`, alternating signs using `(-1)^i`.\n    - Compute term magnitude as the product of ways to choose excluded properties and ways to satisfy the remaining constraints.\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n\n## technique\n- concept: Set Partition Counting\n  description: Modeling distribution problems where items are distinguishable and bins are indistinguishable as set partition problems.\n  cues:\n    - distinct elements\n    - identical containers\n  implementation:\n    - The initial conditional check identifies this scenario to apply partition counting formulas"
  },
  "cmath_2123": {
    "hint": "## counting method\n- concept: Complementary Counting\n  description: Determining the count of elements satisfying a property by subtracting the count of elements that do not satisfy it from the total count.\n  parameters:\n    - total (type: integer): The total number of possibilities including invalid cases.\n    - excluded (type: integer): The number of invalid or unwanted possibilities to subtract.\n    - total_count (type: integer): The total number of elements in the universal set.\n    - complement_count (type: integer): The number of elements satisfying the negation of the target condition.\n  cues:\n    - Problem asks for \"at least one\", \"non-empty\", or \"not all\", or involves phrases like \"none\", \"never\", or \"all distinct\".\n    - Direct counting involves complex casework, but counting the complement is simpler.\n    - Total set size is easily determined.\n  implementation:\n    - Calculate result by subtracting the complement count from the total count.\n    - Subtract 1 from total_combinations to remove the empty selection case.\n\n## number theory tool\n- concept: GCD Computation\n  description: Calculating the greatest common divisor of two integers to analyze their divisibility relationship.\n  parameters:\n    - a (type: int): The first integer.\n    - b (type: int): The second integer.\n  cues:\n    - Problem involves common factors, simplification, or divisibility\n    - Explicit mention of gcd or greatest common divisor\n    - reducing fractions to irreducible form\n    - analyzing divisibility relationship\n    - Need to find the common divisor of multiple generated values\n    - Determining the greatest integer satisfying multiple divisibility constraints\n  implementation:\n    - Compute `g = gcd(m, 100)`\n    - Used to reduce probability fraction to irreducible form m/n.\n    - Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)\n\n## technique\n- concept: Probability as Ratio of Counts\n  description: Calculating the probability of an event in a uniform sample space by dividing the count of favorable outcomes by the count of total possible outcomes.\n  parameters:\n    - favorable_count (type: integer): The number of outcomes satisfying the specific condition.\n    - total_count (type: integer): The total number of possible outcomes in the sample space.\n  cues:\n    - problem asks for probability of an event, arrangement, or configuration\n    - discrete uniform sample space implied\n    - ratio of favorable to total outcomes\n  implementation:\n    - DERIVE probability = favorable_outcomes / total_outcomes\n    - SIMPLIFY probability to lowest terms m/n\n- concept: Linear Recurrence Counting\n  description: Solving counting problems by defining a sequence where each term depends on previous terms based on how valid configurations can be extended.\n  parameters:\n    - state_definition (type: string): Definition of what the sequence term dp[i] represents.\n    - base_cases (type: list): Initial values for the sequence.\n    - transition_rule (type: equation): The recurrence relation expressing dp[i] in terms of previous terms.\n  cues:\n    - counting valid sequences of length n with local constraints where solutions can be built from smaller subproblems\n  implementation:\n    - Define dp[i] as the count of valid configurations of length i, establish base cases, and derive a transition rule based on how valid configurations can be extended (e.g., dp[i] = dp[i-1] + dp[i-2] for appending '0' or '01').\n\n## theorem\n- concept: Law of Total Probability\n  description: Computes the probability of an event by summing the conditional probabilities of the event given each partition of the sample space, weighted by the probability of each partition.\n  cues:\n    - Problem involves mutually exclusive scenarios or hypotheses\n    - Need to compute marginal or predictive probability by averaging conditional probabilities over a distribution of states\n  implementation:\n    - Computed total or predictive probability by summing conditional probabilities weighted by prior or posterior probabilities of each scenario"
  },
  "cmath_2124": {
    "hint": "## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n- concept: Principle of Inclusion-Exclusion\n  description: A combinatorial technique to calculate the number of elements satisfying none of several properties by alternately adding and subtracting the sizes of intersections of subsets of properties.\n  cues:\n    - Problem involves counting objects satisfying conditions (e.g., surjectivity, derangements) where constraints are defined by the exclusion of specific properties.\n    - Solution structure involves an alternating summation with terms like (-1)^k.\n  implementation:\n    - Sum over the number of excluded properties `i`, alternating signs using `(-1)^i`.\n    - Compute term magnitude as the product of ways to choose excluded properties and ways to satisfy the remaining constraints.\n\n## number theory tool\n- concept: Coprimality Check\n  description: Verifying two numbers are relatively prime by checking if their greatest common divisor is 1.\n  parameters:\n    - num1 (type: integer): First integer\n    - num2 (type: integer): Second integer\n  cues:\n    - Constraint explicitly requires gcd(a, b) = 1 or gcd(x, n) == 1\n    - Requirement for a modular inverse to exist or justification for division in congruences\n    - Problem involves reduced fractions, canonical representation, or numerators coprime to denominators\n    - Conditions requiring adjacent elements, derived variables, or factor pairs to be relatively prime\n    - Application of Euler's Totient Theorem\n  implementation:\n    - Check `if gcd(a, m) == 1` to validate precondition for modular inverse or division, returning error if failed\n    - Iterate through candidates, pairs, or residue systems, computing gcd to filter non-coprime elements or ensure coprimality (e.g., numerators/denominators)\n- concept: Divisibility Counting Formula\n  description: Calculates the number of multiples of an integer k within the range [1, N] using the floor division formula floor(N / k).\n  parameters:\n    - limit (type: integer): The upper bound of the range (inclusive)\n    - divisor (type: integer): The number whose multiples are being counted\n  cues:\n    - Counting multiples or divisible numbers within a large range [1, N] where enumeration is inefficient (requires floor(N / k))\n  implementation:\n    - Use floor(N / k) to calculate the number of multiples of k in range [1, N]\n    - Apply formula inside loops for dynamic divisors (e.g., powers of a prime)\n    - Extend to inclusion-exclusion by computing counts for individual divisors and their LCM for intersections\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)"
  },
  "cmath_2129": {
    "hint": "## counting method\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n\n## identity\n- concept: Multinomial Coefficient\n  description: A formula used to calculate the number of distinct permutations of a multiset (a set with repeated elements), given by n! / (n1! * n2! * ... * nk!).\n  parameters:\n    - total_count (type: integer): The total number of items (n).\n    - group_counts (type: list of integers): The counts of each identical group (n1, n2, ...).\n  cues:\n    - distinct permutations of a multiset or items with repeated elements\n  implementation:\n    - COMPUTE total_permutations using multinomial coefficient for all items combined\n\n## number theory tool\n- concept: GCD Computation\n  description: Calculating the greatest common divisor of two integers to analyze their divisibility relationship.\n  parameters:\n    - a (type: int): The first integer.\n    - b (type: int): The second integer.\n  cues:\n    - Problem involves common factors, simplification, or divisibility\n    - Explicit mention of gcd or greatest common divisor\n    - reducing fractions to irreducible form\n    - analyzing divisibility relationship\n    - Need to find the common divisor of multiple generated values\n    - Determining the greatest integer satisfying multiple divisibility constraints\n  implementation:\n    - Compute `g = gcd(m, 100)`\n    - Used to reduce probability fraction to irreducible form m/n.\n    - Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)\n\n## technique\n- concept: Probability as Ratio of Counts\n  description: Calculating the probability of an event in a uniform sample space by dividing the count of favorable outcomes by the count of total possible outcomes.\n  parameters:\n    - favorable_count (type: integer): The number of outcomes satisfying the specific condition.\n    - total_count (type: integer): The total number of possible outcomes in the sample space.\n  cues:\n    - problem asks for probability of an event, arrangement, or configuration\n    - discrete uniform sample space implied\n    - ratio of favorable to total outcomes\n  implementation:\n    - DERIVE probability = favorable_outcomes / total_outcomes\n    - SIMPLIFY probability to lowest terms m/n"
  },
  "cmath_2131": {
    "hint": "## counting method\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n\n## technique\n- concept: Linear Recurrence Counting\n  description: Solving counting problems by defining a sequence where each term depends on previous terms based on how valid configurations can be extended.\n  parameters:\n    - state_definition (type: string): Definition of what the sequence term dp[i] represents.\n    - base_cases (type: list): Initial values for the sequence.\n    - transition_rule (type: equation): The recurrence relation expressing dp[i] in terms of previous terms.\n  cues:\n    - counting valid sequences of length n with local constraints where solutions can be built from smaller subproblems\n  implementation:\n    - Define dp[i] as the count of valid configurations of length i, establish base cases, and derive a transition rule based on how valid configurations can be extended (e.g., dp[i] = dp[i-1] + dp[i-2] for appending '0' or '01')."
  },
  "cmath_2132": {
    "hint": "## algorithmic pattern\n- concept: Iterative Accumulation\n  description: Accumulating a result by iterating through a sequence of values and updating a running total\n  parameters:\n    - sequence (type: list): The collection of values to iterate over.\n    - accumulator (type: variable): The variable storing the running sum or product\n    - start (type: integer): Starting value of the loop counter\n    - end (type: integer): Ending value of the loop counter\n    - update_rule (type: function): The function applied to the current element to update the sum\n    - operation (type: function): The transformation applied to each element before accumulation.\n  cues:\n    - Problem asks for an aggregate value (sum, product, count, digit sums) derived from a sequence, range, or enumerated items.\n    - Solution involves a loop iterating through a collection (list, range, or components like prime factors) where a running total or product variable is updated in each iteration.\n    - Aggregating results from multiple independent choices or cases (e.g., combinatorial products, inclusion-exclusion terms).\n    - Building a frequency map, histogram, or global metric by sequentially processing input data.\n  implementation:\n    - Initialize an accumulator variable to the identity value (0 for sums, 1 for products).\n    - Iterate through the sequence (range of integers, list of items, or prime factors).\n    - In each iteration, compute the contribution based on the current element and update the accumulator using the appropriate operation (addition, multiplication, modular arithmetic).\n    - If applicable, apply conditions before updating (e.g., only add if a value is valid/integer).\n    - Return the final accumulated value after the loop completes.\n- concept: Constructive Enumeration\n  description: Generates valid instances by composing fundamental building blocks (e.g., primes) according to structural rules instead of brute-force checking.\n  parameters:\n    - primitives (type: list): Fundamental elements to build from (e.g., list of primes)\n    - construction_rules (type: list): Mathematical forms to apply to primitives (e.g., p^3, p*q)\n  cues:\n    - Search space consists of discrete structural configurations (e.g., partitions, subsets) or sequences rather than a numeric range, requiring generation via structural rules or primitives.\n    - Objective is to find an optimal value (min/max) or smallest k numbers with a property among valid configurations.\n  implementation:\n    - Generate candidates by composing primitives (e.g., primes) or iterating structural configurations (e.g., partitions, subsets, recurrence sequences).\n    - Iterate through generated candidates to compute derived values and identify the optimal result.\n\n## counting method\n- concept: Complementary Counting\n  description: Determining the count of elements satisfying a property by subtracting the count of elements that do not satisfy it from the total count.\n  parameters:\n    - total (type: integer): The total number of possibilities including invalid cases.\n    - excluded (type: integer): The number of invalid or unwanted possibilities to subtract.\n    - total_count (type: integer): The total number of elements in the universal set.\n    - complement_count (type: integer): The number of elements satisfying the negation of the target condition.\n  cues:\n    - Problem asks for \"at least one\", \"non-empty\", or \"not all\", or involves phrases like \"none\", \"never\", or \"all distinct\".\n    - Direct counting involves complex casework, but counting the complement is simpler.\n    - Total set size is easily determined.\n  implementation:\n    - Calculate result by subtracting the complement count from the total count.\n    - Subtract 1 from total_combinations to remove the empty selection case.\n\n## formula\n- concept: Range Cardinality\n  description: Computes the number of integers in an inclusive interval [min, max] using the formula max - min + 1.\n  parameters:\n    - range_min (type: integer): The lower bound of the inclusive range.\n    - range_max (type: integer): The upper bound of the inclusive range.\n  cues:\n    - Problem asks for the count of integers within a specific inclusive interval.\n    - Bounds are given as explicit integers (often non-negative).\n    - Counting valid parameter values within a range.\n  implementation:\n    - Compute the count of integers in an inclusive range [min, max] using the formula `max - min + 1` (simplifies to `max + 1` if min is 0).\n    - Use this calculation to establish the universe size for complementary counting."
  },
  "cmath_2144": {
    "hint": "## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n- concept: Constraint-Ordered Counting\n  description: A strategy for constructive counting where variables are assigned values in descending order of constraint strictness. This ensures the number of available choices for subsequent variables remains constant regardless of specific previous choices, avoiding case analysis.\n  cues:\n    - Multiple overlapping constraints creating dependencies (e.g., distinctness, parity, non-zero, strictly increasing)\n    - Need to avoid case splitting by leveraging fixed order for combination logic\n  implementation:\n    - Assign variables in descending order of constraint strictness (e.g., parity, non-zero) to ensure constant option counts, enabling calculation via combinations from the available pool without case analysis\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks"
  },
  "cmath_2175": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Iterative Accumulation\n  description: Accumulating a result by iterating through a sequence of values and updating a running total\n  parameters:\n    - sequence (type: list): The collection of values to iterate over.\n    - accumulator (type: variable): The variable storing the running sum or product\n    - start (type: integer): Starting value of the loop counter\n    - end (type: integer): Ending value of the loop counter\n    - update_rule (type: function): The function applied to the current element to update the sum\n    - operation (type: function): The transformation applied to each element before accumulation.\n  cues:\n    - Problem asks for an aggregate value (sum, product, count, digit sums) derived from a sequence, range, or enumerated items.\n    - Solution involves a loop iterating through a collection (list, range, or components like prime factors) where a running total or product variable is updated in each iteration.\n    - Aggregating results from multiple independent choices or cases (e.g., combinatorial products, inclusion-exclusion terms).\n    - Building a frequency map, histogram, or global metric by sequentially processing input data.\n  implementation:\n    - Initialize an accumulator variable to the identity value (0 for sums, 1 for products).\n    - Iterate through the sequence (range of integers, list of items, or prime factors).\n    - In each iteration, compute the contribution based on the current element and update the accumulator using the appropriate operation (addition, multiplication, modular arithmetic).\n    - If applicable, apply conditions before updating (e.g., only add if a value is valid/integer).\n    - Return the final accumulated value after the loop completes.\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n\n## technique\n- concept: Gap Method\n  description: A combinatorial technique for counting arrangements where specific items must not be adjacent. It involves first arranging the unrestricted items, identifying the available \"gaps\" (including ends) between them, and then choosing distinct gaps to place the restricted items.\n  parameters:\n    - unrestricted_items (type: list): The set of items that have no adjacency constraints.\n    - restricted_items (type: list): The set of items that must not be adjacent to each other.\n  cues:\n    - non-adjacent items or no two items together\n    - arrangement with separation constraints\n  implementation:\n    - ARRANGE non_restricted_items and compute their distinct permutations\n    - GENERATE gaps from non_restricted_arrangement equal to (count + 1)\n    - SELECT positions for restricted_items from gaps using combinations to ensure non-adjacency\n    - COMPUTE valid_permutations = non_restricted_permutations * selection_ways\n- concept: Fixed Element Counting\n  description: Counting subsets by fixing certain elements as required inclusions or exclusions, then choosing remaining elements from the reduced pool\n  parameters:\n    - total_elements (type: integer): Total number of elements available (n)\n    - subset_size (type: integer): Target size of the subset (k)\n    - fixed_inclusions (type: integer): Number of elements that must be included\n    - fixed_exclusions (type: integer): Number of elements that must be excluded\n  cues:\n    - Constraints specify certain elements must be included or excluded from a subset\n    - Problem reduces to choosing remaining elements from a reduced pool after fixing specific inclusions/exclusions\n    - Counting formula involves C(n - fixed_count, k - fixed_inclusions)\n  implementation:\n    - Handle fixed inclusions by ensuring required elements are present (reducing target size k)\n    - Handle fixed exclusions by removing forbidden elements from the available pool (reducing total n)\n    - Calculate result as Combinations(n - excluded_count, k - included_count)"
  },
  "cmath_2180": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Iterative Accumulation\n  description: Accumulating a result by iterating through a sequence of values and updating a running total\n  parameters:\n    - sequence (type: list): The collection of values to iterate over.\n    - accumulator (type: variable): The variable storing the running sum or product\n    - start (type: integer): Starting value of the loop counter\n    - end (type: integer): Ending value of the loop counter\n    - update_rule (type: function): The function applied to the current element to update the sum\n    - operation (type: function): The transformation applied to each element before accumulation.\n  cues:\n    - Problem asks for an aggregate value (sum, product, count, digit sums) derived from a sequence, range, or enumerated items.\n    - Solution involves a loop iterating through a collection (list, range, or components like prime factors) where a running total or product variable is updated in each iteration.\n    - Aggregating results from multiple independent choices or cases (e.g., combinatorial products, inclusion-exclusion terms).\n    - Building a frequency map, histogram, or global metric by sequentially processing input data.\n  implementation:\n    - Initialize an accumulator variable to the identity value (0 for sums, 1 for products).\n    - Iterate through the sequence (range of integers, list of items, or prime factors).\n    - In each iteration, compute the contribution based on the current element and update the accumulator using the appropriate operation (addition, multiplication, modular arithmetic).\n    - If applicable, apply conditions before updating (e.g., only add if a value is valid/integer).\n    - Return the final accumulated value after the loop completes.\n- concept: interval_intersection_logic\n  description: Computes the overlapping range between two closed intervals [a, b] and [c, d].\n  parameters:\n    - interval1 (type: tuple (start, end)): First range boundaries\n    - interval2 (type: tuple (start, end)): Second range boundaries\n  cues:\n    - Multiple independent constraints define valid ranges of integers, requiring values that satisfy all simultaneously.\n  implementation:\n    - Calculate intersection bounds as the MAX of lower bounds and MIN of upper bounds.\n    - Check validity with intersection_start <= intersection_end.\n\n## calculation method\n- concept: Summation of Distinct Values\n  description: Calculating the arithmetic sum of all unique values in a collection.\n  parameters:\n    - distinct_values (type: set): The set of unique numbers to sum\n  cues:\n    - Problem asks for the sum of all distinct/unique valid solutions or outcomes.\n    - Collected numbers are distinct by virtue of the search process.\n  implementation:\n    - Compute the final answer as the arithmetic sum of all elements in the collected set of valid values, typically by iterating and accumulating into a total sum variable.\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n\n## formula\n- concept: Range Cardinality\n  description: Computes the number of integers in an inclusive interval [min, max] using the formula max - min + 1.\n  parameters:\n    - range_min (type: integer): The lower bound of the inclusive range.\n    - range_max (type: integer): The upper bound of the inclusive range.\n  cues:\n    - Problem asks for the count of integers within a specific inclusive interval.\n    - Bounds are given as explicit integers (often non-negative).\n    - Counting valid parameter values within a range.\n  implementation:\n    - Compute the count of integers in an inclusive range [min, max] using the formula `max - min + 1` (simplifies to `max + 1` if min is 0).\n    - Use this calculation to establish the universe size for complementary counting."
  },
  "cmath_2183": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## counting method\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n\n## technique\n- concept: Graph Modeling\n  description: Translating a problem involving entities and pairwise relationships into a graph structure (vertices and edges) to leverage graph theoretic tools.\n  parameters:\n    - entities (type: set): The objects to be represented as vertices.\n    - relationships (type: set of pairs): The interactions to be represented as edges.\n  cues:\n    - handshakes\n    - network structure or pairwise relationships between entities\n  implementation:\n    - Model entities as Vertices V and relationships as Edges in Graph G"
  },
  "cmath_2195": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## counting method\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n- concept: Complementary Counting\n  description: Determining the count of elements satisfying a property by subtracting the count of elements that do not satisfy it from the total count.\n  parameters:\n    - total (type: integer): The total number of possibilities including invalid cases.\n    - excluded (type: integer): The number of invalid or unwanted possibilities to subtract.\n    - total_count (type: integer): The total number of elements in the universal set.\n    - complement_count (type: integer): The number of elements satisfying the negation of the target condition.\n  cues:\n    - Problem asks for \"at least one\", \"non-empty\", or \"not all\", or involves phrases like \"none\", \"never\", or \"all distinct\".\n    - Direct counting involves complex casework, but counting the complement is simpler.\n    - Total set size is easily determined.\n  implementation:\n    - Calculate result by subtracting the complement count from the total count.\n    - Subtract 1 from total_combinations to remove the empty selection case.\n\n## technique\n- concept: Linear Recurrence Counting\n  description: Solving counting problems by defining a sequence where each term depends on previous terms based on how valid configurations can be extended.\n  parameters:\n    - state_definition (type: string): Definition of what the sequence term dp[i] represents.\n    - base_cases (type: list): Initial values for the sequence.\n    - transition_rule (type: equation): The recurrence relation expressing dp[i] in terms of previous terms.\n  cues:\n    - counting valid sequences of length n with local constraints where solutions can be built from smaller subproblems\n  implementation:\n    - Define dp[i] as the count of valid configurations of length i, establish base cases, and derive a transition rule based on how valid configurations can be extended (e.g., dp[i] = dp[i-1] + dp[i-2] for appending '0' or '01')."
  },
  "cmath_2238": {
    "hint": "## algebraic manipulation\n- concept: Equating Coefficients\n  description: Method for solving parameters in an identity by matching the coefficients of corresponding powers of the variable on both sides.\n  cues:\n    - identity in a variable holding for all valid values with unknown parameters in linear or polynomial expressions\n  implementation:\n    - Derive relationships between parameters by matching coefficients of corresponding powers and constant terms on both sides of the identity\n\n## counting method\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n\n## identity\n- concept: Multinomial Coefficient\n  description: A formula used to calculate the number of distinct permutations of a multiset (a set with repeated elements), given by n! / (n1! * n2! * ... * nk!).\n  parameters:\n    - total_count (type: integer): The total number of items (n).\n    - group_counts (type: list of integers): The counts of each identical group (n1, n2, ...).\n  cues:\n    - distinct permutations of a multiset or items with repeated elements\n  implementation:\n    - COMPUTE total_permutations using multinomial coefficient for all items combined"
  },
  "cmath_2271": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Iterative Accumulation\n  description: Accumulating a result by iterating through a sequence of values and updating a running total\n  parameters:\n    - sequence (type: list): The collection of values to iterate over.\n    - accumulator (type: variable): The variable storing the running sum or product\n    - start (type: integer): Starting value of the loop counter\n    - end (type: integer): Ending value of the loop counter\n    - update_rule (type: function): The function applied to the current element to update the sum\n    - operation (type: function): The transformation applied to each element before accumulation.\n  cues:\n    - Problem asks for an aggregate value (sum, product, count, digit sums) derived from a sequence, range, or enumerated items.\n    - Solution involves a loop iterating through a collection (list, range, or components like prime factors) where a running total or product variable is updated in each iteration.\n    - Aggregating results from multiple independent choices or cases (e.g., combinatorial products, inclusion-exclusion terms).\n    - Building a frequency map, histogram, or global metric by sequentially processing input data.\n  implementation:\n    - Initialize an accumulator variable to the identity value (0 for sums, 1 for products).\n    - Iterate through the sequence (range of integers, list of items, or prime factors).\n    - In each iteration, compute the contribution based on the current element and update the accumulator using the appropriate operation (addition, multiplication, modular arithmetic).\n    - If applicable, apply conditions before updating (e.g., only add if a value is valid/integer).\n    - Return the final accumulated value after the loop completes.\n- concept: Constructive Enumeration\n  description: Generates valid instances by composing fundamental building blocks (e.g., primes) according to structural rules instead of brute-force checking.\n  parameters:\n    - primitives (type: list): Fundamental elements to build from (e.g., list of primes)\n    - construction_rules (type: list): Mathematical forms to apply to primitives (e.g., p^3, p*q)\n  cues:\n    - Search space consists of discrete structural configurations (e.g., partitions, subsets) or sequences rather than a numeric range, requiring generation via structural rules or primitives.\n    - Objective is to find an optimal value (min/max) or smallest k numbers with a property among valid configurations.\n  implementation:\n    - Generate candidates by composing primitives (e.g., primes) or iterating structural configurations (e.g., partitions, subsets, recurrence sequences).\n    - Iterate through generated candidates to compute derived values and identify the optimal result.\n\n## counting method\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n\n## technique\n- concept: Set Partition Counting\n  description: Modeling distribution problems where items are distinguishable and bins are indistinguishable as set partition problems.\n  cues:\n    - distinct elements\n    - identical containers\n  implementation:\n    - The initial conditional check identifies this scenario to apply partition counting formulas"
  },
  "cmath_2305": {
    "hint": "## algorithmic pattern\n- concept: Set Deduplication\n  description: Using a set data structure to store results of a transformation to automatically filter duplicates, useful for identifying distinct outcomes.\n  parameters:\n    - values (type: iterable): The sequence of values to deduplicate\n  cues:\n    - Goal is to count the number of *unique* or *distinct* outcomes.\n    - Multiple different inputs may produce the same output value.\n  implementation:\n    - Initialize an empty set to store unique outcomes.\n    - Compute the value for each input and insert into the set to automatically filter duplicates.\n    - Return the cardinality of the set as the final answer.\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n\n## formula\n- concept: Pairwise Combination Formula\n  description: Calculates the number of unique pairs that can be formed from a set of n elements, given by the formula n(n-1)/2.\n  parameters:\n    - n (type: integer): The size of the set from which pairs are formed.\n  cues:\n    - Round-robin tournament structures\n    - Handshake problems\n    - Counting edges in a complete graph\n    - Problems involving interactions between all distinct pairs of items\n    - Choosing 2 distinct items from a set\n    - Order irrelevant due to sorting constraint\n    - Product of geometric sequence terms\n    - Sum of arithmetic progression in exponent\n  implementation:\n    - Calculated `total_games` as `num_teams * (num_teams - 1) / 2` to determine the total number of matches in the tournament.\n    - Computing ways_to_choose_prefix using Binomial_Coefficient(last_digit - 1, 2)\n    - Computed exponent of ratio r as n_terms * (n_terms - 1) / 2\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks"
  },
  "cmath_2340": {
    "hint": "## counting method\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication."
  },
  "cmath_2364": {
    "hint": "## algorithmic pattern\n- concept: Set Deduplication\n  description: Using a set data structure to store results of a transformation to automatically filter duplicates, useful for identifying distinct outcomes.\n  parameters:\n    - values (type: iterable): The sequence of values to deduplicate\n  cues:\n    - Goal is to count the number of *unique* or *distinct* outcomes.\n    - Multiple different inputs may produce the same output value.\n  implementation:\n    - Initialize an empty set to store unique outcomes.\n    - Compute the value for each input and insert into the set to automatically filter duplicates.\n    - Return the cardinality of the set as the final answer.\n- concept: Constructive Enumeration\n  description: Generates valid instances by composing fundamental building blocks (e.g., primes) according to structural rules instead of brute-force checking.\n  parameters:\n    - primitives (type: list): Fundamental elements to build from (e.g., list of primes)\n    - construction_rules (type: list): Mathematical forms to apply to primitives (e.g., p^3, p*q)\n  cues:\n    - Search space consists of discrete structural configurations (e.g., partitions, subsets) or sequences rather than a numeric range, requiring generation via structural rules or primitives.\n    - Objective is to find an optimal value (min/max) or smallest k numbers with a property among valid configurations.\n  implementation:\n    - Generate candidates by composing primitives (e.g., primes) or iterating structural configurations (e.g., partitions, subsets, recurrence sequences).\n    - Iterate through generated candidates to compute derived values and identify the optimal result.\n\n## counting method\n- concept: Complementary Counting\n  description: Determining the count of elements satisfying a property by subtracting the count of elements that do not satisfy it from the total count.\n  parameters:\n    - total (type: integer): The total number of possibilities including invalid cases.\n    - excluded (type: integer): The number of invalid or unwanted possibilities to subtract.\n    - total_count (type: integer): The total number of elements in the universal set.\n    - complement_count (type: integer): The number of elements satisfying the negation of the target condition.\n  cues:\n    - Problem asks for \"at least one\", \"non-empty\", or \"not all\", or involves phrases like \"none\", \"never\", or \"all distinct\".\n    - Direct counting involves complex casework, but counting the complement is simpler.\n    - Total set size is easily determined.\n  implementation:\n    - Calculate result by subtracting the complement count from the total count.\n    - Subtract 1 from total_combinations to remove the empty selection case.\n- concept: Positional Digit Counting\n  description: Counting integers satisfying digit-level constraints by multiplying the number of valid choices for each digit position (Hundreds, Tens, Units, etc.).\n  parameters:\n    - positions (type: list): The digit positions to fill (e.g., [100, 10, 1]).\n    - constraints (type: list): Rules restricting valid digits at each position (e.g., distinctness, range bounds).\n  cues:\n    - Counting integers with fixed digit length or base b representation (e.g., Hundreds, Tens, Units)\n    - Digit-level constraints (parity, leading zero, specific values) or dependencies between positions (e.g., distinctness)\n  implementation:\n    - Decompose the number into positional components (e.g., Hundreds, Tens, Units or base b positions)\n    - Calculate valid digit choices for each position, adjusting for dependencies like distinctness based on previous selections, and apply the multiplication principle to compute total count\n\n## technique\n- concept: Fixed Element Counting\n  description: Counting subsets by fixing certain elements as required inclusions or exclusions, then choosing remaining elements from the reduced pool\n  parameters:\n    - total_elements (type: integer): Total number of elements available (n)\n    - subset_size (type: integer): Target size of the subset (k)\n    - fixed_inclusions (type: integer): Number of elements that must be included\n    - fixed_exclusions (type: integer): Number of elements that must be excluded\n  cues:\n    - Constraints specify certain elements must be included or excluded from a subset\n    - Problem reduces to choosing remaining elements from a reduced pool after fixing specific inclusions/exclusions\n    - Counting formula involves C(n - fixed_count, k - fixed_inclusions)\n  implementation:\n    - Handle fixed inclusions by ensuring required elements are present (reducing target size k)\n    - Handle fixed exclusions by removing forbidden elements from the available pool (reducing total n)\n    - Calculate result as Combinations(n - excluded_count, k - included_count)"
  },
  "cmath_2373": {
    "hint": "## technique\n- concept: Set Partition Counting\n  description: Modeling distribution problems where items are distinguishable and bins are indistinguishable as set partition problems.\n  cues:\n    - distinct elements\n    - identical containers\n  implementation:\n    - The initial conditional check identifies this scenario to apply partition counting formulas\n\n## theorem\n- concept: Bell Number\n  description: The total number of partitions of a set of n labeled elements into non-empty unlabeled subsets.\n  parameters:\n    - n (type: integer): The number of distinct elements to partition\n  cues:\n    - distinct elements\n    - identical containers\n    - unlimited container capacity or count\n  implementation:\n    - Returned directly when the number of containers k is greater than or equal to the number of elements n\n- concept: Stirling Numbers of the Second Kind\n  description: Counts the number of ways to partition a set of n labeled elements into exactly k non-empty unlabeled subsets.\n  parameters:\n    - n (type: integer): The number of distinct elements\n    - k (type: integer): The exact number of non-empty subsets\n  cues:\n    - distinct elements\n    - identical containers\n    - constraint on number of non-empty subsets\n  implementation:\n    - Summed from i=1 to k to count partitions with at most k subsets when containers are limited"
  },
  "cmath_2444": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## counting method\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n- concept: Positional Digit Counting\n  description: Counting integers satisfying digit-level constraints by multiplying the number of valid choices for each digit position (Hundreds, Tens, Units, etc.).\n  parameters:\n    - positions (type: list): The digit positions to fill (e.g., [100, 10, 1]).\n    - constraints (type: list): Rules restricting valid digits at each position (e.g., distinctness, range bounds).\n  cues:\n    - Counting integers with fixed digit length or base b representation (e.g., Hundreds, Tens, Units)\n    - Digit-level constraints (parity, leading zero, specific values) or dependencies between positions (e.g., distinctness)\n  implementation:\n    - Decompose the number into positional components (e.g., Hundreds, Tens, Units or base b positions)\n    - Calculate valid digit choices for each position, adjusting for dependencies like distinctness based on previous selections, and apply the multiplication principle to compute total count"
  },
  "cmath_2460": {
    "hint": "## technique\n- concept: Set Partition Counting\n  description: Modeling distribution problems where items are distinguishable and bins are indistinguishable as set partition problems.\n  cues:\n    - distinct elements\n    - identical containers\n  implementation:\n    - The initial conditional check identifies this scenario to apply partition counting formulas\n\n## theorem\n- concept: Stirling Numbers of the Second Kind\n  description: Counts the number of ways to partition a set of n labeled elements into exactly k non-empty unlabeled subsets.\n  parameters:\n    - n (type: integer): The number of distinct elements\n    - k (type: integer): The exact number of non-empty subsets\n  cues:\n    - distinct elements\n    - identical containers\n    - constraint on number of non-empty subsets\n  implementation:\n    - Summed from i=1 to k to count partitions with at most k subsets when containers are limited"
  },
  "cmath_2481": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Constructive Enumeration\n  description: Generates valid instances by composing fundamental building blocks (e.g., primes) according to structural rules instead of brute-force checking.\n  parameters:\n    - primitives (type: list): Fundamental elements to build from (e.g., list of primes)\n    - construction_rules (type: list): Mathematical forms to apply to primitives (e.g., p^3, p*q)\n  cues:\n    - Search space consists of discrete structural configurations (e.g., partitions, subsets) or sequences rather than a numeric range, requiring generation via structural rules or primitives.\n    - Objective is to find an optimal value (min/max) or smallest k numbers with a property among valid configurations.\n  implementation:\n    - Generate candidates by composing primitives (e.g., primes) or iterating structural configurations (e.g., partitions, subsets, recurrence sequences).\n    - Iterate through generated candidates to compute derived values and identify the optimal result.\n\n## counting method\n- concept: Constraint-Ordered Counting\n  description: A strategy for constructive counting where variables are assigned values in descending order of constraint strictness. This ensures the number of available choices for subsequent variables remains constant regardless of specific previous choices, avoiding case analysis.\n  cues:\n    - Multiple overlapping constraints creating dependencies (e.g., distinctness, parity, non-zero, strictly increasing)\n    - Need to avoid case splitting by leveraging fixed order for combination logic\n  implementation:\n    - Assign variables in descending order of constraint strictness (e.g., parity, non-zero) to ensure constant option counts, enabling calculation via combinations from the available pool without case analysis"
  },
  "cmath_2490": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Set Deduplication\n  description: Using a set data structure to store results of a transformation to automatically filter duplicates, useful for identifying distinct outcomes.\n  parameters:\n    - values (type: iterable): The sequence of values to deduplicate\n  cues:\n    - Goal is to count the number of *unique* or *distinct* outcomes.\n    - Multiple different inputs may produce the same output value.\n  implementation:\n    - Initialize an empty set to store unique outcomes.\n    - Compute the value for each input and insert into the set to automatically filter duplicates.\n    - Return the cardinality of the set as the final answer.\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication."
  },
  "cmath_4706": {
    "hint": "## algorithm\n- concept: Modular Exponentiation\n  description: Efficiently computes (base^exponent) % modulus using binary exponentiation (square-and-multiply).\n  parameters:\n    - base (type: integer): The base of the power\n    - exponent (type: integer): The reduced exponent\n    - modulus (type: integer): The modulus for the operation\n  cues:\n    - Computing a power modulo m\n    - Base and exponent may be large\n    - Exponent is manageable after reduction\n  implementation:\n    - Compute base^exponent % modulus as the final step to obtain the result\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: Modular Power Cycle\n  description: Exploits the periodic sequence of powers of an integer modulo m to reduce large exponents by computing the exponent modulo the cycle length.\n  parameters:\n    - base (type: integer): The base of the power (e.g., the prime p).\n    - modulus (type: integer): The modulus for the cycle (e.g., 10 for ones digit).\n    - exponent (type: integer): The large exponent to be reduced.\n  cues:\n    - Computing last digits or residues of large powers (including power towers)\n    - Detecting periodicity in sequences of powers modulo m\n  implementation:\n    - Determine the cycle length of base^k mod m, then reduce the exponent modulo this length (mapping 0 to the cycle length).\n\n## theorem\n- concept: Euler's Totient Theorem\n  description: States that if gcd(a, n) = 1, then a^phi(n) \u2261 1 (mod n), allowing exponent reduction modulo phi(n).\n  parameters:\n    - base (type: integer): The integer base 'a' which must be coprime to the modulus\n    - modulus (type: integer): The modulus 'n' for the congruence\n  cues:\n    - Computing a^b mod n where b is large\n    - Base and modulus are coprime (especially if modulus is prime)\n  implementation:\n    - Reduce exponent modulo phi(n) using a^phi(n) \u2261 1 (mod n) (use n-1 if modulus is prime)"
  },
  "cmath_4730": {
    "hint": "## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: GCD Computation\n  description: Calculating the greatest common divisor of two integers to analyze their divisibility relationship.\n  parameters:\n    - a (type: int): The first integer.\n    - b (type: int): The second integer.\n  cues:\n    - Problem involves common factors, simplification, or divisibility\n    - Explicit mention of gcd or greatest common divisor\n    - reducing fractions to irreducible form\n    - analyzing divisibility relationship\n    - Need to find the common divisor of multiple generated values\n    - Determining the greatest integer satisfying multiple divisibility constraints\n  implementation:\n    - Compute `g = gcd(m, 100)`\n    - Used to reduce probability fraction to irreducible form m/n.\n    - Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)\n\n## theorem\n- concept: Difference of Squares Characterization\n  description: An integer n can be expressed as the difference of two squares (a^2 - b^2) if and only if n is not congruent to 2 modulo 4. This arises because factors (a+b) and (a-b) must have the same parity.\n  parameters:\n    - n (type: integer): The integer to test for representability as a difference of squares.\n  cues:\n    - Problem involves expressing numbers as a^2 - b^2.\n    - Constraints on parity or modulo 4 appear in the problem statement or derivation.\n    - Need to filter integers based on arithmetic properties rather than brute force.\n  implementation:\n    - Use the identity n = (a+b)(a-b) to deduce that factors must share parity (both odd or both even).\n    - Conclude that n cannot be congruent to 2 (mod 4), as this is the only case where factors would have differing parity.\n    - Filter out integers satisfying k \u2261 2 (mod 4) to identify valid candidates."
  },
  "cmath_4744": {
    "hint": "## algebraic manipulation\n- concept: Base-b Polynomial Representation\n  description: Interpreting a number represented by digits in an unknown base b as a polynomial expression in b, where each digit is a coefficient corresponding to a power of b.\n  parameters:\n    - digits (type: list of integers): The sequence of digits d_n...d_0 representing the number.\n    - base_variable (type: symbol): The variable representing the unknown base (e.g., b).\n  cues:\n    - Problem involves numbers represented by digits in unspecified, variable, or multiple bases using positional notation (e.g., $121_c$ or equations mixing bases).\n    - Problem involves sums of distinct powers of 3 (equivalent to base-3 representation with digits 0 and 1).\n  implementation:\n    - Convert numbers from base-b representation to a polynomial in b (e.g., digits d_n...d_0 map to sum(d_i * b^i)); for sums of distinct powers, treat as base-b polynomials with binary coefficients.\n\n## calculation method\n- concept: Summation of Distinct Values\n  description: Calculating the arithmetic sum of all unique values in a collection.\n  parameters:\n    - distinct_values (type: set): The set of unique numbers to sum\n  cues:\n    - Problem asks for the sum of all distinct/unique valid solutions or outcomes.\n    - Collected numbers are distinct by virtue of the search process.\n  implementation:\n    - Compute the final answer as the arithmetic sum of all elements in the collected set of valid values, typically by iterating and accumulating into a total sum variable.\n\n## formula\n- concept: base_digit_range_formula\n  description: Determines the minimum and maximum base-10 integer values representable by a number with a specific count of digits in a given base.\n  parameters:\n    - num_digits (type: integer): The number of digits in the representation\n    - base (type: integer): The base of the number system\n  cues:\n    - Problem specifies numbers with a fixed number of digits in a specific base (e.g., 3-digit base 5)\n    - Need to determine the range (smallest/largest) of base-10 integer values these representations correspond to\n  implementation:\n    - Used in `get_base_range` to compute `min_val` as `base^(num_digits - 1)` and `max_val` as `base^num_digits - 1` for varying digit counts and bases.\n- concept: Range Cardinality\n  description: Computes the number of integers in an inclusive interval [min, max] using the formula max - min + 1.\n  parameters:\n    - range_min (type: integer): The lower bound of the inclusive range.\n    - range_max (type: integer): The upper bound of the inclusive range.\n  cues:\n    - Problem asks for the count of integers within a specific inclusive interval.\n    - Bounds are given as explicit integers (often non-negative).\n    - Counting valid parameter values within a range.\n  implementation:\n    - Compute the count of integers in an inclusive range [min, max] using the formula `max - min + 1` (simplifies to `max + 1` if min is 0).\n    - Use this calculation to establish the universe size for complementary counting.\n\n## identity\n- concept: arithmetic_progression_mean\n  description: The mean of a finite set of consecutive integers is equal to the average of the first and last terms.\n  parameters:\n    - start (type: integer): The first integer in the sequence\n    - end (type: integer): The last integer in the sequence\n  cues:\n    - Problem asks for the average, mean, or sum of a set of integers\n    - The integers form a consecutive sequence or arithmetic progression\n  implementation:\n    - Compute the average as (first_term + last_term) / 2\n    - Avoid explicit summation or counting of elements\n\n## technique\n- concept: Digit Decomposition\n  description: Extracting individual digits from an integer in a given base to analyze their values or relationships.\n  parameters:\n    - number (type: integer): The integer to be decomposed into digits\n    - base (type: integer): The numerical base for decomposition (default 10)\n  cues:\n    - Problem involves extracting, analyzing, or performing arithmetic on individual digits, bits, or positional values in a specific base (e.g., decimal, binary, digit_sum, ith bit)\n    - References to decimal/fractional expansion or positional representation formulas (e.g., n = \u03a3(b_i * 2^i))\n  implementation:\n    - Decompose the number (integer or rational) into a sequence of digits or bits in the target base (e.g., via `decimal_digits(n)` or bit extraction)\n    - Treat the extracted digits for analysis or as coefficients in a summation"
  },
  "cmath_4758": {
    "hint": "## algorithmic pattern\n- concept: Reverse Search for Maximum\n  description: Iterating from the theoretical upper bound downwards to find the largest value satisfying a predicate, allowing early termination.\n  parameters:\n    - start_val (type: integer): The maximum possible value to start searching from\n    - condition (type: predicate function): The boolean condition that the value must satisfy\n  cues:\n    - Objective is to find the largest discrete value satisfying a condition\n    - Search space consists of bounded, ordered discrete candidates\n    - Existence of a calculable theoretical upper bound\n    - Validity check is computationally feasible\n  implementation:\n    - Compute starting value as floor(upper_bound / divisor) to establish search start\n    - Iterate candidates from maximum possible value downwards\n    - Return immediately upon finding the first valid candidate\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: GCD Computation\n  description: Calculating the greatest common divisor of two integers to analyze their divisibility relationship.\n  parameters:\n    - a (type: int): The first integer.\n    - b (type: int): The second integer.\n  cues:\n    - Problem involves common factors, simplification, or divisibility\n    - Explicit mention of gcd or greatest common divisor\n    - reducing fractions to irreducible form\n    - analyzing divisibility relationship\n    - Need to find the common divisor of multiple generated values\n    - Determining the greatest integer satisfying multiple divisibility constraints\n  implementation:\n    - Compute `g = gcd(m, 100)`\n    - Used to reduce probability fraction to irreducible form m/n.\n    - Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)\n- concept: Divisibility Substitution\n  description: Replacing variables with parameterized forms based on known divisibility constraints (e.g., if x must be divisible by k, set x = k\u00b7t for integer t)\n  parameters:\n    - variable (type: symbol): The original variable subject to divisibility constraint\n    - divisor (type: integer): The known divisor that the variable must be a multiple of\n    - parameter (type: symbol): The new integer parameter representing the quotient\n  cues:\n    - Variable constrained by divisibility, congruences, or multiple conditions (e.g., multiple of k or mk + r)\n    - Problem involves partitioning or grouping with fixed sizes\n    - Need to reduce search space using structural constraints or density reduction\n    - Counting divisors subject to a multiple constraint (e.g., divisors of N that are multiples of k)\n    - Problem involves ratios, proportional holdings, or a common scaling factor\n  implementation:\n    - Substitute variables with divisor multiples or congruence forms (e.g., M = 8m or r = a + m\u00b7k) to simplify equations and reduce coefficients\n    - Substitute divisor d = k\u00b7m to transform 'd divides N and k divides d' into counting divisors of N/k\n    - Introduce a scaling factor k to represent proportional values (e.g., 3k, 4k, 5k) based on given ratios to facilitate equation formulation\n    - Define candidates as n * multiplier to reduce search space from limit values to limit/multiplier values\n\n## technique\n- concept: Linear Congruence Resolution\n  description: Solves a linear congruence equation ax \u2261 b (mod m) by reducing coefficients via GCD and computing the modular inverse to isolate x.\n  parameters:\n    - coeff (type: integer): The coefficient 'a' of the variable x.\n    - constant (type: integer): The constant term 'b' on the RHS.\n    - modulus (type: integer): The modulus 'm'.\n  cues:\n    - Linear congruence equation ax \u2261 b (mod m) requiring isolation of x.\n  implementation:\n    - Reduced equation by dividing coeff, constant, and modulus by g = GCD(coeff, modulus).\n    - Computed modular inverse of reduced coefficient to find the residue."
  },
  "cmath_4777": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n\n## number theory tool\n- concept: Divisor Enumeration\n  description: Computing the complete set of positive divisors for a given integer to identify candidate values satisfying divisibility conditions.\n  parameters:\n    - n (type: Integer): The integer to find divisors for\n    - target_number (type: integer): The integer whose divisors are being computed\n  cues:\n    - Problem involves divisibility constraints or checking if k divides N.\n    - Search space or conditions require finding all divisors or specific subsets (e.g., proper divisors) of a specific or derived integer.\n  implementation:\n    - Iterate from 1 to sqrt(N) to construct the set of all positive divisors of the target integer by checking divisibility.\n    - Filter divisors to exclude 1 and n if proper divisors are required.\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)"
  },
  "cmath_4780": {
    "hint": "## algorithm\n- concept: Modular Exponentiation\n  description: Efficiently computes (base^exponent) % modulus using binary exponentiation (square-and-multiply).\n  parameters:\n    - base (type: integer): The base of the power\n    - exponent (type: integer): The reduced exponent\n    - modulus (type: integer): The modulus for the operation\n  cues:\n    - Computing a power modulo m\n    - Base and exponent may be large\n    - Exponent is manageable after reduction\n  implementation:\n    - Compute base^exponent % modulus as the final step to obtain the result\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: Modular Power Cycle\n  description: Exploits the periodic sequence of powers of an integer modulo m to reduce large exponents by computing the exponent modulo the cycle length.\n  parameters:\n    - base (type: integer): The base of the power (e.g., the prime p).\n    - modulus (type: integer): The modulus for the cycle (e.g., 10 for ones digit).\n    - exponent (type: integer): The large exponent to be reduced.\n  cues:\n    - Computing last digits or residues of large powers (including power towers)\n    - Detecting periodicity in sequences of powers modulo m\n  implementation:\n    - Determine the cycle length of base^k mod m, then reduce the exponent modulo this length (mapping 0 to the cycle length).\n\n## theorem\n- concept: Euler's Totient Theorem\n  description: States that if gcd(a, n) = 1, then a^phi(n) \u2261 1 (mod n), allowing exponent reduction modulo phi(n).\n  parameters:\n    - base (type: integer): The integer base 'a' which must be coprime to the modulus\n    - modulus (type: integer): The modulus 'n' for the congruence\n  cues:\n    - Computing a^b mod n where b is large\n    - Base and modulus are coprime (especially if modulus is prime)\n  implementation:\n    - Reduce exponent modulo phi(n) using a^phi(n) \u2261 1 (mod n) (use n-1 if modulus is prime)"
  },
  "cmath_4786": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Incremental Search for Minimum\n  description: Iterating integers from a theoretical lower bound upwards to find the smallest value satisfying a predicate, allowing early termination.\n  cues:\n    - Problem asks for the \"smallest\", \"first\", or \"minimum\" integer satisfying a condition within an ordered search space starting from a known lower bound.\n  implementation:\n    - Iterate integers upwards from the theoretical lower bound, checking the condition at each step, and terminate immediately upon finding the first match to guarantee the minimum solution.\n\n## number theory tool\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: Digit Decomposition\n  description: Extracting individual digits from an integer in a given base to analyze their values or relationships.\n  parameters:\n    - number (type: integer): The integer to be decomposed into digits\n    - base (type: integer): The numerical base for decomposition (default 10)\n  cues:\n    - Problem involves extracting, analyzing, or performing arithmetic on individual digits, bits, or positional values in a specific base (e.g., decimal, binary, digit_sum, ith bit)\n    - References to decimal/fractional expansion or positional representation formulas (e.g., n = \u03a3(b_i * 2^i))\n  implementation:\n    - Decompose the number (integer or rational) into a sequence of digits or bits in the target base (e.g., via `decimal_digits(n)` or bit extraction)\n    - Treat the extracted digits for analysis or as coefficients in a summation\n\n## theorem\n- concept: Terminating Decimal Criterion\n  description: A fraction in lowest terms has a terminating decimal representation if and only if its denominator's prime factorization contains only the primes 2 and 5. Otherwise, the decimal representation is repeating.\n  cues:\n    - Questions about whether a fraction's decimal representation terminates or repeats\n    - Analysis of denominator prime factorization in fraction problems\n  implementation:\n    - Determine if a fraction has a repeating decimal by checking if the denominator (in lowest terms) has prime factors other than 2 or 5\n    - Invert the terminating criterion to count fractions with non-terminating (repeating) decimals"
  },
  "cmath_4788": {
    "hint": "## counting method\n- concept: Principle of Inclusion-Exclusion\n  description: A combinatorial technique to calculate the number of elements satisfying none of several properties by alternately adding and subtracting the sizes of intersections of subsets of properties.\n  cues:\n    - Problem involves counting objects satisfying conditions (e.g., surjectivity, derangements) where constraints are defined by the exclusion of specific properties.\n    - Solution structure involves an alternating summation with terms like (-1)^k.\n  implementation:\n    - Sum over the number of excluded properties `i`, alternating signs using `(-1)^i`.\n    - Compute term magnitude as the product of ways to choose excluded properties and ways to satisfy the remaining constraints.\n\n## number theory tool\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: GCD Pair Parametrization\n  description: Representing two integers x, y with gcd(x, y) = g as x = g*a, y = g*b where gcd(a, b) = 1 to simplify GCD/LCM constraints.\n  parameters:\n    - gcd_val (type: integer): The known greatest common divisor of the pair\n    - factors (type: pair of integers): The coprime coefficients a and b\n  cues:\n    - Problem involves finding integer pairs with specified GCD/LCM values or constraints linking them (e.g., LCM related to one of the numbers).\n  implementation:\n    - Parametrize integers as x = gcd_val * a, y = gcd_val * b with gcd(a, b) = 1.\n    - Reduce constraints to the product equation a * b = lcm_val / gcd_val.\n- concept: Linear Diophantine Non-negative Counting\n  description: Counts non-negative integer solutions to a linear equation Ax + By = C by parameterizing the general solution and determining the valid range of the parameter.\n  parameters:\n    - coefficients (type: list of integers): Coefficients A and B of the variables in the linear equation\n    - target (type: integer): The constant term C on the right hand side\n  cues:\n    - Linear equation on integer variables\n    - Non-negativity constraints\n    - Counting valid solutions\n  implementation:\n    - Parameterized solution for y, derived bounds for parameter k from x>=0 and y>=0"
  },
  "cmath_4828": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n- concept: Complementary Counting\n  description: Determining the count of elements satisfying a property by subtracting the count of elements that do not satisfy it from the total count.\n  parameters:\n    - total (type: integer): The total number of possibilities including invalid cases.\n    - excluded (type: integer): The number of invalid or unwanted possibilities to subtract.\n    - total_count (type: integer): The total number of elements in the universal set.\n    - complement_count (type: integer): The number of elements satisfying the negation of the target condition.\n  cues:\n    - Problem asks for \"at least one\", \"non-empty\", or \"not all\", or involves phrases like \"none\", \"never\", or \"all distinct\".\n    - Direct counting involves complex casework, but counting the complement is simpler.\n    - Total set size is easily determined.\n  implementation:\n    - Calculate result by subtracting the complement count from the total count.\n    - Subtract 1 from total_combinations to remove the empty selection case.\n\n## formula\n- concept: Divisor Counting Formula\n  description: Computes the total number of positive divisors of an integer given its prime factorization exponents using the product of (exponent + 1).\n  cues:\n    - Problem asks for the count of divisors and prime factorization (or its exponents) is available or computable\n  implementation:\n    - Calculate the total number of divisors as the product of (exponent + 1) for each prime factor in the factorization\n\n## number theory tool\n- concept: Divisor Enumeration\n  description: Computing the complete set of positive divisors for a given integer to identify candidate values satisfying divisibility conditions.\n  parameters:\n    - n (type: Integer): The integer to find divisors for\n    - target_number (type: integer): The integer whose divisors are being computed\n  cues:\n    - Problem involves divisibility constraints or checking if k divides N.\n    - Search space or conditions require finding all divisors or specific subsets (e.g., proper divisors) of a specific or derived integer.\n  implementation:\n    - Iterate from 1 to sqrt(N) to construct the set of all positive divisors of the target integer by checking divisibility.\n    - Filter divisors to exclude 1 and n if proper divisors are required.\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)"
  },
  "cmath_4881": {
    "hint": "## number theory tool\n- concept: Perfect Power Divisor Count\n  description: Calculates the number of divisors that are perfect k-th powers by counting valid exponents divisible by k for each prime factor in the number's factorization.\n  parameters:\n    - power (type: integer): The root of the perfect power (e.g., 2 for squares, 3 for cubes)\n    - exponent (type: integer): The exponent of the prime factor in the number's prime factorization\n    - PrimeExponents (type: list[int]): The exponents of the prime factors in the integer's prime factorization\n    - RootPower (type: int): The power k (e.g., 2 for square, 3 for cube) that the divisors must satisfy\n  cues:\n    - Problem asks for the number of divisors that are perfect k-th powers (squares, cubes, etc.)\n    - Prime factorization is known or easily computable\n  implementation:\n    - For each prime factor exponent E, calculate valid choices as floor(E / k) + 1, where k is the root power\n    - Multiply the counts for each prime factor to get the total number of perfect power divisors\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: Valuation Analysis\n  description: Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.\n  parameters:\n    - p (type: prime): The prime base for the valuation.\n    - n (type: integer): The number to analyze for prime valuation.\n  cues:\n    - Equations involving multiplicative operations (LCM, GCD, division) or determining the exact prime power dividing quotients/rational expressions\n    - Constraints or properties applied independently to each prime factor (e.g., perfect powers, divisor counts, exponent divisibility)\n    - Logarithmic equations with integer constraints or base conversion involving primes\n  implementation:\n    - Extract exponents via full prime factorization or specific p-adic valuation calculations (repeated division/subtraction)\n    - Convert constraints (logarithms, perfect powers) into linear equations on exponents, solving for each prime independently before combining results"
  },
  "cmath_4897": {
    "hint": "## counting method\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n\n## number theory tool\n- concept: Perfect Power Divisor Count\n  description: Calculates the number of divisors that are perfect k-th powers by counting valid exponents divisible by k for each prime factor in the number's factorization.\n  parameters:\n    - power (type: integer): The root of the perfect power (e.g., 2 for squares, 3 for cubes)\n    - exponent (type: integer): The exponent of the prime factor in the number's prime factorization\n    - PrimeExponents (type: list[int]): The exponents of the prime factors in the integer's prime factorization\n    - RootPower (type: int): The power k (e.g., 2 for square, 3 for cube) that the divisors must satisfy\n  cues:\n    - Problem asks for the number of divisors that are perfect k-th powers (squares, cubes, etc.)\n    - Prime factorization is known or easily computable\n  implementation:\n    - For each prime factor exponent E, calculate valid choices as floor(E / k) + 1, where k is the root power\n    - Multiply the counts for each prime factor to get the total number of perfect power divisors\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: GCD Pair Parametrization\n  description: Representing two integers x, y with gcd(x, y) = g as x = g*a, y = g*b where gcd(a, b) = 1 to simplify GCD/LCM constraints.\n  parameters:\n    - gcd_val (type: integer): The known greatest common divisor of the pair\n    - factors (type: pair of integers): The coprime coefficients a and b\n  cues:\n    - Problem involves finding integer pairs with specified GCD/LCM values or constraints linking them (e.g., LCM related to one of the numbers).\n  implementation:\n    - Parametrize integers as x = gcd_val * a, y = gcd_val * b with gcd(a, b) = 1.\n    - Reduce constraints to the product equation a * b = lcm_val / gcd_val.\n- concept: Valuation Analysis\n  description: Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.\n  parameters:\n    - p (type: prime): The prime base for the valuation.\n    - n (type: integer): The number to analyze for prime valuation.\n  cues:\n    - Equations involving multiplicative operations (LCM, GCD, division) or determining the exact prime power dividing quotients/rational expressions\n    - Constraints or properties applied independently to each prime factor (e.g., perfect powers, divisor counts, exponent divisibility)\n    - Logarithmic equations with integer constraints or base conversion involving primes\n  implementation:\n    - Extract exponents via full prime factorization or specific p-adic valuation calculations (repeated division/subtraction)\n    - Convert constraints (logarithms, perfect powers) into linear equations on exponents, solving for each prime independently before combining results\n\n## theorem\n- concept: LCM Valuation Identity\n  description: The p-adic valuation of the least common multiple of two numbers is the maximum of their individual p-adic valuations.\n  cues:\n    - Problem involves LCM or GCD operations\n    - Need to simplify LCM expressions algebraically\n  implementation:\n    - Applied property v_p(lcm(x, y)) = max(v_p(x), v_p(y)) to transform the LCM equation into exponent equations."
  },
  "cmath_5024": {
    "hint": "## formula\n- concept: Divisor Counting Formula\n  description: Computes the total number of positive divisors of an integer given its prime factorization exponents using the product of (exponent + 1).\n  cues:\n    - Problem asks for the count of divisors and prime factorization (or its exponents) is available or computable\n  implementation:\n    - Calculate the total number of divisors as the product of (exponent + 1) for each prime factor in the factorization\n\n## number theory tool\n- concept: Legendre's Formula\n  description: Computes the exponent of a prime p in the prime factorization of n! by summing the floor divisions of n by powers of p (sum_{k>=1} floor(n/p^k)).\n  parameters:\n    - n (type: integer): The integer for which the factorial prime exponent is calculated.\n    - p (type: prime): The prime number for which the exponent in the factorization is sought.\n    - prime (type: integer): The prime number whose exponent in the prime factorization of n! is desired.\n  cues:\n    - Determining the exponent of a prime p in the factorization of n!\n    - Problems asking for the number of trailing zeros in a factorial\n    - Simplifying fractions or expressions involving factorials and prime powers\n  implementation:\n    - Iterate through powers of p (p, p^2, ...), summing floor(n / p^k) until p^k > n.\n    - Commonly applied with p=5 to determine the number of trailing zeros in n!.\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: Valuation Analysis\n  description: Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.\n  parameters:\n    - p (type: prime): The prime base for the valuation.\n    - n (type: integer): The number to analyze for prime valuation.\n  cues:\n    - Equations involving multiplicative operations (LCM, GCD, division) or determining the exact prime power dividing quotients/rational expressions\n    - Constraints or properties applied independently to each prime factor (e.g., perfect powers, divisor counts, exponent divisibility)\n    - Logarithmic equations with integer constraints or base conversion involving primes\n  implementation:\n    - Extract exponents via full prime factorization or specific p-adic valuation calculations (repeated division/subtraction)\n    - Convert constraints (logarithms, perfect powers) into linear equations on exponents, solving for each prime independently before combining results"
  },
  "cmath_5044": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n- concept: Complementary Counting\n  description: Determining the count of elements satisfying a property by subtracting the count of elements that do not satisfy it from the total count.\n  parameters:\n    - total (type: integer): The total number of possibilities including invalid cases.\n    - excluded (type: integer): The number of invalid or unwanted possibilities to subtract.\n    - total_count (type: integer): The total number of elements in the universal set.\n    - complement_count (type: integer): The number of elements satisfying the negation of the target condition.\n  cues:\n    - Problem asks for \"at least one\", \"non-empty\", or \"not all\", or involves phrases like \"none\", \"never\", or \"all distinct\".\n    - Direct counting involves complex casework, but counting the complement is simpler.\n    - Total set size is easily determined.\n  implementation:\n    - Calculate result by subtracting the complement count from the total count.\n    - Subtract 1 from total_combinations to remove the empty selection case.\n\n## formula\n- concept: Range Cardinality\n  description: Computes the number of integers in an inclusive interval [min, max] using the formula max - min + 1.\n  parameters:\n    - range_min (type: integer): The lower bound of the inclusive range.\n    - range_max (type: integer): The upper bound of the inclusive range.\n  cues:\n    - Problem asks for the count of integers within a specific inclusive interval.\n    - Bounds are given as explicit integers (often non-negative).\n    - Counting valid parameter values within a range.\n  implementation:\n    - Compute the count of integers in an inclusive range [min, max] using the formula `max - min + 1` (simplifies to `max + 1` if min is 0).\n    - Use this calculation to establish the universe size for complementary counting.\n\n## number theory tool\n- concept: Divisibility Counting Formula\n  description: Calculates the number of multiples of an integer k within the range [1, N] using the floor division formula floor(N / k).\n  parameters:\n    - limit (type: integer): The upper bound of the range (inclusive)\n    - divisor (type: integer): The number whose multiples are being counted\n  cues:\n    - Counting multiples or divisible numbers within a large range [1, N] where enumeration is inefficient (requires floor(N / k))\n  implementation:\n    - Use floor(N / k) to calculate the number of multiples of k in range [1, N]\n    - Apply formula inside loops for dynamic divisors (e.g., powers of a prime)\n    - Extend to inclusion-exclusion by computing counts for individual divisors and their LCM for intersections\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)"
  },
  "cmath_5071": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Iterative Accumulation\n  description: Accumulating a result by iterating through a sequence of values and updating a running total\n  parameters:\n    - sequence (type: list): The collection of values to iterate over.\n    - accumulator (type: variable): The variable storing the running sum or product\n    - start (type: integer): Starting value of the loop counter\n    - end (type: integer): Ending value of the loop counter\n    - update_rule (type: function): The function applied to the current element to update the sum\n    - operation (type: function): The transformation applied to each element before accumulation.\n  cues:\n    - Problem asks for an aggregate value (sum, product, count, digit sums) derived from a sequence, range, or enumerated items.\n    - Solution involves a loop iterating through a collection (list, range, or components like prime factors) where a running total or product variable is updated in each iteration.\n    - Aggregating results from multiple independent choices or cases (e.g., combinatorial products, inclusion-exclusion terms).\n    - Building a frequency map, histogram, or global metric by sequentially processing input data.\n  implementation:\n    - Initialize an accumulator variable to the identity value (0 for sums, 1 for products).\n    - Iterate through the sequence (range of integers, list of items, or prime factors).\n    - In each iteration, compute the contribution based on the current element and update the accumulator using the appropriate operation (addition, multiplication, modular arithmetic).\n    - If applicable, apply conditions before updating (e.g., only add if a value is valid/integer).\n    - Return the final accumulated value after the loop completes.\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n\n## technique\n- concept: Digit Decomposition\n  description: Extracting individual digits from an integer in a given base to analyze their values or relationships.\n  parameters:\n    - number (type: integer): The integer to be decomposed into digits\n    - base (type: integer): The numerical base for decomposition (default 10)\n  cues:\n    - Problem involves extracting, analyzing, or performing arithmetic on individual digits, bits, or positional values in a specific base (e.g., decimal, binary, digit_sum, ith bit)\n    - References to decimal/fractional expansion or positional representation formulas (e.g., n = \u03a3(b_i * 2^i))\n  implementation:\n    - Decompose the number (integer or rational) into a sequence of digits or bits in the target base (e.g., via `decimal_digits(n)` or bit extraction)\n    - Treat the extracted digits for analysis or as coefficients in a summation"
  },
  "cmath_5157": {
    "hint": "## algebraic manipulation\n- concept: Base-b Polynomial Representation\n  description: Interpreting a number represented by digits in an unknown base b as a polynomial expression in b, where each digit is a coefficient corresponding to a power of b.\n  parameters:\n    - digits (type: list of integers): The sequence of digits d_n...d_0 representing the number.\n    - base_variable (type: symbol): The variable representing the unknown base (e.g., b).\n  cues:\n    - Problem involves numbers represented by digits in unspecified, variable, or multiple bases using positional notation (e.g., $121_c$ or equations mixing bases).\n    - Problem involves sums of distinct powers of 3 (equivalent to base-3 representation with digits 0 and 1).\n  implementation:\n    - Convert numbers from base-b representation to a polynomial in b (e.g., digits d_n...d_0 map to sum(d_i * b^i)); for sums of distinct powers, treat as base-b polynomials with binary coefficients.\n\n## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## counting method\n- concept: Positional Digit Counting\n  description: Counting integers satisfying digit-level constraints by multiplying the number of valid choices for each digit position (Hundreds, Tens, Units, etc.).\n  parameters:\n    - positions (type: list): The digit positions to fill (e.g., [100, 10, 1]).\n    - constraints (type: list): Rules restricting valid digits at each position (e.g., distinctness, range bounds).\n  cues:\n    - Counting integers with fixed digit length or base b representation (e.g., Hundreds, Tens, Units)\n    - Digit-level constraints (parity, leading zero, specific values) or dependencies between positions (e.g., distinctness)\n  implementation:\n    - Decompose the number into positional components (e.g., Hundreds, Tens, Units or base b positions)\n    - Calculate valid digit choices for each position, adjusting for dependencies like distinctness based on previous selections, and apply the multiplication principle to compute total count"
  },
  "cmath_5170": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n\n## number theory tool\n- concept: Coprimality Check\n  description: Verifying two numbers are relatively prime by checking if their greatest common divisor is 1.\n  parameters:\n    - num1 (type: integer): First integer\n    - num2 (type: integer): Second integer\n  cues:\n    - Constraint explicitly requires gcd(a, b) = 1 or gcd(x, n) == 1\n    - Requirement for a modular inverse to exist or justification for division in congruences\n    - Problem involves reduced fractions, canonical representation, or numerators coprime to denominators\n    - Conditions requiring adjacent elements, derived variables, or factor pairs to be relatively prime\n    - Application of Euler's Totient Theorem\n  implementation:\n    - Check `if gcd(a, m) == 1` to validate precondition for modular inverse or division, returning error if failed\n    - Iterate through candidates, pairs, or residue systems, computing gcd to filter non-coprime elements or ensure coprimality (e.g., numerators/denominators)"
  },
  "cmath_5193": {
    "hint": "## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n\n## formula\n- concept: Arithmetic Progression Count\n  description: Calculates the number of terms in an arithmetic progression (start, start+step, ...) that are less than or equal to a given limit.\n  parameters:\n    - start (type: integer): The first term of the arithmetic progression.\n    - step (type: integer): The common difference between consecutive terms.\n    - limit (type: integer): The upper bound for the terms.\n  cues:\n    - Need to count integers (included or excluded) in a range that form a regular sequence with constant difference (e.g., satisfying a linear congruence).\n    - Range is large, requiring an O(1) formula instead of iteration.\n  implementation:\n    - Identify sequence parameters (start, step) from the condition (e.g., k \u2261 2 mod 4 implies start=2, step=4).\n    - {'Compute count using formula': 'FLOOR((limit - start) / step) + 1.'}\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: Consecutive Digit Sum Relation\n  description: Relates the sum of digits of consecutive integers n and n+1 via the formula S(n+1) = S(n) + 1 - 9k, where k is the number of trailing 9s in n. This implies S(n+1) <= S(n) + 1 and S(n+1) is congruent to S(n) + 1 modulo 9.\n  parameters:\n    - S_n (type: integer): The sum of digits of the integer n\n    - S_next (type: integer): The sum of digits of the integer n+1\n    - k (type: integer): The number of trailing 9s in the decimal representation of n (number of carries)\n  cues:\n    - Problems involving digit sums of consecutive integers\n    - Divisibility by 9 in digit sum differences\n    - Inequality constraints between consecutive digit sums\n  implementation:\n    - Calculated theoretical maximum digit sum for n+1 as S_n + 1\n    - Validated candidate digit sums by checking if the difference from the maximum is a non-negative multiple of 9"
  },
  "cmath_5209": {
    "hint": "## algebraic manipulation\n- concept: Base-b Polynomial Representation\n  description: Interpreting a number represented by digits in an unknown base b as a polynomial expression in b, where each digit is a coefficient corresponding to a power of b.\n  parameters:\n    - digits (type: list of integers): The sequence of digits d_n...d_0 representing the number.\n    - base_variable (type: symbol): The variable representing the unknown base (e.g., b).\n  cues:\n    - Problem involves numbers represented by digits in unspecified, variable, or multiple bases using positional notation (e.g., $121_c$ or equations mixing bases).\n    - Problem involves sums of distinct powers of 3 (equivalent to base-3 representation with digits 0 and 1).\n  implementation:\n    - Convert numbers from base-b representation to a polynomial in b (e.g., digits d_n...d_0 map to sum(d_i * b^i)); for sums of distinct powers, treat as base-b polynomials with binary coefficients.\n\n## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n\n## technique\n- concept: Algebraic Substitution\n  description: Replacing a variable in an equation with an equivalent expression derived from another equation to reduce the system to a single variable.\n  parameters:\n    - target_equation (type: equation): The equation into which substitution is performed\n    - substitution_expression (type: expression): The expression replacing the variable\n    - variable (type: symbol): The variable being eliminated\n  cues:\n    - Systems of equations with shared variables, especially where linear constraints allow easy isolation\n    - Expressions containing matching sub-expressions or derived forms where substitution simplifies structure or utilizes given values\n    - Problems involving ratio-based holdings or distribution expressions\n  implementation:\n    - Substitute isolated variables into other equations to reduce the system to a single variable (e.g., quadratic)\n    - Substitute sub-expressions or definitions into expressions to simplify computation or reveal structure (e.g., prime factorization)\n    - Substitute parameterized ratios into distribution expressions to link quantities to scaling factors"
  },
  "cmath_5237": {
    "hint": "## algorithmic pattern\n- concept: Reverse Search for Maximum\n  description: Iterating from the theoretical upper bound downwards to find the largest value satisfying a predicate, allowing early termination.\n  parameters:\n    - start_val (type: integer): The maximum possible value to start searching from\n    - condition (type: predicate function): The boolean condition that the value must satisfy\n  cues:\n    - Objective is to find the largest discrete value satisfying a condition\n    - Search space consists of bounded, ordered discrete candidates\n    - Existence of a calculable theoretical upper bound\n    - Validity check is computationally feasible\n  implementation:\n    - Compute starting value as floor(upper_bound / divisor) to establish search start\n    - Iterate candidates from maximum possible value downwards\n    - Return immediately upon finding the first valid candidate\n\n## identity\n- concept: arithmetic_progression_mean\n  description: The mean of a finite set of consecutive integers is equal to the average of the first and last terms.\n  parameters:\n    - start (type: integer): The first integer in the sequence\n    - end (type: integer): The last integer in the sequence\n  cues:\n    - Problem asks for the average, mean, or sum of a set of integers\n    - The integers form a consecutive sequence or arithmetic progression\n  implementation:\n    - Compute the average as (first_term + last_term) / 2\n    - Avoid explicit summation or counting of elements\n\n## number theory tool\n- concept: Divisor Enumeration\n  description: Computing the complete set of positive divisors for a given integer to identify candidate values satisfying divisibility conditions.\n  parameters:\n    - n (type: Integer): The integer to find divisors for\n    - target_number (type: integer): The integer whose divisors are being computed\n  cues:\n    - Problem involves divisibility constraints or checking if k divides N.\n    - Search space or conditions require finding all divisors or specific subsets (e.g., proper divisors) of a specific or derived integer.\n  implementation:\n    - Iterate from 1 to sqrt(N) to construct the set of all positive divisors of the target integer by checking divisibility.\n    - Filter divisors to exclude 1 and n if proper divisors are required.\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)"
  },
  "cmath_5267": {
    "hint": "## algorithmic pattern\n- concept: Constructive Enumeration\n  description: Generates valid instances by composing fundamental building blocks (e.g., primes) according to structural rules instead of brute-force checking.\n  parameters:\n    - primitives (type: list): Fundamental elements to build from (e.g., list of primes)\n    - construction_rules (type: list): Mathematical forms to apply to primitives (e.g., p^3, p*q)\n  cues:\n    - Search space consists of discrete structural configurations (e.g., partitions, subsets) or sequences rather than a numeric range, requiring generation via structural rules or primitives.\n    - Objective is to find an optimal value (min/max) or smallest k numbers with a property among valid configurations.\n  implementation:\n    - Generate candidates by composing primitives (e.g., primes) or iterating structural configurations (e.g., partitions, subsets, recurrence sequences).\n    - Iterate through generated candidates to compute derived values and identify the optimal result.\n- concept: K-Smallest Aggregation\n  description: Selects the k extreme values from a generated set and computes an aggregate value over them.\n  parameters:\n    - k (type: integer): Count of extreme values to select\n    - aggregation_func (type: function): Function to apply to selected subset (e.g., sum, product)\n  cues:\n    - sum of smallest k values\n  implementation:\n    - Sort all candidates in ascending order, select the first k, and compute the aggregate (e.g., sum) over them.\n\n## formula\n- concept: Divisor Counting Formula\n  description: Computes the total number of positive divisors of an integer given its prime factorization exponents using the product of (exponent + 1).\n  cues:\n    - Problem asks for the count of divisors and prime factorization (or its exponents) is available or computable\n  implementation:\n    - Calculate the total number of divisors as the product of (exponent + 1) for each prime factor in the factorization\n\n## technique\n- concept: Valuation Analysis\n  description: Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.\n  parameters:\n    - p (type: prime): The prime base for the valuation.\n    - n (type: integer): The number to analyze for prime valuation.\n  cues:\n    - Equations involving multiplicative operations (LCM, GCD, division) or determining the exact prime power dividing quotients/rational expressions\n    - Constraints or properties applied independently to each prime factor (e.g., perfect powers, divisor counts, exponent divisibility)\n    - Logarithmic equations with integer constraints or base conversion involving primes\n  implementation:\n    - Extract exponents via full prime factorization or specific p-adic valuation calculations (repeated division/subtraction)\n    - Convert constraints (logarithms, perfect powers) into linear equations on exponents, solving for each prime independently before combining results\n- concept: Greedy Prime Exponent Assignment\n  description: To minimize an integer N = product(p_i ^ e_i) given a fixed multiset of exponents, assign the largest exponents to the smallest distinct prime bases.\n  parameters:\n    - exponents (type: list[int]): The multiset of exponents derived from the problem constraints.\n    - prime_sequence (type: list[int]): The ordered sequence of distinct primes (e.g., 2, 3, 5...) to be used as bases.\n  cues:\n    - Problem asks for the minimum integer where the multiset of prime exponents is derived from structural constraints (e.g., divisor count).\n    - The choice of prime bases is flexible (not fixed by the problem).\n  implementation:\n    - Sort derived exponents in descending order and assign them to consecutive primes starting from 2.\n    - Evaluate each valid exponent partition configuration to find the global minimum.\n\n## theorem\n- concept: Divisor Count Structure\n  description: Characterizes the prime factorization form of an integer based on its total number of divisors using the divisor function formula tau(n).\n  parameters:\n    - target_divisors (type: integer): The exact number of divisors the integer must have\n  cues:\n    - Problem specifies an exact count of divisors (total or restricted) and requires determining the number's prime factorization structure (exponents).\n  implementation:\n    - Apply the relation tau(N) = product(e_i + 1) to derive prime exponents from the target divisor count (e.g., 3 factors implies p^2, 4 factors implies p^3 or p*q).\n    - If given a restricted divisor count (excluding 1 and N), infer the total divisor count D by adding 2.\n    - Validate that candidate numbers constructed from the derived exponents satisfy the original divisor count requirement."
  },
  "cmath_5289": {
    "hint": "## algorithmic pattern\n- concept: Iterative Accumulation\n  description: Accumulating a result by iterating through a sequence of values and updating a running total\n  parameters:\n    - sequence (type: list): The collection of values to iterate over.\n    - accumulator (type: variable): The variable storing the running sum or product\n    - start (type: integer): Starting value of the loop counter\n    - end (type: integer): Ending value of the loop counter\n    - update_rule (type: function): The function applied to the current element to update the sum\n    - operation (type: function): The transformation applied to each element before accumulation.\n  cues:\n    - Problem asks for an aggregate value (sum, product, count, digit sums) derived from a sequence, range, or enumerated items.\n    - Solution involves a loop iterating through a collection (list, range, or components like prime factors) where a running total or product variable is updated in each iteration.\n    - Aggregating results from multiple independent choices or cases (e.g., combinatorial products, inclusion-exclusion terms).\n    - Building a frequency map, histogram, or global metric by sequentially processing input data.\n  implementation:\n    - Initialize an accumulator variable to the identity value (0 for sums, 1 for products).\n    - Iterate through the sequence (range of integers, list of items, or prime factors).\n    - In each iteration, compute the contribution based on the current element and update the accumulator using the appropriate operation (addition, multiplication, modular arithmetic).\n    - If applicable, apply conditions before updating (e.g., only add if a value is valid/integer).\n    - Return the final accumulated value after the loop completes.\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: Legendre's Formula\n  description: Computes the exponent of a prime p in the prime factorization of n! by summing the floor divisions of n by powers of p (sum_{k>=1} floor(n/p^k)).\n  parameters:\n    - n (type: integer): The integer for which the factorial prime exponent is calculated.\n    - p (type: prime): The prime number for which the exponent in the factorization is sought.\n    - prime (type: integer): The prime number whose exponent in the prime factorization of n! is desired.\n  cues:\n    - Determining the exponent of a prime p in the factorization of n!\n    - Problems asking for the number of trailing zeros in a factorial\n    - Simplifying fractions or expressions involving factorials and prime powers\n  implementation:\n    - Iterate through powers of p (p, p^2, ...), summing floor(n / p^k) until p^k > n.\n    - Commonly applied with p=5 to determine the number of trailing zeros in n!.\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: Valuation Analysis\n  description: Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.\n  parameters:\n    - p (type: prime): The prime base for the valuation.\n    - n (type: integer): The number to analyze for prime valuation.\n  cues:\n    - Equations involving multiplicative operations (LCM, GCD, division) or determining the exact prime power dividing quotients/rational expressions\n    - Constraints or properties applied independently to each prime factor (e.g., perfect powers, divisor counts, exponent divisibility)\n    - Logarithmic equations with integer constraints or base conversion involving primes\n  implementation:\n    - Extract exponents via full prime factorization or specific p-adic valuation calculations (repeated division/subtraction)\n    - Convert constraints (logarithms, perfect powers) into linear equations on exponents, solving for each prime independently before combining results"
  },
  "cmath_5307": {
    "hint": "## algorithmic pattern\n- concept: Iterative Accumulation\n  description: Accumulating a result by iterating through a sequence of values and updating a running total\n  parameters:\n    - sequence (type: list): The collection of values to iterate over.\n    - accumulator (type: variable): The variable storing the running sum or product\n    - start (type: integer): Starting value of the loop counter\n    - end (type: integer): Ending value of the loop counter\n    - update_rule (type: function): The function applied to the current element to update the sum\n    - operation (type: function): The transformation applied to each element before accumulation.\n  cues:\n    - Problem asks for an aggregate value (sum, product, count, digit sums) derived from a sequence, range, or enumerated items.\n    - Solution involves a loop iterating through a collection (list, range, or components like prime factors) where a running total or product variable is updated in each iteration.\n    - Aggregating results from multiple independent choices or cases (e.g., combinatorial products, inclusion-exclusion terms).\n    - Building a frequency map, histogram, or global metric by sequentially processing input data.\n  implementation:\n    - Initialize an accumulator variable to the identity value (0 for sums, 1 for products).\n    - Iterate through the sequence (range of integers, list of items, or prime factors).\n    - In each iteration, compute the contribution based on the current element and update the accumulator using the appropriate operation (addition, multiplication, modular arithmetic).\n    - If applicable, apply conditions before updating (e.g., only add if a value is valid/integer).\n    - Return the final accumulated value after the loop completes.\n\n## definition\n- concept: Double Factorial\n  description: Product of integers from n down to 1 or 2 with a step of 2, denoted as n!!\n  parameters:\n    - n (type: integer): The non-negative integer to compute the double factorial for\n  cues:\n    - double exclamation mark notation\n    - product of integers with same parity (skipping every other integer)\n  implementation:\n    - {'Recursive implementation': 'base case returns 1 for n <= 1, otherwise n * DoubleFactorial(n - 2)'}\n\n## number theory tool\n- concept: GCD Computation\n  description: Calculating the greatest common divisor of two integers to analyze their divisibility relationship.\n  parameters:\n    - a (type: int): The first integer.\n    - b (type: int): The second integer.\n  cues:\n    - Problem involves common factors, simplification, or divisibility\n    - Explicit mention of gcd or greatest common divisor\n    - reducing fractions to irreducible form\n    - analyzing divisibility relationship\n    - Need to find the common divisor of multiple generated values\n    - Determining the greatest integer satisfying multiple divisibility constraints\n  implementation:\n    - Compute `g = gcd(m, 100)`\n    - Used to reduce probability fraction to irreducible form m/n.\n    - Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)\n- concept: Legendre's Formula\n  description: Computes the exponent of a prime p in the prime factorization of n! by summing the floor divisions of n by powers of p (sum_{k>=1} floor(n/p^k)).\n  parameters:\n    - n (type: integer): The integer for which the factorial prime exponent is calculated.\n    - p (type: prime): The prime number for which the exponent in the factorization is sought.\n    - prime (type: integer): The prime number whose exponent in the prime factorization of n! is desired.\n  cues:\n    - Determining the exponent of a prime p in the factorization of n!\n    - Problems asking for the number of trailing zeros in a factorial\n    - Simplifying fractions or expressions involving factorials and prime powers\n  implementation:\n    - Iterate through powers of p (p, p^2, ...), summing floor(n / p^k) until p^k > n.\n    - Commonly applied with p=5 to determine the number of trailing zeros in n!.\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: Valuation Analysis\n  description: Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.\n  parameters:\n    - p (type: prime): The prime base for the valuation.\n    - n (type: integer): The number to analyze for prime valuation.\n  cues:\n    - Equations involving multiplicative operations (LCM, GCD, division) or determining the exact prime power dividing quotients/rational expressions\n    - Constraints or properties applied independently to each prime factor (e.g., perfect powers, divisor counts, exponent divisibility)\n    - Logarithmic equations with integer constraints or base conversion involving primes\n  implementation:\n    - Extract exponents via full prime factorization or specific p-adic valuation calculations (repeated division/subtraction)\n    - Convert constraints (logarithms, perfect powers) into linear equations on exponents, solving for each prime independently before combining results\n- concept: Algebraic Substitution\n  description: Replacing a variable in an equation with an equivalent expression derived from another equation to reduce the system to a single variable.\n  parameters:\n    - target_equation (type: equation): The equation into which substitution is performed\n    - substitution_expression (type: expression): The expression replacing the variable\n    - variable (type: symbol): The variable being eliminated\n  cues:\n    - Systems of equations with shared variables, especially where linear constraints allow easy isolation\n    - Expressions containing matching sub-expressions or derived forms where substitution simplifies structure or utilizes given values\n    - Problems involving ratio-based holdings or distribution expressions\n  implementation:\n    - Substitute isolated variables into other equations to reduce the system to a single variable (e.g., quadratic)\n    - Substitute sub-expressions or definitions into expressions to simplify computation or reveal structure (e.g., prime factorization)\n    - Substitute parameterized ratios into distribution expressions to link quantities to scaling factors"
  },
  "cmath_5310": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Set Deduplication\n  description: Using a set data structure to store results of a transformation to automatically filter duplicates, useful for identifying distinct outcomes.\n  parameters:\n    - values (type: iterable): The sequence of values to deduplicate\n  cues:\n    - Goal is to count the number of *unique* or *distinct* outcomes.\n    - Multiple different inputs may produce the same output value.\n  implementation:\n    - Initialize an empty set to store unique outcomes.\n    - Compute the value for each input and insert into the set to automatically filter duplicates.\n    - Return the cardinality of the set as the final answer.\n\n## calculation method\n- concept: Summation of Distinct Values\n  description: Calculating the arithmetic sum of all unique values in a collection.\n  parameters:\n    - distinct_values (type: set): The set of unique numbers to sum\n  cues:\n    - Problem asks for the sum of all distinct/unique valid solutions or outcomes.\n    - Collected numbers are distinct by virtue of the search process.\n  implementation:\n    - Compute the final answer as the arithmetic sum of all elements in the collected set of valid values, typically by iterating and accumulating into a total sum variable.\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n- concept: Modular Power Cycle\n  description: Exploits the periodic sequence of powers of an integer modulo m to reduce large exponents by computing the exponent modulo the cycle length.\n  parameters:\n    - base (type: integer): The base of the power (e.g., the prime p).\n    - modulus (type: integer): The modulus for the cycle (e.g., 10 for ones digit).\n    - exponent (type: integer): The large exponent to be reduced.\n  cues:\n    - Computing last digits or residues of large powers (including power towers)\n    - Detecting periodicity in sequences of powers modulo m\n  implementation:\n    - Determine the cycle length of base^k mod m, then reduce the exponent modulo this length (mapping 0 to the cycle length).\n\n## theorem\n- concept: Euler's Totient Theorem\n  description: States that if gcd(a, n) = 1, then a^phi(n) \u2261 1 (mod n), allowing exponent reduction modulo phi(n).\n  parameters:\n    - base (type: integer): The integer base 'a' which must be coprime to the modulus\n    - modulus (type: integer): The modulus 'n' for the congruence\n  cues:\n    - Computing a^b mod n where b is large\n    - Base and modulus are coprime (especially if modulus is prime)\n  implementation:\n    - Reduce exponent modulo phi(n) using a^phi(n) \u2261 1 (mod n) (use n-1 if modulus is prime)\n- concept: Chinese Remainder Theorem\n  description: Constructs a unique solution modulo the product of moduli for a system of linear congruences with pairwise coprime moduli.\n  parameters:\n    - congruences (type: list of tuples): List of (residue, modulus) pairs representing x \u2261 residue (mod modulus).\n  cues:\n    - System of multiple modular congruences.\n    - Moduli are pairwise coprime.\n    - Need to find a single integer satisfying all conditions.\n  implementation:\n    - Computed M_total as the product of all reduced moduli.\n    - Iterated through each congruence to compute partial terms (N_i * y_i * residue).\n    - Summed partial terms modulo M_total to find the base solution x_0."
  },
  "cmath_5322": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## number theory tool\n- concept: Coprimality Check\n  description: Verifying two numbers are relatively prime by checking if their greatest common divisor is 1.\n  parameters:\n    - num1 (type: integer): First integer\n    - num2 (type: integer): Second integer\n  cues:\n    - Constraint explicitly requires gcd(a, b) = 1 or gcd(x, n) == 1\n    - Requirement for a modular inverse to exist or justification for division in congruences\n    - Problem involves reduced fractions, canonical representation, or numerators coprime to denominators\n    - Conditions requiring adjacent elements, derived variables, or factor pairs to be relatively prime\n    - Application of Euler's Totient Theorem\n  implementation:\n    - Check `if gcd(a, m) == 1` to validate precondition for modular inverse or division, returning error if failed\n    - Iterate through candidates, pairs, or residue systems, computing gcd to filter non-coprime elements or ensure coprimality (e.g., numerators/denominators)\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: GCD Computation\n  description: Calculating the greatest common divisor of two integers to analyze their divisibility relationship.\n  parameters:\n    - a (type: int): The first integer.\n    - b (type: int): The second integer.\n  cues:\n    - Problem involves common factors, simplification, or divisibility\n    - Explicit mention of gcd or greatest common divisor\n    - reducing fractions to irreducible form\n    - analyzing divisibility relationship\n    - Need to find the common divisor of multiple generated values\n    - Determining the greatest integer satisfying multiple divisibility constraints\n  implementation:\n    - Compute `g = gcd(m, 100)`\n    - Used to reduce probability fraction to irreducible form m/n.\n    - Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)\n- concept: Divisibility Substitution\n  description: Replacing variables with parameterized forms based on known divisibility constraints (e.g., if x must be divisible by k, set x = k\u00b7t for integer t)\n  parameters:\n    - variable (type: symbol): The original variable subject to divisibility constraint\n    - divisor (type: integer): The known divisor that the variable must be a multiple of\n    - parameter (type: symbol): The new integer parameter representing the quotient\n  cues:\n    - Variable constrained by divisibility, congruences, or multiple conditions (e.g., multiple of k or mk + r)\n    - Problem involves partitioning or grouping with fixed sizes\n    - Need to reduce search space using structural constraints or density reduction\n    - Counting divisors subject to a multiple constraint (e.g., divisors of N that are multiples of k)\n    - Problem involves ratios, proportional holdings, or a common scaling factor\n  implementation:\n    - Substitute variables with divisor multiples or congruence forms (e.g., M = 8m or r = a + m\u00b7k) to simplify equations and reduce coefficients\n    - Substitute divisor d = k\u00b7m to transform 'd divides N and k divides d' into counting divisors of N/k\n    - Introduce a scaling factor k to represent proportional values (e.g., 3k, 4k, 5k) based on given ratios to facilitate equation formulation\n    - Define candidates as n * multiplier to reduce search space from limit values to limit/multiplier values\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: Valuation Analysis\n  description: Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.\n  parameters:\n    - p (type: prime): The prime base for the valuation.\n    - n (type: integer): The number to analyze for prime valuation.\n  cues:\n    - Equations involving multiplicative operations (LCM, GCD, division) or determining the exact prime power dividing quotients/rational expressions\n    - Constraints or properties applied independently to each prime factor (e.g., perfect powers, divisor counts, exponent divisibility)\n    - Logarithmic equations with integer constraints or base conversion involving primes\n  implementation:\n    - Extract exponents via full prime factorization or specific p-adic valuation calculations (repeated division/subtraction)\n    - Convert constraints (logarithms, perfect powers) into linear equations on exponents, solving for each prime independently before combining results\n- concept: Minimum Integer Ceiling\n  description: Converting a real-valued lower bound derived from an inequality into the minimum satisfying integer using the ceiling function.\n  parameters:\n    - real_bound (type: float): The real-valued solution to the inequality.\n  cues:\n    - minimum integer\n    - discrete trials\n    - inequality solution\n  implementation:\n    - Step 4 applies ceiling to n_real to find n_min."
  },
  "cmath_5333": {
    "hint": "## algebraic manipulation\n- concept: Base-b Polynomial Representation\n  description: Interpreting a number represented by digits in an unknown base b as a polynomial expression in b, where each digit is a coefficient corresponding to a power of b.\n  parameters:\n    - digits (type: list of integers): The sequence of digits d_n...d_0 representing the number.\n    - base_variable (type: symbol): The variable representing the unknown base (e.g., b).\n  cues:\n    - Problem involves numbers represented by digits in unspecified, variable, or multiple bases using positional notation (e.g., $121_c$ or equations mixing bases).\n    - Problem involves sums of distinct powers of 3 (equivalent to base-3 representation with digits 0 and 1).\n  implementation:\n    - Convert numbers from base-b representation to a polynomial in b (e.g., digits d_n...d_0 map to sum(d_i * b^i)); for sums of distinct powers, treat as base-b polynomials with binary coefficients.\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n\n## technique\n- concept: Digit Decomposition\n  description: Extracting individual digits from an integer in a given base to analyze their values or relationships.\n  parameters:\n    - number (type: integer): The integer to be decomposed into digits\n    - base (type: integer): The numerical base for decomposition (default 10)\n  cues:\n    - Problem involves extracting, analyzing, or performing arithmetic on individual digits, bits, or positional values in a specific base (e.g., decimal, binary, digit_sum, ith bit)\n    - References to decimal/fractional expansion or positional representation formulas (e.g., n = \u03a3(b_i * 2^i))\n  implementation:\n    - Decompose the number (integer or rational) into a sequence of digits or bits in the target base (e.g., via `decimal_digits(n)` or bit extraction)\n    - Treat the extracted digits for analysis or as coefficients in a summation\n\n## theorem\n- concept: Chinese Remainder Theorem\n  description: Constructs a unique solution modulo the product of moduli for a system of linear congruences with pairwise coprime moduli.\n  parameters:\n    - congruences (type: list of tuples): List of (residue, modulus) pairs representing x \u2261 residue (mod modulus).\n  cues:\n    - System of multiple modular congruences.\n    - Moduli are pairwise coprime.\n    - Need to find a single integer satisfying all conditions.\n  implementation:\n    - Computed M_total as the product of all reduced moduli.\n    - Iterated through each congruence to compute partial terms (N_i * y_i * residue).\n    - Summed partial terms modulo M_total to find the base solution x_0."
  },
  "cmath_5335": {
    "hint": "## formula\n- concept: Divisor Counting Formula\n  description: Computes the total number of positive divisors of an integer given its prime factorization exponents using the product of (exponent + 1).\n  cues:\n    - Problem asks for the count of divisors and prime factorization (or its exponents) is available or computable\n  implementation:\n    - Calculate the total number of divisors as the product of (exponent + 1) for each prime factor in the factorization\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: Divisor Enumeration\n  description: Computing the complete set of positive divisors for a given integer to identify candidate values satisfying divisibility conditions.\n  parameters:\n    - n (type: Integer): The integer to find divisors for\n    - target_number (type: integer): The integer whose divisors are being computed\n  cues:\n    - Problem involves divisibility constraints or checking if k divides N.\n    - Search space or conditions require finding all divisors or specific subsets (e.g., proper divisors) of a specific or derived integer.\n  implementation:\n    - Iterate from 1 to sqrt(N) to construct the set of all positive divisors of the target integer by checking divisibility.\n    - Filter divisors to exclude 1 and n if proper divisors are required.\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: Valuation Analysis\n  description: Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.\n  parameters:\n    - p (type: prime): The prime base for the valuation.\n    - n (type: integer): The number to analyze for prime valuation.\n  cues:\n    - Equations involving multiplicative operations (LCM, GCD, division) or determining the exact prime power dividing quotients/rational expressions\n    - Constraints or properties applied independently to each prime factor (e.g., perfect powers, divisor counts, exponent divisibility)\n    - Logarithmic equations with integer constraints or base conversion involving primes\n  implementation:\n    - Extract exponents via full prime factorization or specific p-adic valuation calculations (repeated division/subtraction)\n    - Convert constraints (logarithms, perfect powers) into linear equations on exponents, solving for each prime independently before combining results\n\n## theorem\n- concept: Divisor Count Structure\n  description: Characterizes the prime factorization form of an integer based on its total number of divisors using the divisor function formula tau(n).\n  parameters:\n    - target_divisors (type: integer): The exact number of divisors the integer must have\n  cues:\n    - Problem specifies an exact count of divisors (total or restricted) and requires determining the number's prime factorization structure (exponents).\n  implementation:\n    - Apply the relation tau(N) = product(e_i + 1) to derive prime exponents from the target divisor count (e.g., 3 factors implies p^2, 4 factors implies p^3 or p*q).\n    - If given a restricted divisor count (excluding 1 and N), infer the total divisor count D by adding 2.\n    - Validate that candidate numbers constructed from the derived exponents satisfy the original divisor count requirement."
  },
  "cmath_5338": {
    "hint": "## algebraic manipulation\n- concept: Base-b Polynomial Representation\n  description: Interpreting a number represented by digits in an unknown base b as a polynomial expression in b, where each digit is a coefficient corresponding to a power of b.\n  parameters:\n    - digits (type: list of integers): The sequence of digits d_n...d_0 representing the number.\n    - base_variable (type: symbol): The variable representing the unknown base (e.g., b).\n  cues:\n    - Problem involves numbers represented by digits in unspecified, variable, or multiple bases using positional notation (e.g., $121_c$ or equations mixing bases).\n    - Problem involves sums of distinct powers of 3 (equivalent to base-3 representation with digits 0 and 1).\n  implementation:\n    - Convert numbers from base-b representation to a polynomial in b (e.g., digits d_n...d_0 map to sum(d_i * b^i)); for sums of distinct powers, treat as base-b polynomials with binary coefficients.\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: Valuation Analysis\n  description: Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.\n  parameters:\n    - p (type: prime): The prime base for the valuation.\n    - n (type: integer): The number to analyze for prime valuation.\n  cues:\n    - Equations involving multiplicative operations (LCM, GCD, division) or determining the exact prime power dividing quotients/rational expressions\n    - Constraints or properties applied independently to each prime factor (e.g., perfect powers, divisor counts, exponent divisibility)\n    - Logarithmic equations with integer constraints or base conversion involving primes\n  implementation:\n    - Extract exponents via full prime factorization or specific p-adic valuation calculations (repeated division/subtraction)\n    - Convert constraints (logarithms, perfect powers) into linear equations on exponents, solving for each prime independently before combining results"
  },
  "cmath_5345": {
    "hint": "## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n\n## formula\n- concept: Arithmetic Progression Count\n  description: Calculates the number of terms in an arithmetic progression (start, start+step, ...) that are less than or equal to a given limit.\n  parameters:\n    - start (type: integer): The first term of the arithmetic progression.\n    - step (type: integer): The common difference between consecutive terms.\n    - limit (type: integer): The upper bound for the terms.\n  cues:\n    - Need to count integers (included or excluded) in a range that form a regular sequence with constant difference (e.g., satisfying a linear congruence).\n    - Range is large, requiring an O(1) formula instead of iteration.\n  implementation:\n    - Identify sequence parameters (start, step) from the condition (e.g., k \u2261 2 mod 4 implies start=2, step=4).\n    - {'Compute count using formula': 'FLOOR((limit - start) / step) + 1.'}\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: Divisibility Counting Formula\n  description: Calculates the number of multiples of an integer k within the range [1, N] using the floor division formula floor(N / k).\n  parameters:\n    - limit (type: integer): The upper bound of the range (inclusive)\n    - divisor (type: integer): The number whose multiples are being counted\n  cues:\n    - Counting multiples or divisible numbers within a large range [1, N] where enumeration is inefficient (requires floor(N / k))\n  implementation:\n    - Use floor(N / k) to calculate the number of multiples of k in range [1, N]\n    - Apply formula inside loops for dynamic divisors (e.g., powers of a prime)\n    - Extend to inclusion-exclusion by computing counts for individual divisors and their LCM for intersections\n\n## technique\n- concept: Parity Feasibility Check\n  description: Verifying that the target sum and variable constraints have compatible parity to ensure integer solutions exist before counting.\n  cues:\n    - linear Diophantine equation\n    - Variable expression has a fixed parity structure (e.g., 2n - 1 is always odd) requiring integer solutions\n  implementation:\n    - Checked if (S - k) is odd or negative to return 0 early.\n    - Ensured compatibility between the parity of the divisor and the form 2n - 1 to guarantee integer n\n\n## theorem\n- concept: Euler's Totient Theorem\n  description: States that if gcd(a, n) = 1, then a^phi(n) \u2261 1 (mod n), allowing exponent reduction modulo phi(n).\n  parameters:\n    - base (type: integer): The integer base 'a' which must be coprime to the modulus\n    - modulus (type: integer): The modulus 'n' for the congruence\n  cues:\n    - Computing a^b mod n where b is large\n    - Base and modulus are coprime (especially if modulus is prime)\n  implementation:\n    - Reduce exponent modulo phi(n) using a^phi(n) \u2261 1 (mod n) (use n-1 if modulus is prime)"
  },
  "cmath_5353": {
    "hint": "## algorithmic pattern\n- concept: Iterative Accumulation\n  description: Accumulating a result by iterating through a sequence of values and updating a running total\n  parameters:\n    - sequence (type: list): The collection of values to iterate over.\n    - accumulator (type: variable): The variable storing the running sum or product\n    - start (type: integer): Starting value of the loop counter\n    - end (type: integer): Ending value of the loop counter\n    - update_rule (type: function): The function applied to the current element to update the sum\n    - operation (type: function): The transformation applied to each element before accumulation.\n  cues:\n    - Problem asks for an aggregate value (sum, product, count, digit sums) derived from a sequence, range, or enumerated items.\n    - Solution involves a loop iterating through a collection (list, range, or components like prime factors) where a running total or product variable is updated in each iteration.\n    - Aggregating results from multiple independent choices or cases (e.g., combinatorial products, inclusion-exclusion terms).\n    - Building a frequency map, histogram, or global metric by sequentially processing input data.\n  implementation:\n    - Initialize an accumulator variable to the identity value (0 for sums, 1 for products).\n    - Iterate through the sequence (range of integers, list of items, or prime factors).\n    - In each iteration, compute the contribution based on the current element and update the accumulator using the appropriate operation (addition, multiplication, modular arithmetic).\n    - If applicable, apply conditions before updating (e.g., only add if a value is valid/integer).\n    - Return the final accumulated value after the loop completes.\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n\n## formula\n- concept: Base-b Digit Count Formula\n  description: Calculates the number of digits required to represent a positive integer n in base b using the formula floor(log_b(n)) + 1.\n  parameters:\n    - n (type: integer): The positive integer value to be represented.\n    - b (type: integer): The target base for representation (b >= 2).\n  cues:\n    - Calculate the number of digits in a specific base\n    - log_base\n    - floor\n  implementation:\n    - Apply floor(log_b(n)) + 1 to determine the digit count for a given integer n and base b.\n\n## technique\n- concept: Leading Digit via Logarithmic Fractional Part\n  description: Determines the leading digit of a number N by computing the fractional part f of log10(N) and evaluating floor(10^f), avoiding direct computation of N.\n  parameters:\n    - number_expression (type: mathematical expression): The expression representing the large number (e.g., b^k).\n    - log_base (type: integer): The base of the logarithm, typically 10 for decimal leading digits.\n  cues:\n    - Problem asks for the leading digit of a large power or product.\n    - Direct computation of the number is infeasible due to size.\n  implementation:\n    - Computed fractional_part as {k * LOG_9} representing the fractional part of log10(9^k).\n    - Derived leading_digit using floor(10 ^ fractional_part)."
  },
  "cmath_5375": {
    "hint": "## formula\n- concept: base_digit_range_formula\n  description: Determines the minimum and maximum base-10 integer values representable by a number with a specific count of digits in a given base.\n  parameters:\n    - num_digits (type: integer): The number of digits in the representation\n    - base (type: integer): The base of the number system\n  cues:\n    - Problem specifies numbers with a fixed number of digits in a specific base (e.g., 3-digit base 5)\n    - Need to determine the range (smallest/largest) of base-10 integer values these representations correspond to\n  implementation:\n    - Used in `get_base_range` to compute `min_val` as `base^(num_digits - 1)` and `max_val` as `base^num_digits - 1` for varying digit counts and bases.\n- concept: Base-b Digit Count Formula\n  description: Calculates the number of digits required to represent a positive integer n in base b using the formula floor(log_b(n)) + 1.\n  parameters:\n    - n (type: integer): The positive integer value to be represented.\n    - b (type: integer): The target base for representation (b >= 2).\n  cues:\n    - Calculate the number of digits in a specific base\n    - log_base\n    - floor\n  implementation:\n    - Apply floor(log_b(n)) + 1 to determine the digit count for a given integer n and base b.\n\n## technique\n- concept: GCD Pair Parametrization\n  description: Representing two integers x, y with gcd(x, y) = g as x = g*a, y = g*b where gcd(a, b) = 1 to simplify GCD/LCM constraints.\n  parameters:\n    - gcd_val (type: integer): The known greatest common divisor of the pair\n    - factors (type: pair of integers): The coprime coefficients a and b\n  cues:\n    - Problem involves finding integer pairs with specified GCD/LCM values or constraints linking them (e.g., LCM related to one of the numbers).\n  implementation:\n    - Parametrize integers as x = gcd_val * a, y = gcd_val * b with gcd(a, b) = 1.\n    - Reduce constraints to the product equation a * b = lcm_val / gcd_val.\n- concept: Algebraic Substitution\n  description: Replacing a variable in an equation with an equivalent expression derived from another equation to reduce the system to a single variable.\n  parameters:\n    - target_equation (type: equation): The equation into which substitution is performed\n    - substitution_expression (type: expression): The expression replacing the variable\n    - variable (type: symbol): The variable being eliminated\n  cues:\n    - Systems of equations with shared variables, especially where linear constraints allow easy isolation\n    - Expressions containing matching sub-expressions or derived forms where substitution simplifies structure or utilizes given values\n    - Problems involving ratio-based holdings or distribution expressions\n  implementation:\n    - Substitute isolated variables into other equations to reduce the system to a single variable (e.g., quadratic)\n    - Substitute sub-expressions or definitions into expressions to simplify computation or reveal structure (e.g., prime factorization)\n    - Substitute parameterized ratios into distribution expressions to link quantities to scaling factors"
  },
  "cmath_5403": {
    "hint": "## number theory tool\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: GCD Pair Parametrization\n  description: Representing two integers x, y with gcd(x, y) = g as x = g*a, y = g*b where gcd(a, b) = 1 to simplify GCD/LCM constraints.\n  parameters:\n    - gcd_val (type: integer): The known greatest common divisor of the pair\n    - factors (type: pair of integers): The coprime coefficients a and b\n  cues:\n    - Problem involves finding integer pairs with specified GCD/LCM values or constraints linking them (e.g., LCM related to one of the numbers).\n  implementation:\n    - Parametrize integers as x = gcd_val * a, y = gcd_val * b with gcd(a, b) = 1.\n    - Reduce constraints to the product equation a * b = lcm_val / gcd_val.\n- concept: Valuation Analysis\n  description: Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.\n  parameters:\n    - p (type: prime): The prime base for the valuation.\n    - n (type: integer): The number to analyze for prime valuation.\n  cues:\n    - Equations involving multiplicative operations (LCM, GCD, division) or determining the exact prime power dividing quotients/rational expressions\n    - Constraints or properties applied independently to each prime factor (e.g., perfect powers, divisor counts, exponent divisibility)\n    - Logarithmic equations with integer constraints or base conversion involving primes\n  implementation:\n    - Extract exponents via full prime factorization or specific p-adic valuation calculations (repeated division/subtraction)\n    - Convert constraints (logarithms, perfect powers) into linear equations on exponents, solving for each prime independently before combining results\n- concept: Greedy Prime Exponent Assignment\n  description: To minimize an integer N = product(p_i ^ e_i) given a fixed multiset of exponents, assign the largest exponents to the smallest distinct prime bases.\n  parameters:\n    - exponents (type: list[int]): The multiset of exponents derived from the problem constraints.\n    - prime_sequence (type: list[int]): The ordered sequence of distinct primes (e.g., 2, 3, 5...) to be used as bases.\n  cues:\n    - Problem asks for the minimum integer where the multiset of prime exponents is derived from structural constraints (e.g., divisor count).\n    - The choice of prime bases is flexible (not fixed by the problem).\n  implementation:\n    - Sort derived exponents in descending order and assign them to consecutive primes starting from 2.\n    - Evaluate each valid exponent partition configuration to find the global minimum.\n\n## theorem\n- concept: LCM Valuation Identity\n  description: The p-adic valuation of the least common multiple of two numbers is the maximum of their individual p-adic valuations.\n  cues:\n    - Problem involves LCM or GCD operations\n    - Need to simplify LCM expressions algebraically\n  implementation:\n    - Applied property v_p(lcm(x, y)) = max(v_p(x), v_p(y)) to transform the LCM equation into exponent equations."
  },
  "cmath_5414": {
    "hint": "## algebraic manipulation\n- concept: Base-b Polynomial Representation\n  description: Interpreting a number represented by digits in an unknown base b as a polynomial expression in b, where each digit is a coefficient corresponding to a power of b.\n  parameters:\n    - digits (type: list of integers): The sequence of digits d_n...d_0 representing the number.\n    - base_variable (type: symbol): The variable representing the unknown base (e.g., b).\n  cues:\n    - Problem involves numbers represented by digits in unspecified, variable, or multiple bases using positional notation (e.g., $121_c$ or equations mixing bases).\n    - Problem involves sums of distinct powers of 3 (equivalent to base-3 representation with digits 0 and 1).\n  implementation:\n    - Convert numbers from base-b representation to a polynomial in b (e.g., digits d_n...d_0 map to sum(d_i * b^i)); for sums of distinct powers, treat as base-b polynomials with binary coefficients.\n- concept: Fraction Clearing\n  description: Converting equations with rational coefficients to integer coefficients by multiplying through by the LCM of all denominators\n  cues:\n    - Linear or polynomial equations contain fractions or rational coefficients that need simplification to integer arithmetic\n  implementation:\n    - Multiply the entire equation by the LCM of all denominators to convert rational coefficients to integers (e.g., multiplying M/4 + C/6 = 8 by 12 yields 3M + 2C = 96)\n\n## algorithmic pattern\n- concept: Incremental Search for Minimum\n  description: Iterating integers from a theoretical lower bound upwards to find the smallest value satisfying a predicate, allowing early termination.\n  cues:\n    - Problem asks for the \"smallest\", \"first\", or \"minimum\" integer satisfying a condition within an ordered search space starting from a known lower bound.\n  implementation:\n    - Iterate integers upwards from the theoretical lower bound, checking the condition at each step, and terminate immediately upon finding the first match to guarantee the minimum solution.\n\n## formula\n- concept: base_digit_range_formula\n  description: Determines the minimum and maximum base-10 integer values representable by a number with a specific count of digits in a given base.\n  parameters:\n    - num_digits (type: integer): The number of digits in the representation\n    - base (type: integer): The base of the number system\n  cues:\n    - Problem specifies numbers with a fixed number of digits in a specific base (e.g., 3-digit base 5)\n    - Need to determine the range (smallest/largest) of base-10 integer values these representations correspond to\n  implementation:\n    - Used in `get_base_range` to compute `min_val` as `base^(num_digits - 1)` and `max_val` as `base^num_digits - 1` for varying digit counts and bases.\n\n## number theory tool\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: Valuation Analysis\n  description: Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.\n  parameters:\n    - p (type: prime): The prime base for the valuation.\n    - n (type: integer): The number to analyze for prime valuation.\n  cues:\n    - Equations involving multiplicative operations (LCM, GCD, division) or determining the exact prime power dividing quotients/rational expressions\n    - Constraints or properties applied independently to each prime factor (e.g., perfect powers, divisor counts, exponent divisibility)\n    - Logarithmic equations with integer constraints or base conversion involving primes\n  implementation:\n    - Extract exponents via full prime factorization or specific p-adic valuation calculations (repeated division/subtraction)\n    - Convert constraints (logarithms, perfect powers) into linear equations on exponents, solving for each prime independently before combining results\n- concept: Divisor Enumeration for Integrality\n  description: Solving equations where a rational expression must be an integer by enumerating the divisors of the numerator and solving for the variable in the denominator.\n  parameters:\n    - Numerator (type: Integer): The constant value in the numerator of the fraction.\n    - Denominator Expression (type: Function): The expression involving the variable that forms the denominator.\n  cues:\n    - Finding integer variable values (including negatives) that make a rational expression (constant numerator, variable denominator) evaluate to an integer (implies denominator divides numerator)\n    - Constant numerator is small enough to allow complete divisor enumeration\n  implementation:\n    - Enumerate all integer divisors of the numerator (including negatives), set denominator expression equal to each divisor, solve for the variable, and verify integrality\n    - If optimizing, select the divisor that maximizes or minimizes the result before solving"
  },
  "cmath_5426": {
    "hint": "## algebraic manipulation\n- concept: Base-b Polynomial Representation\n  description: Interpreting a number represented by digits in an unknown base b as a polynomial expression in b, where each digit is a coefficient corresponding to a power of b.\n  parameters:\n    - digits (type: list of integers): The sequence of digits d_n...d_0 representing the number.\n    - base_variable (type: symbol): The variable representing the unknown base (e.g., b).\n  cues:\n    - Problem involves numbers represented by digits in unspecified, variable, or multiple bases using positional notation (e.g., $121_c$ or equations mixing bases).\n    - Problem involves sums of distinct powers of 3 (equivalent to base-3 representation with digits 0 and 1).\n  implementation:\n    - Convert numbers from base-b representation to a polynomial in b (e.g., digits d_n...d_0 map to sum(d_i * b^i)); for sums of distinct powers, treat as base-b polynomials with binary coefficients.\n\n## number theory tool\n- concept: GCD Computation\n  description: Calculating the greatest common divisor of two integers to analyze their divisibility relationship.\n  parameters:\n    - a (type: int): The first integer.\n    - b (type: int): The second integer.\n  cues:\n    - Problem involves common factors, simplification, or divisibility\n    - Explicit mention of gcd or greatest common divisor\n    - reducing fractions to irreducible form\n    - analyzing divisibility relationship\n    - Need to find the common divisor of multiple generated values\n    - Determining the greatest integer satisfying multiple divisibility constraints\n  implementation:\n    - Compute `g = gcd(m, 100)`\n    - Used to reduce probability fraction to irreducible form m/n.\n    - Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)\n\n## technique\n- concept: Fixed Divisor Determination\n  description: Determining the largest integer that divides a polynomial's value for all integer inputs by computing the GCD of the polynomial's values at a sufficient set of sample points.\n  cues:\n    - Problem asks for the largest integer that divides a polynomial's value for all integer inputs\n  implementation:\n    - Evaluate the polynomial at a sufficient set of small integer points and compute the GCD of the resulting values to determine the universal divisor\n\n## theorem\n- concept: Consecutive Integer Coprimality\n  description: Any two consecutive positive integers are relatively prime, i.e., gcd(n, n+1) = 1 for all n \u2265 1.\n  cues:\n    - Problems involving GCD calculations, fractions, or simplification where the numerator and denominator are consecutive integers (differ by 1)\n  implementation:\n    - Establish that n/(n+1) is already in lowest terms (gcd(n, n+1)=1), allowing direct application of properties like the terminating decimal criterion to the denominator"
  },
  "cmath_5439": {
    "hint": "## number theory tool\n- concept: Divisibility Counting Formula\n  description: Calculates the number of multiples of an integer k within the range [1, N] using the floor division formula floor(N / k).\n  parameters:\n    - limit (type: integer): The upper bound of the range (inclusive)\n    - divisor (type: integer): The number whose multiples are being counted\n  cues:\n    - Counting multiples or divisible numbers within a large range [1, N] where enumeration is inefficient (requires floor(N / k))\n  implementation:\n    - Use floor(N / k) to calculate the number of multiples of k in range [1, N]\n    - Apply formula inside loops for dynamic divisors (e.g., powers of a prime)\n    - Extend to inclusion-exclusion by computing counts for individual divisors and their LCM for intersections\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## theorem\n- concept: Terminating Decimal Criterion\n  description: A fraction in lowest terms has a terminating decimal representation if and only if its denominator's prime factorization contains only the primes 2 and 5. Otherwise, the decimal representation is repeating.\n  cues:\n    - Questions about whether a fraction's decimal representation terminates or repeats\n    - Analysis of denominator prime factorization in fraction problems\n  implementation:\n    - Determine if a fraction has a repeating decimal by checking if the denominator (in lowest terms) has prime factors other than 2 or 5\n    - Invert the terminating criterion to count fractions with non-terminating (repeating) decimals"
  },
  "cmath_5442": {
    "hint": "## algebraic manipulation\n- concept: Base-b Polynomial Representation\n  description: Interpreting a number represented by digits in an unknown base b as a polynomial expression in b, where each digit is a coefficient corresponding to a power of b.\n  parameters:\n    - digits (type: list of integers): The sequence of digits d_n...d_0 representing the number.\n    - base_variable (type: symbol): The variable representing the unknown base (e.g., b).\n  cues:\n    - Problem involves numbers represented by digits in unspecified, variable, or multiple bases using positional notation (e.g., $121_c$ or equations mixing bases).\n    - Problem involves sums of distinct powers of 3 (equivalent to base-3 representation with digits 0 and 1).\n  implementation:\n    - Convert numbers from base-b representation to a polynomial in b (e.g., digits d_n...d_0 map to sum(d_i * b^i)); for sums of distinct powers, treat as base-b polynomials with binary coefficients.\n- concept: Equating Coefficients\n  description: Method for solving parameters in an identity by matching the coefficients of corresponding powers of the variable on both sides.\n  cues:\n    - identity in a variable holding for all valid values with unknown parameters in linear or polynomial expressions\n  implementation:\n    - Derive relationships between parameters by matching coefficients of corresponding powers and constant terms on both sides of the identity\n\n## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Integer Base Enumeration\n  description: A search strategy for finding an unknown integer base by iterating through candidate values starting from a valid lower bound and checking for satisfaction of the problem conditions.\n  parameters:\n    - start_value (type: integer): The minimum valid base to start the search from.\n    - condition (type: boolean function): The algebraic equation or logical condition that must evaluate to true.\n  cues:\n    - The unknown variable is a base (implied to be a small integer).\n    - An algebraic equation involving the base has been constructed.\n    - Analytic solution of the polynomial may be difficult or unnecessary.\n  implementation:\n    - Iterate integer b starting from b_min upwards.\n    - Evaluate the equation for each b and return the first where it holds true.\n\n## counting method\n- concept: Constraint-Ordered Counting\n  description: A strategy for constructive counting where variables are assigned values in descending order of constraint strictness. This ensures the number of available choices for subsequent variables remains constant regardless of specific previous choices, avoiding case analysis.\n  cues:\n    - Multiple overlapping constraints creating dependencies (e.g., distinctness, parity, non-zero, strictly increasing)\n    - Need to avoid case splitting by leveraging fixed order for combination logic\n  implementation:\n    - Assign variables in descending order of constraint strictness (e.g., parity, non-zero) to ensure constant option counts, enabling calculation via combinations from the available pool without case analysis\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: Minimum Valid Base Constraint\n  description: A constraint determining the lower bound for a valid base, which must be strictly greater than the largest digit value appearing in the number representations.\n  parameters:\n    - digits (type: set of integers): All unique digits appearing in the numbers within the problem.\n  cues:\n    - The base of the number system is unknown or represented by a variable.\n    - Numbers are expressed in standard positional notation involving specific digit values or distinct digit constraints.\n    - Solutions to equations yield multiple candidates (e.g., quadratic roots) requiring validation against digit constraints.\n  implementation:\n    - Identify the maximum digit value D across all numbers, establish the minimum valid base as max(D + 1, count of unique digits), and filter candidate solutions to satisfy this lower bound.\n\n## technique\n- concept: Algebraic Substitution\n  description: Replacing a variable in an equation with an equivalent expression derived from another equation to reduce the system to a single variable.\n  parameters:\n    - target_equation (type: equation): The equation into which substitution is performed\n    - substitution_expression (type: expression): The expression replacing the variable\n    - variable (type: symbol): The variable being eliminated\n  cues:\n    - Systems of equations with shared variables, especially where linear constraints allow easy isolation\n    - Expressions containing matching sub-expressions or derived forms where substitution simplifies structure or utilizes given values\n    - Problems involving ratio-based holdings or distribution expressions\n  implementation:\n    - Substitute isolated variables into other equations to reduce the system to a single variable (e.g., quadratic)\n    - Substitute sub-expressions or definitions into expressions to simplify computation or reveal structure (e.g., prime factorization)\n    - Substitute parameterized ratios into distribution expressions to link quantities to scaling factors"
  },
  "cmath_8695": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n\n## number theory tool\n- concept: Divisor Enumeration\n  description: Computing the complete set of positive divisors for a given integer to identify candidate values satisfying divisibility conditions.\n  parameters:\n    - n (type: Integer): The integer to find divisors for\n    - target_number (type: integer): The integer whose divisors are being computed\n  cues:\n    - Problem involves divisibility constraints or checking if k divides N.\n    - Search space or conditions require finding all divisors or specific subsets (e.g., proper divisors) of a specific or derived integer.\n  implementation:\n    - Iterate from 1 to sqrt(N) to construct the set of all positive divisors of the target integer by checking divisibility.\n    - Filter divisors to exclude 1 and n if proper divisors are required.\n\n## technique\n- concept: Graph Modeling\n  description: Translating a problem involving entities and pairwise relationships into a graph structure (vertices and edges) to leverage graph theoretic tools.\n  parameters:\n    - entities (type: set): The objects to be represented as vertices.\n    - relationships (type: set of pairs): The interactions to be represented as edges.\n  cues:\n    - handshakes\n    - network structure or pairwise relationships between entities\n  implementation:\n    - Model entities as Vertices V and relationships as Edges in Graph G"
  },
  "cmath_8980": {
    "hint": "## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n- concept: Complementary Counting\n  description: Determining the count of elements satisfying a property by subtracting the count of elements that do not satisfy it from the total count.\n  parameters:\n    - total (type: integer): The total number of possibilities including invalid cases.\n    - excluded (type: integer): The number of invalid or unwanted possibilities to subtract.\n    - total_count (type: integer): The total number of elements in the universal set.\n    - complement_count (type: integer): The number of elements satisfying the negation of the target condition.\n  cues:\n    - Problem asks for \"at least one\", \"non-empty\", or \"not all\", or involves phrases like \"none\", \"never\", or \"all distinct\".\n    - Direct counting involves complex casework, but counting the complement is simpler.\n    - Total set size is easily determined.\n  implementation:\n    - Calculate result by subtracting the complement count from the total count.\n    - Subtract 1 from total_combinations to remove the empty selection case."
  },
  "cmath_9002": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## counting method\n- concept: Multiplication Principle\n  description: Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.\n  parameters:\n    - option_counts (type: list of integers): The number of available choices for each independent decision point.\n  cues:\n    - Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).\n    - Linguistic cues like 'for each...' indicating iteration over choices.\n  implementation:\n    - Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.\n    - Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication.\n\n## technique\n- concept: Set Partition Counting\n  description: Modeling distribution problems where items are distinguishable and bins are indistinguishable as set partition problems.\n  cues:\n    - distinct elements\n    - identical containers\n  implementation:\n    - The initial conditional check identifies this scenario to apply partition counting formulas"
  },
  "cmath_10646": {
    "hint": "## algorithmic pattern\n- concept: Incremental Search for Minimum\n  description: Iterating integers from a theoretical lower bound upwards to find the smallest value satisfying a predicate, allowing early termination.\n  cues:\n    - Problem asks for the \"smallest\", \"first\", or \"minimum\" integer satisfying a condition within an ordered search space starting from a known lower bound.\n  implementation:\n    - Iterate integers upwards from the theoretical lower bound, checking the condition at each step, and terminate immediately upon finding the first match to guarantee the minimum solution.\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: GCD Computation\n  description: Calculating the greatest common divisor of two integers to analyze their divisibility relationship.\n  parameters:\n    - a (type: int): The first integer.\n    - b (type: int): The second integer.\n  cues:\n    - Problem involves common factors, simplification, or divisibility\n    - Explicit mention of gcd or greatest common divisor\n    - reducing fractions to irreducible form\n    - analyzing divisibility relationship\n    - Need to find the common divisor of multiple generated values\n    - Determining the greatest integer satisfying multiple divisibility constraints\n  implementation:\n    - Compute `g = gcd(m, 100)`\n    - Used to reduce probability fraction to irreducible form m/n.\n    - Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: Valuation Analysis\n  description: Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.\n  parameters:\n    - p (type: prime): The prime base for the valuation.\n    - n (type: integer): The number to analyze for prime valuation.\n  cues:\n    - Equations involving multiplicative operations (LCM, GCD, division) or determining the exact prime power dividing quotients/rational expressions\n    - Constraints or properties applied independently to each prime factor (e.g., perfect powers, divisor counts, exponent divisibility)\n    - Logarithmic equations with integer constraints or base conversion involving primes\n  implementation:\n    - Extract exponents via full prime factorization or specific p-adic valuation calculations (repeated division/subtraction)\n    - Convert constraints (logarithms, perfect powers) into linear equations on exponents, solving for each prime independently before combining results"
  },
  "cmath_4843": {
    "hint": "## algebraic manipulation\n- concept: Base-b Polynomial Representation\n  description: Interpreting a number represented by digits in an unknown base b as a polynomial expression in b, where each digit is a coefficient corresponding to a power of b.\n  parameters:\n    - digits (type: list of integers): The sequence of digits d_n...d_0 representing the number.\n    - base_variable (type: symbol): The variable representing the unknown base (e.g., b).\n  cues:\n    - Problem involves numbers represented by digits in unspecified, variable, or multiple bases using positional notation (e.g., $121_c$ or equations mixing bases).\n    - Problem involves sums of distinct powers of 3 (equivalent to base-3 representation with digits 0 and 1).\n  implementation:\n    - Convert numbers from base-b representation to a polynomial in b (e.g., digits d_n...d_0 map to sum(d_i * b^i)); for sums of distinct powers, treat as base-b polynomials with binary coefficients.\n\n## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Reverse Search for Maximum\n  description: Iterating from the theoretical upper bound downwards to find the largest value satisfying a predicate, allowing early termination.\n  parameters:\n    - start_val (type: integer): The maximum possible value to start searching from\n    - condition (type: predicate function): The boolean condition that the value must satisfy\n  cues:\n    - Objective is to find the largest discrete value satisfying a condition\n    - Search space consists of bounded, ordered discrete candidates\n    - Existence of a calculable theoretical upper bound\n    - Validity check is computationally feasible\n  implementation:\n    - Compute starting value as floor(upper_bound / divisor) to establish search start\n    - Iterate candidates from maximum possible value downwards\n    - Return immediately upon finding the first valid candidate\n- concept: Constructive Enumeration\n  description: Generates valid instances by composing fundamental building blocks (e.g., primes) according to structural rules instead of brute-force checking.\n  parameters:\n    - primitives (type: list): Fundamental elements to build from (e.g., list of primes)\n    - construction_rules (type: list): Mathematical forms to apply to primitives (e.g., p^3, p*q)\n  cues:\n    - Search space consists of discrete structural configurations (e.g., partitions, subsets) or sequences rather than a numeric range, requiring generation via structural rules or primitives.\n    - Objective is to find an optimal value (min/max) or smallest k numbers with a property among valid configurations.\n  implementation:\n    - Generate candidates by composing primitives (e.g., primes) or iterating structural configurations (e.g., partitions, subsets, recurrence sequences).\n    - Iterate through generated candidates to compute derived values and identify the optimal result.\n\n## counting method\n- concept: Positional Digit Counting\n  description: Counting integers satisfying digit-level constraints by multiplying the number of valid choices for each digit position (Hundreds, Tens, Units, etc.).\n  parameters:\n    - positions (type: list): The digit positions to fill (e.g., [100, 10, 1]).\n    - constraints (type: list): Rules restricting valid digits at each position (e.g., distinctness, range bounds).\n  cues:\n    - Counting integers with fixed digit length or base b representation (e.g., Hundreds, Tens, Units)\n    - Digit-level constraints (parity, leading zero, specific values) or dependencies between positions (e.g., distinctness)\n  implementation:\n    - Decompose the number into positional components (e.g., Hundreds, Tens, Units or base b positions)\n    - Calculate valid digit choices for each position, adjusting for dependencies like distinctness based on previous selections, and apply the multiplication principle to compute total count\n- concept: Constraint-Ordered Counting\n  description: A strategy for constructive counting where variables are assigned values in descending order of constraint strictness. This ensures the number of available choices for subsequent variables remains constant regardless of specific previous choices, avoiding case analysis.\n  cues:\n    - Multiple overlapping constraints creating dependencies (e.g., distinctness, parity, non-zero, strictly increasing)\n    - Need to avoid case splitting by leveraging fixed order for combination logic\n  implementation:\n    - Assign variables in descending order of constraint strictness (e.g., parity, non-zero) to ensure constant option counts, enabling calculation via combinations from the available pool without case analysis"
  },
  "cmath_5273": {
    "hint": "## algebraic manipulation\n- concept: Base-b Polynomial Representation\n  description: Interpreting a number represented by digits in an unknown base b as a polynomial expression in b, where each digit is a coefficient corresponding to a power of b.\n  parameters:\n    - digits (type: list of integers): The sequence of digits d_n...d_0 representing the number.\n    - base_variable (type: symbol): The variable representing the unknown base (e.g., b).\n  cues:\n    - Problem involves numbers represented by digits in unspecified, variable, or multiple bases using positional notation (e.g., $121_c$ or equations mixing bases).\n    - Problem involves sums of distinct powers of 3 (equivalent to base-3 representation with digits 0 and 1).\n  implementation:\n    - Convert numbers from base-b representation to a polynomial in b (e.g., digits d_n...d_0 map to sum(d_i * b^i)); for sums of distinct powers, treat as base-b polynomials with binary coefficients.\n\n## algorithmic pattern\n- concept: Set Deduplication\n  description: Using a set data structure to store results of a transformation to automatically filter duplicates, useful for identifying distinct outcomes.\n  parameters:\n    - values (type: iterable): The sequence of values to deduplicate\n  cues:\n    - Goal is to count the number of *unique* or *distinct* outcomes.\n    - Multiple different inputs may produce the same output value.\n  implementation:\n    - Initialize an empty set to store unique outcomes.\n    - Compute the value for each input and insert into the set to automatically filter duplicates.\n    - Return the cardinality of the set as the final answer.\n\n## counting method\n- concept: Positional Digit Counting\n  description: Counting integers satisfying digit-level constraints by multiplying the number of valid choices for each digit position (Hundreds, Tens, Units, etc.).\n  parameters:\n    - positions (type: list): The digit positions to fill (e.g., [100, 10, 1]).\n    - constraints (type: list): Rules restricting valid digits at each position (e.g., distinctness, range bounds).\n  cues:\n    - Counting integers with fixed digit length or base b representation (e.g., Hundreds, Tens, Units)\n    - Digit-level constraints (parity, leading zero, specific values) or dependencies between positions (e.g., distinctness)\n  implementation:\n    - Decompose the number into positional components (e.g., Hundreds, Tens, Units or base b positions)\n    - Calculate valid digit choices for each position, adjusting for dependencies like distinctness based on previous selections, and apply the multiplication principle to compute total count\n\n## formula\n- concept: Range Cardinality\n  description: Computes the number of integers in an inclusive interval [min, max] using the formula max - min + 1.\n  parameters:\n    - range_min (type: integer): The lower bound of the inclusive range.\n    - range_max (type: integer): The upper bound of the inclusive range.\n  cues:\n    - Problem asks for the count of integers within a specific inclusive interval.\n    - Bounds are given as explicit integers (often non-negative).\n    - Counting valid parameter values within a range.\n  implementation:\n    - Compute the count of integers in an inclusive range [min, max] using the formula `max - min + 1` (simplifies to `max + 1` if min is 0).\n    - Use this calculation to establish the universe size for complementary counting."
  },
  "cmath_5315": {
    "hint": "## algorithmic pattern\n- concept: Iterative Accumulation\n  description: Accumulating a result by iterating through a sequence of values and updating a running total\n  parameters:\n    - sequence (type: list): The collection of values to iterate over.\n    - accumulator (type: variable): The variable storing the running sum or product\n    - start (type: integer): Starting value of the loop counter\n    - end (type: integer): Ending value of the loop counter\n    - update_rule (type: function): The function applied to the current element to update the sum\n    - operation (type: function): The transformation applied to each element before accumulation.\n  cues:\n    - Problem asks for an aggregate value (sum, product, count, digit sums) derived from a sequence, range, or enumerated items.\n    - Solution involves a loop iterating through a collection (list, range, or components like prime factors) where a running total or product variable is updated in each iteration.\n    - Aggregating results from multiple independent choices or cases (e.g., combinatorial products, inclusion-exclusion terms).\n    - Building a frequency map, histogram, or global metric by sequentially processing input data.\n  implementation:\n    - Initialize an accumulator variable to the identity value (0 for sums, 1 for products).\n    - Iterate through the sequence (range of integers, list of items, or prime factors).\n    - In each iteration, compute the contribution based on the current element and update the accumulator using the appropriate operation (addition, multiplication, modular arithmetic).\n    - If applicable, apply conditions before updating (e.g., only add if a value is valid/integer).\n    - Return the final accumulated value after the loop completes.\n- concept: Incremental Search for Minimum\n  description: Iterating integers from a theoretical lower bound upwards to find the smallest value satisfying a predicate, allowing early termination.\n  cues:\n    - Problem asks for the \"smallest\", \"first\", or \"minimum\" integer satisfying a condition within an ordered search space starting from a known lower bound.\n  implementation:\n    - Iterate integers upwards from the theoretical lower bound, checking the condition at each step, and terminate immediately upon finding the first match to guarantee the minimum solution.\n\n## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n\n## technique\n- concept: Linear Congruence Resolution\n  description: Solves a linear congruence equation ax \u2261 b (mod m) by reducing coefficients via GCD and computing the modular inverse to isolate x.\n  parameters:\n    - coeff (type: integer): The coefficient 'a' of the variable x.\n    - constant (type: integer): The constant term 'b' on the RHS.\n    - modulus (type: integer): The modulus 'm'.\n  cues:\n    - Linear congruence equation ax \u2261 b (mod m) requiring isolation of x.\n  implementation:\n    - Reduced equation by dividing coeff, constant, and modulus by g = GCD(coeff, modulus).\n    - Computed modular inverse of reduced coefficient to find the residue.\n\n## theorem\n- concept: Chinese Remainder Theorem\n  description: Constructs a unique solution modulo the product of moduli for a system of linear congruences with pairwise coprime moduli.\n  parameters:\n    - congruences (type: list of tuples): List of (residue, modulus) pairs representing x \u2261 residue (mod modulus).\n  cues:\n    - System of multiple modular congruences.\n    - Moduli are pairwise coprime.\n    - Need to find a single integer satisfying all conditions.\n  implementation:\n    - Computed M_total as the product of all reduced moduli.\n    - Iterated through each congruence to compute partial terms (N_i * y_i * residue).\n    - Summed partial terms modulo M_total to find the base solution x_0.\n- concept: Difference of Squares Characterization\n  description: An integer n can be expressed as the difference of two squares (a^2 - b^2) if and only if n is not congruent to 2 modulo 4. This arises because factors (a+b) and (a-b) must have the same parity.\n  parameters:\n    - n (type: integer): The integer to test for representability as a difference of squares.\n  cues:\n    - Problem involves expressing numbers as a^2 - b^2.\n    - Constraints on parity or modulo 4 appear in the problem statement or derivation.\n    - Need to filter integers based on arithmetic properties rather than brute force.\n  implementation:\n    - Use the identity n = (a+b)(a-b) to deduce that factors must share parity (both odd or both even).\n    - Conclude that n cannot be congruent to 2 (mod 4), as this is the only case where factors would have differing parity.\n    - Filter out integers satisfying k \u2261 2 (mod 4) to identify valid candidates."
  },
  "cmath_5331": {
    "hint": "## algebraic manipulation\n- concept: Logarithmic Exponent Isolation\n  description: Solving for an exponent variable in an exponential inequality by applying logarithms to both sides.\n  parameters:\n    - base (type: float): The base of the exponential term.\n    - target (type: float): The value the exponential term is compared against.\n  cues:\n    - variable in exponent\n    - exponential inequality\n    - base < 1\n  implementation:\n    - Step 3 solves n using log(max_allowed) / log(p_failure).\n\n## technique\n- concept: Algebraic Substitution\n  description: Replacing a variable in an equation with an equivalent expression derived from another equation to reduce the system to a single variable.\n  parameters:\n    - target_equation (type: equation): The equation into which substitution is performed\n    - substitution_expression (type: expression): The expression replacing the variable\n    - variable (type: symbol): The variable being eliminated\n  cues:\n    - Systems of equations with shared variables, especially where linear constraints allow easy isolation\n    - Expressions containing matching sub-expressions or derived forms where substitution simplifies structure or utilizes given values\n    - Problems involving ratio-based holdings or distribution expressions\n  implementation:\n    - Substitute isolated variables into other equations to reduce the system to a single variable (e.g., quadratic)\n    - Substitute sub-expressions or definitions into expressions to simplify computation or reveal structure (e.g., prime factorization)\n    - Substitute parameterized ratios into distribution expressions to link quantities to scaling factors\n- concept: Exponential Growth Bounding\n  description: Limiting the search space for variables in exponential equations by observing that terms grow rapidly relative to the constant value, ensuring the search space is finite and small.\n  parameters:\n    - exponential_terms (type: list of expressions): The terms containing variables in exponents\n    - constant (type: integer): The target value the terms sum to or differ by\n  cues:\n    - Variables appear in exponents in an equation equal to a small constant\n  implementation:\n    - Determining bounds for x and y such that 2^(2x) and 3^(2y) do not excessively exceed 55 before starting iteration"
  },
  "cmath_5336": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## calculation method\n- concept: Summation of Distinct Values\n  description: Calculating the arithmetic sum of all unique values in a collection.\n  parameters:\n    - distinct_values (type: set): The set of unique numbers to sum\n  cues:\n    - Problem asks for the sum of all distinct/unique valid solutions or outcomes.\n    - Collected numbers are distinct by virtue of the search process.\n  implementation:\n    - Compute the final answer as the arithmetic sum of all elements in the collected set of valid values, typically by iterating and accumulating into a total sum variable.\n\n## technique\n- concept: Divisor Enumeration for Integrality\n  description: Solving equations where a rational expression must be an integer by enumerating the divisors of the numerator and solving for the variable in the denominator.\n  parameters:\n    - Numerator (type: Integer): The constant value in the numerator of the fraction.\n    - Denominator Expression (type: Function): The expression involving the variable that forms the denominator.\n  cues:\n    - Finding integer variable values (including negatives) that make a rational expression (constant numerator, variable denominator) evaluate to an integer (implies denominator divides numerator)\n    - Constant numerator is small enough to allow complete divisor enumeration\n  implementation:\n    - Enumerate all integer divisors of the numerator (including negatives), set denominator expression equal to each divisor, solve for the variable, and verify integrality\n    - If optimizing, select the divisor that maximizes or minimizes the result before solving\n- concept: Algebraic Substitution\n  description: Replacing a variable in an equation with an equivalent expression derived from another equation to reduce the system to a single variable.\n  parameters:\n    - target_equation (type: equation): The equation into which substitution is performed\n    - substitution_expression (type: expression): The expression replacing the variable\n    - variable (type: symbol): The variable being eliminated\n  cues:\n    - Systems of equations with shared variables, especially where linear constraints allow easy isolation\n    - Expressions containing matching sub-expressions or derived forms where substitution simplifies structure or utilizes given values\n    - Problems involving ratio-based holdings or distribution expressions\n  implementation:\n    - Substitute isolated variables into other equations to reduce the system to a single variable (e.g., quadratic)\n    - Substitute sub-expressions or definitions into expressions to simplify computation or reveal structure (e.g., prime factorization)\n    - Substitute parameterized ratios into distribution expressions to link quantities to scaling factors"
  },
  "cmath_5354": {
    "hint": "## formula\n- concept: Divisor Counting Formula\n  description: Computes the total number of positive divisors of an integer given its prime factorization exponents using the product of (exponent + 1).\n  cues:\n    - Problem asks for the count of divisors and prime factorization (or its exponents) is available or computable\n  implementation:\n    - Calculate the total number of divisors as the product of (exponent + 1) for each prime factor in the factorization\n\n## number theory tool\n- concept: Coprimality Check\n  description: Verifying two numbers are relatively prime by checking if their greatest common divisor is 1.\n  parameters:\n    - num1 (type: integer): First integer\n    - num2 (type: integer): Second integer\n  cues:\n    - Constraint explicitly requires gcd(a, b) = 1 or gcd(x, n) == 1\n    - Requirement for a modular inverse to exist or justification for division in congruences\n    - Problem involves reduced fractions, canonical representation, or numerators coprime to denominators\n    - Conditions requiring adjacent elements, derived variables, or factor pairs to be relatively prime\n    - Application of Euler's Totient Theorem\n  implementation:\n    - Check `if gcd(a, m) == 1` to validate precondition for modular inverse or division, returning error if failed\n    - Iterate through candidates, pairs, or residue systems, computing gcd to filter non-coprime elements or ensure coprimality (e.g., numerators/denominators)\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## theorem\n- concept: Terminating Decimal Criterion\n  description: A fraction in lowest terms has a terminating decimal representation if and only if its denominator's prime factorization contains only the primes 2 and 5. Otherwise, the decimal representation is repeating.\n  cues:\n    - Questions about whether a fraction's decimal representation terminates or repeats\n    - Analysis of denominator prime factorization in fraction problems\n  implementation:\n    - Determine if a fraction has a repeating decimal by checking if the denominator (in lowest terms) has prime factors other than 2 or 5\n    - Invert the terminating criterion to count fractions with non-terminating (repeating) decimals\n- concept: Difference of Squares Characterization\n  description: An integer n can be expressed as the difference of two squares (a^2 - b^2) if and only if n is not congruent to 2 modulo 4. This arises because factors (a+b) and (a-b) must have the same parity.\n  parameters:\n    - n (type: integer): The integer to test for representability as a difference of squares.\n  cues:\n    - Problem involves expressing numbers as a^2 - b^2.\n    - Constraints on parity or modulo 4 appear in the problem statement or derivation.\n    - Need to filter integers based on arithmetic properties rather than brute force.\n  implementation:\n    - Use the identity n = (a+b)(a-b) to deduce that factors must share parity (both odd or both even).\n    - Conclude that n cannot be congruent to 2 (mod 4), as this is the only case where factors would have differing parity.\n    - Filter out integers satisfying k \u2261 2 (mod 4) to identify valid candidates."
  },
  "cmath_5091": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## counting method\n- concept: Conditional Counting\n  description: Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.\n  parameters:\n    - predicate (type: boolean function): The condition elements must satisfy to be counted\n    - initial_value (type: int): The starting value of the counter.\n    - domain (type: set): The set of elements to iterate over\n  cues:\n    - Problem asks for the total number of elements or configurations satisfying specific properties or constraints\n    - Solution involves accumulating a count using a counter variable and conditional checks inside an iteration\n  implementation:\n    - Initialize a counter variable to 0 before iterating through the domain of candidates\n    - Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met\n    - Return the final accumulated count after iteration completes\n\n## number theory tool\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: Proper Divisor Product Relation\n  description: Relates the product of proper divisors to the product of all divisors by dividing by the number itself.\n  cues:\n    - proper divisors\n    - product excluding the number itself\n    - adjustment of divisor product\n  implementation:\n    - Applied in Step 2 to adjust the exponent from x/2 to (x-2)/2 by dividing by n\n\n## theorem\n- concept: Product of Divisors Formula\n  description: The product of all positive divisors of an integer n is n raised to the power of half the count of its divisors.\n  parameters:\n    - n (type: integer): The number whose divisors are being multiplied\n    - x (type: integer): The total count of divisors of n\n  cues:\n    - product of divisors\n    - divisor count\n    - exponent involving divisor count\n  implementation:\n    - Used to establish the initial exponent x/2 for the product of all divisors in Step 1\n- concept: Divisor Count Structure\n  description: Characterizes the prime factorization form of an integer based on its total number of divisors using the divisor function formula tau(n).\n  parameters:\n    - target_divisors (type: integer): The exact number of divisors the integer must have\n  cues:\n    - Problem specifies an exact count of divisors (total or restricted) and requires determining the number's prime factorization structure (exponents).\n  implementation:\n    - Apply the relation tau(N) = product(e_i + 1) to derive prime exponents from the target divisor count (e.g., 3 factors implies p^2, 4 factors implies p^3 or p*q).\n    - If given a restricted divisor count (excluding 1 and N), infer the total divisor count D by adding 2.\n    - Validate that candidate numbers constructed from the derived exponents satisfy the original divisor count requirement."
  },
  "cmath_5347": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## number theory tool\n- concept: GCD Computation\n  description: Calculating the greatest common divisor of two integers to analyze their divisibility relationship.\n  parameters:\n    - a (type: int): The first integer.\n    - b (type: int): The second integer.\n  cues:\n    - Problem involves common factors, simplification, or divisibility\n    - Explicit mention of gcd or greatest common divisor\n    - reducing fractions to irreducible form\n    - analyzing divisibility relationship\n    - Need to find the common divisor of multiple generated values\n    - Determining the greatest integer satisfying multiple divisibility constraints\n  implementation:\n    - Compute `g = gcd(m, 100)`\n    - Used to reduce probability fraction to irreducible form m/n.\n    - Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)\n\n## technique\n- concept: Algebraic Substitution\n  description: Replacing a variable in an equation with an equivalent expression derived from another equation to reduce the system to a single variable.\n  parameters:\n    - target_equation (type: equation): The equation into which substitution is performed\n    - substitution_expression (type: expression): The expression replacing the variable\n    - variable (type: symbol): The variable being eliminated\n  cues:\n    - Systems of equations with shared variables, especially where linear constraints allow easy isolation\n    - Expressions containing matching sub-expressions or derived forms where substitution simplifies structure or utilizes given values\n    - Problems involving ratio-based holdings or distribution expressions\n  implementation:\n    - Substitute isolated variables into other equations to reduce the system to a single variable (e.g., quadratic)\n    - Substitute sub-expressions or definitions into expressions to simplify computation or reveal structure (e.g., prime factorization)\n    - Substitute parameterized ratios into distribution expressions to link quantities to scaling factors\n- concept: Odd Integer Parametrization\n  description: Representing positive odd integers x as 2y + 1 where y >= 0 to transform constraints into standard non-negative integer forms suitable for combinatorial methods.\n  parameters:\n    - count (type: integer): The number of odd integers to generate.\n    - start (type: integer): The starting odd integer (default 1).\n  cues:\n    - positive odd integers or sequences of odd numbers\n    - sum of odd numbers with parity constraints\n    - variables in the form 2k + 1\n  implementation:\n    - Substitute x_i = 2*y_i + 1 to transform the sum equation into 2 * sum(y_i) + k = S, converting constraints to standard non-negative integer forms.\n    - {'Generate sequences of odd integers (e.g., first 100 odds': '1, 3, ..., 199) to define the domain for valuation or summation.'}\n- concept: Fixed Divisor Determination\n  description: Determining the largest integer that divides a polynomial's value for all integer inputs by computing the GCD of the polynomial's values at a sufficient set of sample points.\n  cues:\n    - Problem asks for the largest integer that divides a polynomial's value for all integer inputs\n  implementation:\n    - Evaluate the polynomial at a sufficient set of small integer points and compute the GCD of the resulting values to determine the universal divisor"
  },
  "cmath_4749": {
    "hint": "## number theory tool\n- concept: Modular Arithmetic\n  description: Performing arithmetic operations within a fixed range defined by a modulus\n  parameters:\n    - modulus (type: integer): The prime number p defining the field Z_p\n  cues:\n    - Problems involving remainders, divisibility, congruence relations (\u2261), specific digits (e.g., units digit), or constraints defined modulo n\n    - Large numbers, exponents, or integers where direct computation is infeasible without modular reduction\n    - Requirement to compute, validate, or utilize modular inverses (division in modular field)\n    - Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)\n    - Observation of cyclic patterns in values, powers, or sequences\n  implementation:\n    - Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations\n    - Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)\n    - Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0\n    - Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks\n- concept: GCD Computation\n  description: Calculating the greatest common divisor of two integers to analyze their divisibility relationship.\n  parameters:\n    - a (type: int): The first integer.\n    - b (type: int): The second integer.\n  cues:\n    - Problem involves common factors, simplification, or divisibility\n    - Explicit mention of gcd or greatest common divisor\n    - reducing fractions to irreducible form\n    - analyzing divisibility relationship\n    - Need to find the common divisor of multiple generated values\n    - Determining the greatest integer satisfying multiple divisibility constraints\n  implementation:\n    - Compute `g = gcd(m, 100)`\n    - Used to reduce probability fraction to irreducible form m/n.\n    - Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)\n- concept: Divisibility Substitution\n  description: Replacing variables with parameterized forms based on known divisibility constraints (e.g., if x must be divisible by k, set x = k\u00b7t for integer t)\n  parameters:\n    - variable (type: symbol): The original variable subject to divisibility constraint\n    - divisor (type: integer): The known divisor that the variable must be a multiple of\n    - parameter (type: symbol): The new integer parameter representing the quotient\n  cues:\n    - Variable constrained by divisibility, congruences, or multiple conditions (e.g., multiple of k or mk + r)\n    - Problem involves partitioning or grouping with fixed sizes\n    - Need to reduce search space using structural constraints or density reduction\n    - Counting divisors subject to a multiple constraint (e.g., divisors of N that are multiples of k)\n    - Problem involves ratios, proportional holdings, or a common scaling factor\n  implementation:\n    - Substitute variables with divisor multiples or congruence forms (e.g., M = 8m or r = a + m\u00b7k) to simplify equations and reduce coefficients\n    - Substitute divisor d = k\u00b7m to transform 'd divides N and k divides d' into counting divisors of N/k\n    - Introduce a scaling factor k to represent proportional values (e.g., 3k, 4k, 5k) based on given ratios to facilitate equation formulation\n    - Define candidates as n * multiplier to reduce search space from limit values to limit/multiplier values\n\n## technique\n- concept: Polynomial Divisibility Reduction\n  description: Transforms a divisibility condition where a linear polynomial divides another polynomial into a constant divisibility condition using the Polynomial Remainder Theorem.\n  parameters:\n    - polynomial (type: expression): The polynomial expression P(n) being divided.\n    - linear_divisor (type: expression): The linear expression L(n) that divides P(n).\n    - variable (type: symbol): The variable n common to both expressions.\n  cues:\n    - Divisibility constraint involving a polynomial and a linear term in the same variable.\n    - Need to find integer values of the variable satisfying the condition.\n  implementation:\n    - Evaluate the polynomial at the root of the linear divisor to find the remainder.\n    - Reduce the condition to the linear divisor dividing the remainder."
  },
  "cmath_5327": {
    "hint": "## algorithm\n- concept: Direct Enumeration\n  description: Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.\n  parameters:\n    - start (type: int): The starting integer of the range.\n    - end (type: int): The ending integer of the range.\n    - operation (type: function): The logic applied to each element in the range.\n    - search_variable (type: integer): The variable being incremented to search for a solution\n    - start_value (type: integer): The initial value for the search variable\n    - search_space (type: set or sequence): The finite set of candidates to enumerate.\n  cues:\n    - Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)\n    - Problem specifies a concrete range of integers or bounded variables to analyze\n    - Requirement to verify a condition, property, or constraint for every candidate in the space\n    - Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions\n    - No closed-form solution or formula is immediately apparent\n    - Search space involves permutations, combinations, or configurations of small sets\n    - Constraints reduce degrees of freedom allowing enumeration of remaining variables\n  implementation:\n    - Define the finite search space (ranges, permutations, lists, or bounded variables)\n    - Construct loops to iterate through every candidate in the search space\n    - Evaluate the specific condition or constraint for each candidate element\n    - Terminate early if only the first, smallest, or specific count of solutions is required\n    - Aggregate results, store valid configurations, or compute values based on valid candidates\n    - Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration\n\n## algorithmic pattern\n- concept: Incremental Search for Minimum\n  description: Iterating integers from a theoretical lower bound upwards to find the smallest value satisfying a predicate, allowing early termination.\n  cues:\n    - Problem asks for the \"smallest\", \"first\", or \"minimum\" integer satisfying a condition within an ordered search space starting from a known lower bound.\n  implementation:\n    - Iterate integers upwards from the theoretical lower bound, checking the condition at each step, and terminate immediately upon finding the first match to guarantee the minimum solution.\n\n## number theory tool\n- concept: GCD Computation\n  description: Calculating the greatest common divisor of two integers to analyze their divisibility relationship.\n  parameters:\n    - a (type: int): The first integer.\n    - b (type: int): The second integer.\n  cues:\n    - Problem involves common factors, simplification, or divisibility\n    - Explicit mention of gcd or greatest common divisor\n    - reducing fractions to irreducible form\n    - analyzing divisibility relationship\n    - Need to find the common divisor of multiple generated values\n    - Determining the greatest integer satisfying multiple divisibility constraints\n  implementation:\n    - Compute `g = gcd(m, 100)`\n    - Used to reduce probability fraction to irreducible form m/n.\n    - Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)\n- concept: LCM Intersection Property\n  description: The set of integers divisible by both a and b is identical to the set of integers divisible by lcm(a, b), allowing intersection counts to be computed via the LCM.\n  parameters:\n    - divisor_a (type: integer): First divisor\n    - divisor_b (type: integer): Second divisor\n    - lcm_value (type: integer): Precomputed LCM of divisor_a and divisor_b\n  cues:\n    - two simultaneous divisibility conditions\n    - finding common multiples\n    - intersection of divisibility sets\n  implementation:\n    - count_intersection <- FLOOR(total_items / lcm_divisor)\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)"
  },
  "cmath_2103": {
    "hint": "## algebraic manipulation\n- concept: Perfect Square Factorization\n  description: Recognizing and factoring a quadratic polynomial as the square of a binomial (e.g., $x^2 + 2x + 1 = (x+1)^2$) to simplify equations.\n  parameters:\n    - polynomial (type: expression): The quadratic expression to be factored\n    - variable (type: symbol): The variable with respect to which the square is formed\n  cues:\n    - Quadratic expressions with coefficients forming a perfect square pattern (e.g., 1, 2, 1)\n    - Equations involving squares of variables on both sides\n  implementation:\n    - Factor the quadratic expression into a squared binomial (e.g., $c^2 + 2c + 1 = (c+1)^2$) and simplify equations by taking the square root of both sides to derive linear relations.\n- concept: Fraction Clearing\n  description: Converting equations with rational coefficients to integer coefficients by multiplying through by the LCM of all denominators\n  cues:\n    - Linear or polynomial equations contain fractions or rational coefficients that need simplification to integer arithmetic\n  implementation:\n    - Multiply the entire equation by the LCM of all denominators to convert rational coefficients to integers (e.g., multiplying M/4 + C/6 = 8 by 12 yields 3M + 2C = 96)\n\n## number theory tool\n- concept: Prime Factorization\n  description: Decomposing an integer into a product of prime powers to analyze its arithmetic properties.\n  cues:\n    - Need to decompose a composite integer into prime powers\n    - Analyzing multiplicative functions (e.g., divisor counting or summing)\n    - GCD/LCM calculations\n    - Factors of 10 (2 * 5) or trailing zeros\n  implementation:\n    - Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)\n    - Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)\n\n## technique\n- concept: Probability as Ratio of Counts\n  description: Calculating the probability of an event in a uniform sample space by dividing the count of favorable outcomes by the count of total possible outcomes.\n  parameters:\n    - favorable_count (type: integer): The number of outcomes satisfying the specific condition.\n    - total_count (type: integer): The total number of possible outcomes in the sample space.\n  cues:\n    - problem asks for probability of an event, arrangement, or configuration\n    - discrete uniform sample space implied\n    - ratio of favorable to total outcomes\n  implementation:\n    - DERIVE probability = favorable_outcomes / total_outcomes\n    - SIMPLIFY probability to lowest terms m/n\n\n## theorem\n- concept: Complementary Probability\n  description: Calculates the probability of an event occurring at least once by subtracting the probability of it never occurring from 1.\n  parameters:\n    - p_event (type: float): Probability of the event occurring in a single trial.\n  cues:\n    - at least one success\n    - target probability\n    - minimum trials\n  implementation:\n    - Step 1 converts target success probability to max allowed failure probability using 1 - p_success.\n- concept: Independent Event Probability Product\n  description: The probability of multiple independent events all occurring is the product of their individual probabilities.\n  parameters:\n    - probabilities (type: list of float): List of probabilities for each independent event.\n  cues:\n    - independent trials\n    - repeated experiments\n    - all failures\n  implementation:\n    - Step 2 models P(all failures) as (p_failure)^n."
  }
}
