{
  "concepts": {
    "GCD Pair Parametrization": {
      "name": "GCD Pair Parametrization",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "gcd_val",
          "typing": "integer",
          "description": "The known greatest common divisor of the pair"
        },
        {
          "name": "factors",
          "typing": "pair of integers",
          "description": "The coprime coefficients a and b"
        }
      ],
      "description": "Representing two integers x, y with gcd(x, y) = g as x = g*a, y = g*b where gcd(a, b) = 1 to simplify GCD/LCM constraints.",
      "cues": [
        "Problem involves finding integer pairs with specified GCD/LCM values or constraints linking them (e.g., LCM related to one of the numbers)."
      ],
      "implementation": [
        "Parametrize integers as x = gcd_val * a, y = gcd_val * b with gcd(a, b) = 1.",
        "Reduce constraints to the product equation a * b = lcm_val / gcd_val."
      ],
      "used_in": [
        "cmath_10550",
        "cmath_10998"
      ]
    },
    "Reverse Search for Maximum": {
      "name": "Reverse Search for Maximum",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "start_val",
          "typing": "integer",
          "description": "The maximum possible value to start searching from"
        },
        {
          "name": "condition",
          "typing": "predicate function",
          "description": "The boolean condition that the value must satisfy"
        }
      ],
      "description": "Iterating from the theoretical upper bound downwards to find the largest value satisfying a predicate, allowing early termination.",
      "cues": [
        "Objective is to find the largest discrete value satisfying a condition",
        "Search space consists of bounded, ordered discrete candidates",
        "Existence of a calculable theoretical upper bound",
        "Validity check is computationally feasible"
      ],
      "implementation": [
        "Compute starting value as floor(upper_bound / divisor) to establish search start",
        "Iterate candidates from maximum possible value downwards",
        "Return immediately upon finding the first valid candidate"
      ],
      "used_in": [
        "cmath_10550",
        "cmath_5271",
        "cmath_5477"
      ]
    },
    "Coprimality Check": {
      "name": "Coprimality Check",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "num1",
          "typing": "integer",
          "description": "First integer"
        },
        {
          "name": "num2",
          "typing": "integer",
          "description": "Second integer"
        }
      ],
      "description": "Verifying two numbers are relatively prime by checking if their greatest common divisor is 1.",
      "cues": [
        "Constraint explicitly requires gcd(a, b) = 1 or gcd(x, n) == 1",
        "Requirement for a modular inverse to exist or justification for division in congruences",
        "Problem involves reduced fractions, canonical representation, or numerators coprime to denominators",
        "Conditions requiring adjacent elements, derived variables, or factor pairs to be relatively prime",
        "Application of Euler's Totient Theorem"
      ],
      "implementation": [
        "Check `if gcd(a, m) == 1` to validate precondition for modular inverse or division, returning error if failed",
        "Iterate through candidates, pairs, or residue systems, computing gcd to filter non-coprime elements or ensure coprimality (e.g., numerators/denominators)"
      ],
      "used_in": [
        "cmath_10550",
        "cmath_10774",
        "cmath_10816",
        "cmath_10993",
        "cmath_10998",
        "cmath_11055",
        "cmath_2167",
        "cmath_5177",
        "cmath_5195"
      ]
    },
    "Double Factorial": {
      "name": "Double Factorial",
      "kind": "definition",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The non-negative integer to compute the double factorial for"
        }
      ],
      "description": "Product of integers from n down to 1 or 2 with a step of 2, denoted as n!!",
      "cues": [
        "double exclamation mark notation",
        "product of integers with same parity (skipping every other integer)"
      ],
      "implementation": [
        "{'Recursive implementation': 'base case returns 1 for n <= 1, otherwise n * DoubleFactorial(n - 2)'}"
      ],
      "used_in": [
        "cmath_10564"
      ]
    },
    "Modular Arithmetic": {
      "name": "Modular Arithmetic",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "modulus",
          "typing": "integer",
          "description": "The prime number p defining the field Z_p"
        }
      ],
      "description": "Performing arithmetic operations within a fixed range defined by a modulus",
      "cues": [
        "Problems involving remainders, divisibility, congruence relations (≡), specific digits (e.g., units digit), or constraints defined modulo n",
        "Large numbers, exponents, or integers where direct computation is infeasible without modular reduction",
        "Requirement to compute, validate, or utilize modular inverses (division in modular field)",
        "Prime modulus constraint specified (enabling field properties like Fermat's Little Theorem)",
        "Observation of cyclic patterns in values, powers, or sequences"
      ],
      "implementation": [
        "Perform arithmetic operations (addition, multiplication, exponentiation) within the modulus domain, reducing operands modulo n early to prevent overflow and simplify calculations",
        "Use modular inverses to handle division or solve linear congruences, validating existence via coprimality (e.g., gcd(a, n) = 1)",
        "Normalize final results to the standard residue range [0, n-1] (handling negative values), extract remainders or digit patterns, and verify divisibility by checking congruence to 0",
        "Constrain search space to the complete residue system {0, 1, ..., n-1} for brute-force or existence checks"
      ],
      "used_in": [
        "cmath_10564",
        "cmath_10942",
        "cmath_10978",
        "cmath_10993",
        "cmath_11055",
        "cmath_4845",
        "cmath_4974",
        "cmath_5271",
        "cmath_5274",
        "cmath_5334",
        "cmath_5349",
        "cmath_5421",
        "cmath_5477",
        "cmath_5543"
      ]
    },
    "Iterative Accumulation": {
      "name": "Iterative Accumulation",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "sequence",
          "typing": "list",
          "description": "The collection of values to iterate over."
        },
        {
          "name": "accumulator",
          "typing": "variable",
          "description": "The variable storing the running sum or product"
        },
        {
          "name": "start",
          "typing": "integer",
          "description": "Starting value of the loop counter"
        },
        {
          "name": "end",
          "typing": "integer",
          "description": "Ending value of the loop counter"
        },
        {
          "name": "update_rule",
          "typing": "function",
          "description": "The function applied to the current element to update the sum"
        },
        {
          "name": "operation",
          "typing": "function",
          "description": "The transformation applied to each element before accumulation."
        }
      ],
      "description": "Accumulating a result by iterating through a sequence of values and updating a running total",
      "cues": [
        "Problem asks for an aggregate value (sum, product, count, digit sums) derived from a sequence, range, or enumerated items.",
        "Solution involves a loop iterating through a collection (list, range, or components like prime factors) where a running total or product variable is updated in each iteration.",
        "Aggregating results from multiple independent choices or cases (e.g., combinatorial products, inclusion-exclusion terms).",
        "Building a frequency map, histogram, or global metric by sequentially processing input data."
      ],
      "implementation": [
        "Initialize an accumulator variable to the identity value (0 for sums, 1 for products).",
        "Iterate through the sequence (range of integers, list of items, or prime factors).",
        "In each iteration, compute the contribution based on the current element and update the accumulator using the appropriate operation (addition, multiplication, modular arithmetic).",
        "If applicable, apply conditions before updating (e.g., only add if a value is valid/integer).",
        "Return the final accumulated value after the loop completes."
      ],
      "used_in": [
        "cmath_10564",
        "cmath_10630",
        "cmath_10664",
        "cmath_10860",
        "cmath_10934",
        "cmath_10978",
        "cmath_1854",
        "cmath_2027",
        "cmath_2147",
        "cmath_2476",
        "cmath_4681",
        "cmath_4689",
        "cmath_5240",
        "cmath_5295",
        "cmath_9112",
        "cmath_9126"
      ]
    },
    "base_digit_range_formula": {
      "name": "base_digit_range_formula",
      "kind": "formula",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "num_digits",
          "typing": "integer",
          "description": "The number of digits in the representation"
        },
        {
          "name": "base",
          "typing": "integer",
          "description": "The base of the number system"
        }
      ],
      "description": "Determines the minimum and maximum base-10 integer values representable by a number with a specific count of digits in a given base.",
      "cues": [
        "Problem specifies numbers with a fixed number of digits in a specific base (e.g., 3-digit base 5)",
        "Need to determine the range (smallest/largest) of base-10 integer values these representations correspond to"
      ],
      "implementation": [
        "Used in `get_base_range` to compute `min_val` as `base^(num_digits - 1)` and `max_val` as `base^num_digits - 1` for varying digit counts and bases."
      ],
      "used_in": [
        "cmath_10590",
        "cmath_10822",
        "cmath_5075",
        "cmath_5330"
      ]
    },
    "interval_intersection_logic": {
      "name": "interval_intersection_logic",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "interval1",
          "typing": "tuple (start, end)",
          "description": "First range boundaries"
        },
        {
          "name": "interval2",
          "typing": "tuple (start, end)",
          "description": "Second range boundaries"
        }
      ],
      "description": "Computes the overlapping range between two closed intervals [a, b] and [c, d].",
      "cues": [
        "Multiple independent constraints define valid ranges of integers, requiring values that satisfy all simultaneously."
      ],
      "implementation": [
        "Calculate intersection bounds as the MAX of lower bounds and MIN of upper bounds.",
        "Check validity with intersection_start <= intersection_end."
      ],
      "used_in": [
        "cmath_10590",
        "cmath_10822"
      ]
    },
    "arithmetic_progression_mean": {
      "name": "arithmetic_progression_mean",
      "kind": "identity",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "start",
          "typing": "integer",
          "description": "The first integer in the sequence"
        },
        {
          "name": "end",
          "typing": "integer",
          "description": "The last integer in the sequence"
        }
      ],
      "description": "The mean of a finite set of consecutive integers is equal to the average of the first and last terms.",
      "cues": [
        "Problem asks for the average, mean, or sum of a set of integers",
        "The integers form a consecutive sequence or arithmetic progression"
      ],
      "implementation": [
        "Compute the average as (first_term + last_term) / 2",
        "Avoid explicit summation or counting of elements"
      ],
      "used_in": [
        "cmath_10590",
        "cmath_10822"
      ]
    },
    "Base-b Polynomial Representation": {
      "name": "Base-b Polynomial Representation",
      "kind": "algebraic manipulation",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "digits",
          "typing": "list of integers",
          "description": "The sequence of digits d_n...d_0 representing the number."
        },
        {
          "name": "base_variable",
          "typing": "symbol",
          "description": "The variable representing the unknown base (e.g., b)."
        }
      ],
      "description": "Interpreting a number represented by digits in an unknown base b as a polynomial expression in b, where each digit is a coefficient corresponding to a power of b.",
      "cues": [
        "Problem involves numbers represented by digits in unspecified, variable, or multiple bases using positional notation (e.g., $121_c$ or equations mixing bases).",
        "Problem involves sums of distinct powers of 3 (equivalent to base-3 representation with digits 0 and 1)."
      ],
      "implementation": [
        "Convert numbers from base-b representation to a polynomial in b (e.g., digits d_n...d_0 map to sum(d_i * b^i)); for sums of distinct powers, treat as base-b polynomials with binary coefficients."
      ],
      "used_in": [
        "cmath_10600",
        "cmath_10695",
        "cmath_5236",
        "cmath_5349"
      ]
    },
    "Minimum Valid Base Constraint": {
      "name": "Minimum Valid Base Constraint",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "digits",
          "typing": "set of integers",
          "description": "All unique digits appearing in the numbers within the problem."
        }
      ],
      "description": "A constraint determining the lower bound for a valid base, which must be strictly greater than the largest digit value appearing in the number representations.",
      "cues": [
        "The base of the number system is unknown or represented by a variable.",
        "Numbers are expressed in standard positional notation involving specific digit values or distinct digit constraints.",
        "Solutions to equations yield multiple candidates (e.g., quadratic roots) requiring validation against digit constraints."
      ],
      "implementation": [
        "Identify the maximum digit value D across all numbers, establish the minimum valid base as max(D + 1, count of unique digits), and filter candidate solutions to satisfy this lower bound."
      ],
      "used_in": [
        "cmath_10600",
        "cmath_10637",
        "cmath_10695",
        "cmath_4869"
      ]
    },
    "Integer Base Enumeration": {
      "name": "Integer Base Enumeration",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "start_value",
          "typing": "integer",
          "description": "The minimum valid base to start the search from."
        },
        {
          "name": "condition",
          "typing": "boolean function",
          "description": "The algebraic equation or logical condition that must evaluate to true."
        }
      ],
      "description": "A search strategy for finding an unknown integer base by iterating through candidate values starting from a valid lower bound and checking for satisfaction of the problem conditions.",
      "cues": [
        "The unknown variable is a base (implied to be a small integer).",
        "An algebraic equation involving the base has been constructed.",
        "Analytic solution of the polynomial may be difficult or unnecessary."
      ],
      "implementation": [
        "Iterate integer b starting from b_min upwards.",
        "Evaluate the equation for each b and return the first where it holds true."
      ],
      "used_in": [
        "cmath_10600",
        "cmath_4869"
      ]
    },
    "Cartesian Product Enumeration": {
      "name": "Cartesian Product Enumeration",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "base_set",
          "typing": "set",
          "description": "The set of values to pick from"
        },
        {
          "name": "length",
          "typing": "int",
          "description": "The number of elements to pick"
        }
      ],
      "description": "Generating all ordered tuples of a fixed length from a base set, allowing repetition.",
      "cues": [
        "Enumerating fixed-length sequences or composite objects where each component is independently chosen from a set of valid options (exhaustive search space)"
      ],
      "implementation": [
        "Generate all outcomes via Cartesian product of the base set (or valid rows) with fixed repetition"
      ],
      "used_in": [
        "cmath_10604",
        "cmath_2100"
      ]
    },
    "Set Deduplication": {
      "name": "Set Deduplication",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "values",
          "typing": "iterable",
          "description": "The sequence of values to deduplicate"
        }
      ],
      "description": "Using a set data structure to store results of a transformation to automatically filter duplicates, useful for identifying distinct outcomes.",
      "cues": [
        "Goal is to count the number of *unique* or *distinct* outcomes.",
        "Multiple different inputs may produce the same output value."
      ],
      "implementation": [
        "Initialize an empty set to store unique outcomes.",
        "Compute the value for each input and insert into the set to automatically filter duplicates.",
        "Return the cardinality of the set as the final answer."
      ],
      "used_in": [
        "cmath_10604",
        "cmath_4845",
        "cmath_9094"
      ]
    },
    "Summation of Distinct Values": {
      "name": "Summation of Distinct Values",
      "kind": "calculation method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "distinct_values",
          "typing": "set",
          "description": "The set of unique numbers to sum"
        }
      ],
      "description": "Calculating the arithmetic sum of all unique values in a collection.",
      "cues": [
        "Problem asks for the sum of all distinct/unique valid solutions or outcomes.",
        "Collected numbers are distinct by virtue of the search process."
      ],
      "implementation": [
        "Compute the final answer as the arithmetic sum of all elements in the collected set of valid values, typically by iterating and accumulating into a total sum variable."
      ],
      "used_in": [
        "cmath_10604",
        "cmath_4759",
        "cmath_4845",
        "cmath_5075",
        "cmath_5240"
      ]
    },
    "Product of Divisors Formula": {
      "name": "Product of Divisors Formula",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The number whose divisors are being multiplied"
        },
        {
          "name": "x",
          "typing": "integer",
          "description": "The total count of divisors of n"
        }
      ],
      "description": "The product of all positive divisors of an integer n is n raised to the power of half the count of its divisors.",
      "cues": [
        "product of divisors",
        "divisor count",
        "exponent involving divisor count"
      ],
      "implementation": [
        "Used to establish the initial exponent x/2 for the product of all divisors in Step 1"
      ],
      "used_in": [
        "cmath_10610"
      ]
    },
    "Proper Divisor Product Relation": {
      "name": "Proper Divisor Product Relation",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Relates the product of proper divisors to the product of all divisors by dividing by the number itself.",
      "cues": [
        "proper divisors",
        "product excluding the number itself",
        "adjustment of divisor product"
      ],
      "implementation": [
        "Applied in Step 2 to adjust the exponent from x/2 to (x-2)/2 by dividing by n"
      ],
      "used_in": [
        "cmath_10610"
      ]
    },
    "Equating Coefficients": {
      "name": "Equating Coefficients",
      "kind": "algebraic manipulation",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Method for solving parameters in an identity by matching the coefficients of corresponding powers of the variable on both sides.",
      "cues": [
        "identity in a variable holding for all valid values with unknown parameters in linear or polynomial expressions"
      ],
      "implementation": [
        "Derive relationships between parameters by matching coefficients of corresponding powers and constant terms on both sides of the identity"
      ],
      "used_in": [
        "cmath_10610"
      ]
    },
    "GCD Normalization": {
      "name": "GCD Normalization",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "ratio",
          "typing": "list of integers",
          "description": "The proportional values derived from equations"
        },
        {
          "name": "target_gcd",
          "typing": "integer",
          "description": "The desired greatest common divisor"
        }
      ],
      "description": "Process of scaling a set of proportional integers to satisfy a greatest common divisor constraint, typically gcd=1.",
      "cues": [
        "gcd constraint on parameters",
        "integer solution required",
        "ratio of parameters determined"
      ],
      "implementation": [
        "Used in Step 5 to select the specific integer values a=1, b=-2, c=2 from the ratio 1:-2:2"
      ],
      "used_in": [
        "cmath_10610"
      ]
    },
    "Divisor Count Structure": {
      "name": "Divisor Count Structure",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "target_divisors",
          "typing": "integer",
          "description": "The exact number of divisors the integer must have"
        }
      ],
      "description": "Characterizes the prime factorization form of an integer based on its total number of divisors using the divisor function formula tau(n).",
      "cues": [
        "Problem specifies an exact count of divisors (total or restricted) and requires determining the number's prime factorization structure (exponents)."
      ],
      "implementation": [
        "Apply the relation tau(N) = product(e_i + 1) to derive prime exponents from the target divisor count (e.g., 3 factors implies p^2, 4 factors implies p^3 or p*q).",
        "If given a restricted divisor count (excluding 1 and N), infer the total divisor count D by adding 2.",
        "Validate that candidate numbers constructed from the derived exponents satisfy the original divisor count requirement."
      ],
      "used_in": [
        "cmath_10619",
        "cmath_5475",
        "cmath_5532"
      ]
    },
    "Constructive Enumeration": {
      "name": "Constructive Enumeration",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "primitives",
          "typing": "list",
          "description": "Fundamental elements to build from (e.g., list of primes)"
        },
        {
          "name": "construction_rules",
          "typing": "list",
          "description": "Mathematical forms to apply to primitives (e.g., p^3, p*q)"
        }
      ],
      "description": "Generates valid instances by composing fundamental building blocks (e.g., primes) according to structural rules instead of brute-force checking.",
      "cues": [
        "Search space consists of discrete structural configurations (e.g., partitions, subsets) or sequences rather than a numeric range, requiring generation via structural rules or primitives.",
        "Objective is to find an optimal value (min/max) or smallest k numbers with a property among valid configurations."
      ],
      "implementation": [
        "Generate candidates by composing primitives (e.g., primes) or iterating structural configurations (e.g., partitions, subsets, recurrence sequences).",
        "Iterate through generated candidates to compute derived values and identify the optimal result."
      ],
      "used_in": [
        "cmath_10619",
        "cmath_2114",
        "cmath_5475",
        "cmath_9094"
      ]
    },
    "K-Smallest Aggregation": {
      "name": "K-Smallest Aggregation",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "k",
          "typing": "integer",
          "description": "Count of extreme values to select"
        },
        {
          "name": "aggregation_func",
          "typing": "function",
          "description": "Function to apply to selected subset (e.g., sum, product)"
        }
      ],
      "description": "Selects the k extreme values from a generated set and computes an aggregate value over them.",
      "cues": [
        "sum of smallest k values"
      ],
      "implementation": [
        "Sort all candidates in ascending order, select the first k, and compute the aggregate (e.g., sum) over them."
      ],
      "used_in": [
        "cmath_10619"
      ]
    },
    "Direct Enumeration": {
      "name": "Direct Enumeration",
      "kind": "algorithm",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "start",
          "typing": "int",
          "description": "The starting integer of the range."
        },
        {
          "name": "end",
          "typing": "int",
          "description": "The ending integer of the range."
        },
        {
          "name": "operation",
          "typing": "function",
          "description": "The logic applied to each element in the range."
        },
        {
          "name": "search_variable",
          "typing": "integer",
          "description": "The variable being incremented to search for a solution"
        },
        {
          "name": "start_value",
          "typing": "integer",
          "description": "The initial value for the search variable"
        },
        {
          "name": "search_space",
          "typing": "set or sequence",
          "description": "The finite set of candidates to enumerate."
        }
      ],
      "description": "Iterating through every element in a finite, manageable search space to verify conditions or compute aggregates.",
      "cues": [
        "Small, finite, and manageable search space (e.g., bounded integers, permutations, provided lists, or specific sets)",
        "Problem specifies a concrete range of integers or bounded variables to analyze",
        "Requirement to verify a condition, property, or constraint for every candidate in the space",
        "Goal is to find specific solutions (smallest, first, count, or all) satisfying conditions",
        "No closed-form solution or formula is immediately apparent",
        "Search space involves permutations, combinations, or configurations of small sets",
        "Constraints reduce degrees of freedom allowing enumeration of remaining variables"
      ],
      "implementation": [
        "Define the finite search space (ranges, permutations, lists, or bounded variables)",
        "Construct loops to iterate through every candidate in the search space",
        "Evaluate the specific condition or constraint for each candidate element",
        "Terminate early if only the first, smallest, or specific count of solutions is required",
        "Aggregate results, store valid configurations, or compute values based on valid candidates",
        "Handle variable bounds explicitly (e.g., 1 to sqrt(n), 0 to max_count) to limit iteration"
      ],
      "used_in": [
        "cmath_10621",
        "cmath_10731",
        "cmath_10816",
        "cmath_10993",
        "cmath_1988",
        "cmath_2100",
        "cmath_2432",
        "cmath_4689",
        "cmath_4733",
        "cmath_4818",
        "cmath_4845",
        "cmath_4949",
        "cmath_4974",
        "cmath_5240",
        "cmath_5246",
        "cmath_5295",
        "cmath_5334",
        "cmath_5342",
        "cmath_5349",
        "cmath_5540",
        "cmath_9126"
      ]
    },
    "GCD Computation": {
      "name": "GCD Computation",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "a",
          "typing": "int",
          "description": "The first integer."
        },
        {
          "name": "b",
          "typing": "int",
          "description": "The second integer."
        }
      ],
      "description": "Calculating the greatest common divisor of two integers to analyze their divisibility relationship.",
      "cues": [
        "Problem involves common factors, simplification, or divisibility",
        "Explicit mention of gcd or greatest common divisor",
        "reducing fractions to irreducible form",
        "analyzing divisibility relationship",
        "Need to find the common divisor of multiple generated values",
        "Determining the greatest integer satisfying multiple divisibility constraints"
      ],
      "implementation": [
        "Compute `g = gcd(m, 100)`",
        "Used to reduce probability fraction to irreducible form m/n.",
        "Applied to the list of evaluated polynomial values to determine the greatest common divisor (MaxDivisor)"
      ],
      "used_in": [
        "cmath_10621",
        "cmath_2190",
        "cmath_5540"
      ]
    },
    "Conditional Counting": {
      "name": "Conditional Counting",
      "kind": "counting method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "predicate",
          "typing": "boolean function",
          "description": "The condition elements must satisfy to be counted"
        },
        {
          "name": "initial_value",
          "typing": "int",
          "description": "The starting value of the counter."
        },
        {
          "name": "domain",
          "typing": "set",
          "description": "The set of elements to iterate over"
        }
      ],
      "description": "Accumulating a total by incrementing a counter only when elements satisfy a specific boolean predicate.",
      "cues": [
        "Problem asks for the total number of elements or configurations satisfying specific properties or constraints",
        "Solution involves accumulating a count using a counter variable and conditional checks inside an iteration"
      ],
      "implementation": [
        "Initialize a counter variable to 0 before iterating through the domain of candidates",
        "Evaluate boolean predicates for each candidate and increment the counter only when validity conditions are met",
        "Return the final accumulated count after iteration completes"
      ],
      "used_in": [
        "cmath_10621",
        "cmath_10637",
        "cmath_10731",
        "cmath_10816",
        "cmath_10998",
        "cmath_1988",
        "cmath_2100",
        "cmath_2147",
        "cmath_2432",
        "cmath_4771",
        "cmath_4818",
        "cmath_4949",
        "cmath_4974",
        "cmath_5246",
        "cmath_5342",
        "cmath_9094"
      ]
    },
    "LCM Valuation Identity": {
      "name": "LCM Valuation Identity",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "The p-adic valuation of the least common multiple of two numbers is the maximum of their individual p-adic valuations.",
      "cues": [
        "Problem involves LCM or GCD operations",
        "Need to simplify LCM expressions algebraically"
      ],
      "implementation": [
        "Applied property v_p(lcm(x, y)) = max(v_p(x), v_p(y)) to transform the LCM equation into exponent equations."
      ],
      "used_in": [
        "cmath_10627"
      ]
    },
    "Valuation Analysis": {
      "name": "Valuation Analysis",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "p",
          "typing": "prime",
          "description": "The prime base for the valuation."
        },
        {
          "name": "n",
          "typing": "integer",
          "description": "The number to analyze for prime valuation."
        }
      ],
      "description": "Solving number theoretic equations by decomposing integers into prime power components and analyzing exponents independently.",
      "cues": [
        "Equations involving multiplicative operations (LCM, GCD, division) or determining the exact prime power dividing quotients/rational expressions",
        "Constraints or properties applied independently to each prime factor (e.g., perfect powers, divisor counts, exponent divisibility)",
        "Logarithmic equations with integer constraints or base conversion involving primes"
      ],
      "implementation": [
        "Extract exponents via full prime factorization or specific p-adic valuation calculations (repeated division/subtraction)",
        "Convert constraints (logarithms, perfect powers) into linear equations on exponents, solving for each prime independently before combining results"
      ],
      "used_in": [
        "cmath_10627",
        "cmath_10630",
        "cmath_10860",
        "cmath_10934",
        "cmath_2104",
        "cmath_2167",
        "cmath_4681",
        "cmath_5291",
        "cmath_5295"
      ]
    },
    "Max Function Case Analysis": {
      "name": "Max Function Case Analysis",
      "kind": "algebraic manipulation",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Solving equations involving max(a, b) by splitting the domain into cases based on the comparison of a and b.",
      "cues": [
        "Equations containing max() terms",
        "Piecewise conditions derived from valuations or absolute values"
      ],
      "implementation": [
        "Solved max(a + 3, 10) = 2 + max(a, 10) by testing cases a >= 7 and a < 7 to determine valid exponent values."
      ],
      "used_in": [
        "cmath_10627"
      ]
    },
    "Perfect Square Exponent Count": {
      "name": "Perfect Square Exponent Count",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "exponent",
          "typing": "integer",
          "description": "The maximum exponent e in the prime factorization p^e of the original number"
        }
      ],
      "description": "Calculates the number of valid even exponents k (0 <= k <= e) for a prime factor p^e to contribute to a perfect square divisor.",
      "cues": [
        "Perfect square factors",
        "Divisor counting",
        "Parity constraints on exponents"
      ],
      "implementation": [
        "Computed floor(e / 2) + 1 for each prime exponent to find the number of even values in range [0, e]"
      ],
      "used_in": [
        "cmath_10630"
      ]
    },
    "Base Digit Divisibility Reduction": {
      "name": "Base Digit Divisibility Reduction",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "N",
          "typing": "Integer",
          "description": "The integer value represented in base b"
        },
        {
          "name": "d",
          "typing": "Integer",
          "description": "The target last digit value"
        },
        {
          "name": "b",
          "typing": "Integer",
          "description": "The unknown base variable"
        }
      ],
      "description": "Transforming a constraint on the last digit of a number in base b into a divisibility constraint where b must divide the difference between the number and the digit.",
      "cues": [
        "last digit in base b",
        "finding valid bases",
        "digit constraint"
      ],
      "implementation": [
        "Condition for last digit d in base b is N mod b = d, implying b divides (N - d)",
        "{'COMPUTE': 'Difference M = N - d = 2010'}"
      ],
      "used_in": [
        "cmath_10637"
      ]
    },
    "Divisor Enumeration": {
      "name": "Divisor Enumeration",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "Integer",
          "description": "The integer to find divisors for"
        },
        {
          "name": "target_number",
          "typing": "integer",
          "description": "The integer whose divisors are being computed"
        }
      ],
      "description": "Computing the complete set of positive divisors for a given integer to identify candidate values satisfying divisibility conditions.",
      "cues": [
        "Problem involves divisibility constraints or checking if k divides N.",
        "Search space or conditions require finding all divisors or specific subsets (e.g., proper divisors) of a specific or derived integer."
      ],
      "implementation": [
        "Iterate from 1 to sqrt(N) to construct the set of all positive divisors of the target integer by checking divisibility.",
        "Filter divisors to exclude 1 and n if proper divisors are required."
      ],
      "used_in": [
        "cmath_10637",
        "cmath_10998",
        "cmath_4818",
        "cmath_5240"
      ]
    },
    "Divisor Enumeration for Integrality": {
      "name": "Divisor Enumeration for Integrality",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "Numerator",
          "typing": "Integer",
          "description": "The constant value in the numerator of the fraction."
        },
        {
          "name": "Denominator Expression",
          "typing": "Function",
          "description": "The expression involving the variable that forms the denominator."
        }
      ],
      "description": "Solving equations where a rational expression must be an integer by enumerating the divisors of the numerator and solving for the variable in the denominator.",
      "cues": [
        "Finding integer variable values (including negatives) that make a rational expression (constant numerator, variable denominator) evaluate to an integer (implies denominator divides numerator)",
        "Constant numerator is small enough to allow complete divisor enumeration"
      ],
      "implementation": [
        "Enumerate all integer divisors of the numerator (including negatives), set denominator expression equal to each divisor, solve for the variable, and verify integrality",
        "If optimizing, select the divisor that maximizes or minimizes the result before solving"
      ],
      "used_in": [
        "cmath_10664",
        "cmath_4759",
        "cmath_5235",
        "cmath_5271"
      ]
    },
    "Divisibility Counting Formula": {
      "name": "Divisibility Counting Formula",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "limit",
          "typing": "integer",
          "description": "The upper bound of the range (inclusive)"
        },
        {
          "name": "divisor",
          "typing": "integer",
          "description": "The number whose multiples are being counted"
        }
      ],
      "description": "Calculates the number of multiples of an integer k within the range [1, N] using the floor division formula floor(N / k).",
      "cues": [
        "Counting multiples or divisible numbers within a large range [1, N] where enumeration is inefficient (requires floor(N / k))"
      ],
      "implementation": [
        "Use floor(N / k) to calculate the number of multiples of k in range [1, N]",
        "Apply formula inside loops for dynamic divisors (e.g., powers of a prime)",
        "Extend to inclusion-exclusion by computing counts for individual divisors and their LCM for intersections"
      ],
      "used_in": [
        "cmath_10691",
        "cmath_5545"
      ]
    },
    "LCM Intersection Property": {
      "name": "LCM Intersection Property",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "divisor_a",
          "typing": "integer",
          "description": "First divisor"
        },
        {
          "name": "divisor_b",
          "typing": "integer",
          "description": "Second divisor"
        },
        {
          "name": "lcm_value",
          "typing": "integer",
          "description": "Precomputed LCM of divisor_a and divisor_b"
        }
      ],
      "description": "The set of integers divisible by both a and b is identical to the set of integers divisible by lcm(a, b), allowing intersection counts to be computed via the LCM.",
      "cues": [
        "two simultaneous divisibility conditions",
        "finding common multiples",
        "intersection of divisibility sets"
      ],
      "implementation": [
        "count_intersection <- FLOOR(total_items / lcm_divisor)"
      ],
      "used_in": [
        "cmath_10691"
      ]
    },
    "Symmetric Difference Counting": {
      "name": "Symmetric Difference Counting",
      "kind": "counting method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "count_a",
          "typing": "integer",
          "description": "Size of set A"
        },
        {
          "name": "count_b",
          "typing": "integer",
          "description": "Size of set B"
        },
        {
          "name": "count_intersection",
          "typing": "integer",
          "description": "Size of intersection A ∩ B"
        }
      ],
      "description": "Computes the size of the symmetric difference of two sets (elements in exactly one set) by summing the counts of elements unique to each set (|A| + |B| - 2|A ∩ B|).",
      "cues": [
        "counting mismatches, elements unique to exactly one of two sets, or scenarios requiring exclusive OR (XOR) logic between two conditions"
      ],
      "implementation": [
        "{'Compute symmetric difference size as (count_a + count_b - 2 * count_intersection), which is equivalent to summing elements unique to each set': '(count_a - intersection) + (count_b - intersection)'}"
      ],
      "used_in": [
        "cmath_10691"
      ]
    },
    "Perfect Square Factorization": {
      "name": "Perfect Square Factorization",
      "kind": "algebraic manipulation",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "polynomial",
          "typing": "expression",
          "description": "The quadratic expression to be factored"
        },
        {
          "name": "variable",
          "typing": "symbol",
          "description": "The variable with respect to which the square is formed"
        }
      ],
      "description": "Recognizing and factoring a quadratic polynomial as the square of a binomial (e.g., $x^2 + 2x + 1 = (x+1)^2$) to simplify equations.",
      "cues": [
        "Quadratic expressions with coefficients forming a perfect square pattern (e.g., 1, 2, 1)",
        "Equations involving squares of variables on both sides"
      ],
      "implementation": [
        "Factor the quadratic expression into a squared binomial (e.g., $c^2 + 2c + 1 = (c+1)^2$) and simplify equations by taking the square root of both sides to derive linear relations."
      ],
      "used_in": [
        "cmath_10695"
      ]
    },
    "Algebraic Substitution": {
      "name": "Algebraic Substitution",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "target_equation",
          "typing": "equation",
          "description": "The equation into which substitution is performed"
        },
        {
          "name": "substitution_expression",
          "typing": "expression",
          "description": "The expression replacing the variable"
        },
        {
          "name": "variable",
          "typing": "symbol",
          "description": "The variable being eliminated"
        }
      ],
      "description": "Replacing a variable in an equation with an equivalent expression derived from another equation to reduce the system to a single variable.",
      "cues": [
        "Systems of equations with shared variables, especially where linear constraints allow easy isolation",
        "Expressions containing matching sub-expressions or derived forms where substitution simplifies structure or utilizes given values",
        "Problems involving ratio-based holdings or distribution expressions"
      ],
      "implementation": [
        "Substitute isolated variables into other equations to reduce the system to a single variable (e.g., quadratic)",
        "Substitute sub-expressions or definitions into expressions to simplify computation or reveal structure (e.g., prime factorization)",
        "Substitute parameterized ratios into distribution expressions to link quantities to scaling factors"
      ],
      "used_in": [
        "cmath_10695",
        "cmath_10942",
        "cmath_2432",
        "cmath_5283",
        "cmath_5532"
      ]
    },
    "Fraction Clearing": {
      "name": "Fraction Clearing",
      "kind": "algebraic manipulation",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Converting equations with rational coefficients to integer coefficients by multiplying through by the LCM of all denominators",
      "cues": [
        "Linear or polynomial equations contain fractions or rational coefficients that need simplification to integer arithmetic"
      ],
      "implementation": [
        "Multiply the entire equation by the LCM of all denominators to convert rational coefficients to integers (e.g., multiplying M/4 + C/6 = 8 by 12 yields 3M + 2C = 96)"
      ],
      "used_in": [
        "cmath_10731"
      ]
    },
    "Divisibility Substitution": {
      "name": "Divisibility Substitution",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "variable",
          "typing": "symbol",
          "description": "The original variable subject to divisibility constraint"
        },
        {
          "name": "divisor",
          "typing": "integer",
          "description": "The known divisor that the variable must be a multiple of"
        },
        {
          "name": "parameter",
          "typing": "symbol",
          "description": "The new integer parameter representing the quotient"
        }
      ],
      "description": "Replacing variables with parameterized forms based on known divisibility constraints (e.g., if x must be divisible by k, set x = k·t for integer t)",
      "cues": [
        "Variable constrained by divisibility, congruences, or multiple conditions (e.g., multiple of k or mk + r)",
        "Problem involves partitioning or grouping with fixed sizes",
        "Need to reduce search space using structural constraints or density reduction",
        "Counting divisors subject to a multiple constraint (e.g., divisors of N that are multiples of k)",
        "Problem involves ratios, proportional holdings, or a common scaling factor"
      ],
      "implementation": [
        "Substitute variables with divisor multiples or congruence forms (e.g., M = 8m or r = a + m·k) to simplify equations and reduce coefficients",
        "Substitute divisor d = k·m to transform 'd divides N and k divides d' into counting divisors of N/k",
        "Introduce a scaling factor k to represent proportional values (e.g., 3k, 4k, 5k) based on given ratios to facilitate equation formulation",
        "Define candidates as n * multiplier to reduce search space from limit values to limit/multiplier values"
      ],
      "used_in": [
        "cmath_10731",
        "cmath_11055",
        "cmath_4855",
        "cmath_5283",
        "cmath_5477"
      ]
    },
    "Extended Euclidean Algorithm": {
      "name": "Extended Euclidean Algorithm",
      "kind": "algorithm",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "a",
          "typing": "integer",
          "description": "The integer to invert"
        },
        {
          "name": "b",
          "typing": "integer",
          "description": "Second integer input"
        },
        {
          "name": "m",
          "typing": "integer",
          "description": "The modulus (must be coprime to a)"
        }
      ],
      "description": "An extension of the Euclidean algorithm that computes the greatest common divisor of two integers a and b, along with coefficients x and y (Bézout's identity) such that ax + by = gcd(a, b).",
      "cues": [
        "Computing GCD with Bézout coefficients (ax + by = gcd(a, b)) or solving linear Diophantine equations",
        "Computing modular multiplicative inverses (e.g., k^(-1) mod p), especially when the modulus is prime ensuring gcd(k, p) = 1"
      ],
      "implementation": [
        "Define a recursive function `extended_gcd(a, b)` returning (gcd, x, y) with base case (b, 0, 1) when a=0",
        "Update coefficients in the recursive step using x = y1 - (b // a) * x1 derived from the previous call",
        "Extract coefficient x from the result to compute the modular inverse, adjusting for negative values if necessary"
      ],
      "used_in": [
        "cmath_10774",
        "cmath_10978",
        "cmath_5195"
      ]
    },
    "Modular Inverse via Extended GCD": {
      "name": "Modular Inverse via Extended GCD",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "a",
          "typing": "integer",
          "description": "The number to invert"
        },
        {
          "name": "m",
          "typing": "integer",
          "description": "The modulus"
        }
      ],
      "description": "A method to compute the multiplicative inverse of an integer 'a' modulo 'm' by utilizing the Extended Euclidean Algorithm to solve ax ≡ 1 (mod m), valid only when gcd(a, m) = 1.",
      "cues": [
        "Problem requires division in modular arithmetic or finding a multiplicative inverse (solving ax ≡ 1 (mod m))",
        "The coefficient and modulus are coprime (gcd(a, m) = 1), but the modulus is not guaranteed to be prime"
      ],
      "implementation": [
        "Transform the problem into solving the Diophantine equation a * x + m * y = 1 using Extended GCD",
        "Include an assertion to verify that the gcd is 1, ensuring the inverse exists",
        "Normalize the resulting coefficient x using modulo m to ensure the result lies in the range [0, m-1]",
        "Used to find inverses in algorithms such as Linear Congruence Resolution or CRT construction"
      ],
      "used_in": [
        "cmath_10774",
        "cmath_5178",
        "cmath_5195"
      ]
    },
    "Perfect Power Divisor Count": {
      "name": "Perfect Power Divisor Count",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "power",
          "typing": "integer",
          "description": "The root of the perfect power (e.g., 2 for squares, 3 for cubes)"
        },
        {
          "name": "exponent",
          "typing": "integer",
          "description": "The exponent of the prime factor in the number's prime factorization"
        },
        {
          "name": "PrimeExponents",
          "typing": "list[int]",
          "description": "The exponents of the prime factors in the integer's prime factorization"
        },
        {
          "name": "RootPower",
          "typing": "int",
          "description": "The power k (e.g., 2 for square, 3 for cube) that the divisors must satisfy"
        }
      ],
      "description": "Calculates the number of divisors that are perfect k-th powers by counting valid exponents divisible by k for each prime factor in the number's factorization.",
      "cues": [
        "Problem asks for the number of divisors that are perfect k-th powers (squares, cubes, etc.)",
        "Prime factorization is known or easily computable"
      ],
      "implementation": [
        "For each prime factor exponent E, calculate valid choices as floor(E / k) + 1, where k is the root power",
        "Multiply the counts for each prime factor to get the total number of perfect power divisors"
      ],
      "used_in": [
        "cmath_10860",
        "cmath_10934"
      ]
    },
    "Reciprocal Sum Identity": {
      "name": "Reciprocal Sum Identity",
      "kind": "identity",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Relates the sum of two multiplicative inverses to the inverse of their product scaled by their sum (a^(-1) + b^(-1) = (a+b)(ab)^(-1)).",
      "cues": [
        "Expression involves a sum of inverses (1/a + 1/b)",
        "Need to combine terms with different modular denominators",
        "Given value is related to the product of the variables (ab)"
      ],
      "implementation": [
        "Transformed (a^(-1) + b^(-1)) into (a+b)*(ab)^(-1) to align with the given constraint",
        "Enabled the use of the known value (ab)^(-1) ≡ 2"
      ],
      "used_in": [
        "cmath_10942"
      ]
    },
    "Conditional Summation": {
      "name": "Conditional Summation",
      "kind": "calculation method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Calculating the sum of values in a collection that satisfy a specific boolean predicate.",
      "cues": [
        "Aggregating values based on a condition (e.g., Sum(x where P(x)))",
        "Partitioning a total sum into components based on properties"
      ],
      "implementation": [
        "Computing separate sums for disjoint components based on properties (e.g., coprime vs non-coprime residues)",
        "Adding value to total_sum only when a specific condition is met (e.g., LCM match, leading non-zero constraint)"
      ],
      "used_in": [
        "cmath_10993",
        "cmath_4733",
        "cmath_5349"
      ]
    },
    "Arithmetic Progression Minimum Bound": {
      "name": "Arithmetic Progression Minimum Bound",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Determining the smallest integer parameter in a linear expression (arithmetic progression) that satisfies a given lower bound constraint, typically using ceiling division.",
      "cues": [
        "Requirement to find the smallest solution >= a specific LowerBound (e.g., \"least four-digit number\", \"smallest n > X\")",
        "Solution space forms an arithmetic progression or specific residue class defined by linear terms with an integer parameter (x_0 + k * M)"
      ],
      "implementation": [
        "{'Calculate minimal integer k using ceiling division': 'k = Ceiling((LowerBound - x_0) / M)'}",
        "{'Compute the final value by adjusting the base solution': 'x_0 + k * M'}"
      ],
      "used_in": [
        "cmath_11055",
        "cmath_5178"
      ]
    },
    "Multiplication Principle": {
      "name": "Multiplication Principle",
      "kind": "counting method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "option_counts",
          "typing": "list of integers",
          "description": "The number of available choices for each independent decision point."
        }
      ],
      "description": "Calculating the total number of ways to perform a sequence of independent tasks by multiplying the number of ways to perform each task.",
      "cues": [
        "Problem decomposes into a sequence of independent choices, categories, or selection tasks (constructive counting strategy).",
        "Linguistic cues like 'for each...' indicating iteration over choices."
      ],
      "implementation": [
        "Calculate choices per independent step or item type (e.g., `count + 1`), then multiply these counts to determine the total.",
        "Combine selection counts (binomial coefficient) with assignment counts (power function) via multiplication."
      ],
      "used_in": [
        "cmath_1854",
        "cmath_2147",
        "cmath_2190",
        "cmath_2385",
        "cmath_2432",
        "cmath_9112"
      ]
    },
    "Complementary Counting": {
      "name": "Complementary Counting",
      "kind": "counting method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "total",
          "typing": "integer",
          "description": "The total number of possibilities including invalid cases."
        },
        {
          "name": "excluded",
          "typing": "integer",
          "description": "The number of invalid or unwanted possibilities to subtract."
        },
        {
          "name": "total_count",
          "typing": "integer",
          "description": "The total number of elements in the universal set."
        },
        {
          "name": "complement_count",
          "typing": "integer",
          "description": "The number of elements satisfying the negation of the target condition."
        }
      ],
      "description": "Determining the count of elements satisfying a property by subtracting the count of elements that do not satisfy it from the total count.",
      "cues": [
        "Problem asks for \"at least one\", \"non-empty\", or \"not all\", or involves phrases like \"none\", \"never\", or \"all distinct\".",
        "Direct counting involves complex casework, but counting the complement is simpler.",
        "Total set size is easily determined."
      ],
      "implementation": [
        "Calculate result by subtracting the complement count from the total count.",
        "Subtract 1 from total_combinations to remove the empty selection case."
      ],
      "used_in": [
        "cmath_1854",
        "cmath_1970",
        "cmath_5260"
      ]
    },
    "Positional Digit Counting": {
      "name": "Positional Digit Counting",
      "kind": "counting method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "positions",
          "typing": "list",
          "description": "The digit positions to fill (e.g., [100, 10, 1])."
        },
        {
          "name": "constraints",
          "typing": "list",
          "description": "Rules restricting valid digits at each position (e.g., distinctness, range bounds)."
        }
      ],
      "description": "Counting integers satisfying digit-level constraints by multiplying the number of valid choices for each digit position (Hundreds, Tens, Units, etc.).",
      "cues": [
        "Counting integers with fixed digit length or base b representation (e.g., Hundreds, Tens, Units)",
        "Digit-level constraints (parity, leading zero, specific values) or dependencies between positions (e.g., distinctness)"
      ],
      "implementation": [
        "Decompose the number into positional components (e.g., Hundreds, Tens, Units or base b positions)",
        "Calculate valid digit choices for each position, adjusting for dependencies like distinctness based on previous selections, and apply the multiplication principle to compute total count"
      ],
      "used_in": [
        "cmath_1970",
        "cmath_2385",
        "cmath_4869"
      ]
    },
    "Range Cardinality": {
      "name": "Range Cardinality",
      "kind": "formula",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "range_min",
          "typing": "integer",
          "description": "The lower bound of the inclusive range."
        },
        {
          "name": "range_max",
          "typing": "integer",
          "description": "The upper bound of the inclusive range."
        }
      ],
      "description": "Computes the number of integers in an inclusive interval [min, max] using the formula max - min + 1.",
      "cues": [
        "Problem asks for the count of integers within a specific inclusive interval.",
        "Bounds are given as explicit integers (often non-negative).",
        "Counting valid parameter values within a range."
      ],
      "implementation": [
        "Compute the count of integers in an inclusive range [min, max] using the formula `max - min + 1` (simplifies to `max + 1` if min is 0).",
        "Use this calculation to establish the universe size for complementary counting."
      ],
      "used_in": [
        "cmath_1970",
        "cmath_5291",
        "cmath_5330"
      ]
    },
    "Digit Decomposition": {
      "name": "Digit Decomposition",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "number",
          "typing": "integer",
          "description": "The integer to be decomposed into digits"
        },
        {
          "name": "base",
          "typing": "integer",
          "description": "The numerical base for decomposition (default 10)"
        }
      ],
      "description": "Extracting individual digits from an integer in a given base to analyze their values or relationships.",
      "cues": [
        "Problem involves extracting, analyzing, or performing arithmetic on individual digits, bits, or positional values in a specific base (e.g., decimal, binary, digit_sum, ith bit)",
        "References to decimal/fractional expansion or positional representation formulas (e.g., n = Σ(b_i * 2^i))"
      ],
      "implementation": [
        "Decompose the number (integer or rational) into a sequence of digits or bits in the target base (e.g., via `decimal_digits(n)` or bit extraction)",
        "Treat the extracted digits for analysis or as coefficients in a summation"
      ],
      "used_in": [
        "cmath_1988",
        "cmath_4689",
        "cmath_5236"
      ]
    },
    "Bell Number": {
      "name": "Bell Number",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The number of distinct elements to partition"
        }
      ],
      "description": "The total number of partitions of a set of n labeled elements into non-empty unlabeled subsets.",
      "cues": [
        "distinct elements",
        "identical containers",
        "unlimited container capacity or count"
      ],
      "implementation": [
        "Returned directly when the number of containers k is greater than or equal to the number of elements n"
      ],
      "used_in": [
        "cmath_2027"
      ]
    },
    "Stirling Numbers of the Second Kind": {
      "name": "Stirling Numbers of the Second Kind",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The number of distinct elements"
        },
        {
          "name": "k",
          "typing": "integer",
          "description": "The exact number of non-empty subsets"
        }
      ],
      "description": "Counts the number of ways to partition a set of n labeled elements into exactly k non-empty unlabeled subsets.",
      "cues": [
        "distinct elements",
        "identical containers",
        "constraint on number of non-empty subsets"
      ],
      "implementation": [
        "Summed from i=1 to k to count partitions with at most k subsets when containers are limited"
      ],
      "used_in": [
        "cmath_2027"
      ]
    },
    "Set Partition Counting": {
      "name": "Set Partition Counting",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Modeling distribution problems where items are distinguishable and bins are indistinguishable as set partition problems.",
      "cues": [
        "distinct elements",
        "identical containers"
      ],
      "implementation": [
        "The initial conditional check identifies this scenario to apply partition counting formulas"
      ],
      "used_in": [
        "cmath_2027"
      ]
    },
    "Gap Method": {
      "name": "Gap Method",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "unrestricted_items",
          "typing": "list",
          "description": "The set of items that have no adjacency constraints."
        },
        {
          "name": "restricted_items",
          "typing": "list",
          "description": "The set of items that must not be adjacent to each other."
        }
      ],
      "description": "A combinatorial technique for counting arrangements where specific items must not be adjacent. It involves first arranging the unrestricted items, identifying the available \"gaps\" (including ends) between them, and then choosing distinct gaps to place the restricted items.",
      "cues": [
        "non-adjacent items or no two items together",
        "arrangement with separation constraints"
      ],
      "implementation": [
        "ARRANGE non_restricted_items and compute their distinct permutations",
        "GENERATE gaps from non_restricted_arrangement equal to (count + 1)",
        "SELECT positions for restricted_items from gaps using combinations to ensure non-adjacency",
        "COMPUTE valid_permutations = non_restricted_permutations * selection_ways"
      ],
      "used_in": [
        "cmath_2077"
      ]
    },
    "Multinomial Coefficient": {
      "name": "Multinomial Coefficient",
      "kind": "identity",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "total_count",
          "typing": "integer",
          "description": "The total number of items (n)."
        },
        {
          "name": "group_counts",
          "typing": "list of integers",
          "description": "The counts of each identical group (n1, n2, ...)."
        }
      ],
      "description": "A formula used to calculate the number of distinct permutations of a multiset (a set with repeated elements), given by n! / (n1! * n2! * ... * nk!).",
      "cues": [
        "distinct permutations of a multiset or items with repeated elements"
      ],
      "implementation": [
        "COMPUTE total_permutations using multinomial coefficient for all items combined"
      ],
      "used_in": [
        "cmath_2077"
      ]
    },
    "Probability as Ratio of Counts": {
      "name": "Probability as Ratio of Counts",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "favorable_count",
          "typing": "integer",
          "description": "The number of outcomes satisfying the specific condition."
        },
        {
          "name": "total_count",
          "typing": "integer",
          "description": "The total number of possible outcomes in the sample space."
        }
      ],
      "description": "Calculating the probability of an event in a uniform sample space by dividing the count of favorable outcomes by the count of total possible outcomes.",
      "cues": [
        "problem asks for probability of an event, arrangement, or configuration",
        "discrete uniform sample space implied",
        "ratio of favorable to total outcomes"
      ],
      "implementation": [
        "DERIVE probability = favorable_outcomes / total_outcomes",
        "SIMPLIFY probability to lowest terms m/n"
      ],
      "used_in": [
        "cmath_2077",
        "cmath_2190",
        "cmath_2286"
      ]
    },
    "Stars and Bars Theorem": {
      "name": "Stars and Bars Theorem",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "N",
          "typing": "integer",
          "description": "The target sum for the non-negative variables."
        },
        {
          "name": "k",
          "typing": "integer",
          "description": "Number of distinct bins available"
        },
        {
          "name": "n",
          "typing": "integer",
          "description": "Number of identical items to distribute"
        }
      ],
      "description": "Determines the number of non-negative integer solutions to a linear equation x_1 + ... + x_k = N using the binomial coefficient C(N+k-1, k-1).",
      "cues": [
        "distributing identical items into distinct bins or counting non-negative integer solutions to a linear sum equation (x_1 + ... + x_k = n)"
      ],
      "implementation": [
        "Map problem variables to theorem parameters (identical_items -> n, distinct_bins -> k)",
        "Verify constraints match non-negative integer solutions requirement",
        "Compute result using BinomialCoefficient(n + k - 1, k - 1)"
      ],
      "used_in": [
        "cmath_2102",
        "cmath_2428",
        "cmath_8896"
      ]
    },
    "Odd Integer Parametrization": {
      "name": "Odd Integer Parametrization",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "count",
          "typing": "integer",
          "description": "The number of odd integers to generate."
        },
        {
          "name": "start",
          "typing": "integer",
          "description": "The starting odd integer (default 1)."
        }
      ],
      "description": "Representing positive odd integers x as 2y + 1 where y >= 0 to transform constraints into standard non-negative integer forms suitable for combinatorial methods.",
      "cues": [
        "positive odd integers or sequences of odd numbers",
        "sum of odd numbers with parity constraints",
        "variables in the form 2k + 1"
      ],
      "implementation": [
        "Substitute x_i = 2*y_i + 1 to transform the sum equation into 2 * sum(y_i) + k = S, converting constraints to standard non-negative integer forms.",
        "{'Generate sequences of odd integers (e.g., first 100 odds': '1, 3, ..., 199) to define the domain for valuation or summation.'}"
      ],
      "used_in": [
        "cmath_2102",
        "cmath_5295"
      ]
    },
    "Parity Feasibility Check": {
      "name": "Parity Feasibility Check",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Verifying that the target sum and variable constraints have compatible parity to ensure integer solutions exist before counting.",
      "cues": [
        "linear Diophantine equation",
        "Variable expression has a fixed parity structure (e.g., 2n - 1 is always odd) requiring integer solutions"
      ],
      "implementation": [
        "Checked if (S - k) is odd or negative to return 0 early.",
        "Ensured compatibility between the parity of the divisor and the form 2n - 1 to guarantee integer n"
      ],
      "used_in": [
        "cmath_2102",
        "cmath_4759"
      ]
    },
    "Pairwise Combination Formula": {
      "name": "Pairwise Combination Formula",
      "kind": "formula",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The size of the set from which pairs are formed."
        }
      ],
      "description": "Calculates the number of unique pairs that can be formed from a set of n elements, given by the formula n(n-1)/2.",
      "cues": [
        "Round-robin tournament structures",
        "Handshake problems",
        "Counting edges in a complete graph",
        "Problems involving interactions between all distinct pairs of items",
        "Choosing 2 distinct items from a set",
        "Order irrelevant due to sorting constraint",
        "Product of geometric sequence terms",
        "Sum of arithmetic progression in exponent"
      ],
      "implementation": [
        "Calculated `total_games` as `num_teams * (num_teams - 1) / 2` to determine the total number of matches in the tournament.",
        "Computing ways_to_choose_prefix using Binomial_Coefficient(last_digit - 1, 2)",
        "Computed exponent of ratio r as n_terms * (n_terms - 1) / 2"
      ],
      "used_in": [
        "cmath_2104",
        "cmath_2476",
        "cmath_5291"
      ]
    },
    "Legendre's Formula": {
      "name": "Legendre's Formula",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The integer for which the factorial prime exponent is calculated."
        },
        {
          "name": "p",
          "typing": "prime",
          "description": "The prime number for which the exponent in the factorization is sought."
        },
        {
          "name": "prime",
          "typing": "integer",
          "description": "The prime number whose exponent in the prime factorization of n! is desired."
        }
      ],
      "description": "Computes the exponent of a prime p in the prime factorization of n! by summing the floor divisions of n by powers of p (sum_{k>=1} floor(n/p^k)).",
      "cues": [
        "Determining the exponent of a prime p in the factorization of n!",
        "Problems asking for the number of trailing zeros in a factorial",
        "Simplifying fractions or expressions involving factorials and prime powers"
      ],
      "implementation": [
        "Iterate through powers of p (p, p^2, ...), summing floor(n / p^k) until p^k > n.",
        "Commonly applied with p=5 to determine the number of trailing zeros in n!."
      ],
      "used_in": [
        "cmath_2104",
        "cmath_5031",
        "cmath_5545",
        "cmath_9126"
      ]
    },
    "Triangle Inequality Negation": {
      "name": "Triangle Inequality Negation",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Condition for three sorted lengths a <= b <= c to fail forming a triangle (a + b <= c).",
      "cues": [
        "triangle-free condition for three sorted elements (a + b <= c)"
      ],
      "implementation": [
        "Derive recurrence `next_val = sequence[-1] + sequence[-2]` from the non-triangle condition `a + b <= c`."
      ],
      "used_in": [
        "cmath_2114"
      ]
    },
    "Fibonacci Growth Extremal Bound": {
      "name": "Fibonacci Growth Extremal Bound",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "start_value",
          "typing": "int",
          "description": "The minimum integer value for the set elements."
        },
        {
          "name": "subset_size",
          "typing": "int",
          "description": "The target number of elements in the subset."
        }
      ],
      "description": "Constructing the minimal growth sequence (Fibonacci-like) satisfying a sum constraint to find the maximum range limit before a property becomes unavoidable.",
      "cues": [
        "maximize range",
        "subset size constraint",
        "sum of two elements",
        "avoid property"
      ],
      "implementation": [
        "Initialized sequence with `min_val`, `min_val + 1`.",
        "Iterated Fibonacci recurrence `next = prev1 + prev2`.",
        "Returned `sequence[-1] - 1` as the maximum valid bound."
      ],
      "used_in": [
        "cmath_2114"
      ]
    },
    "Fixed Element Counting": {
      "name": "Fixed Element Counting",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "total_elements",
          "typing": "integer",
          "description": "Total number of elements available (n)"
        },
        {
          "name": "subset_size",
          "typing": "integer",
          "description": "Target size of the subset (k)"
        },
        {
          "name": "fixed_inclusions",
          "typing": "integer",
          "description": "Number of elements that must be included"
        },
        {
          "name": "fixed_exclusions",
          "typing": "integer",
          "description": "Number of elements that must be excluded"
        }
      ],
      "description": "Counting subsets by fixing certain elements as required inclusions or exclusions, then choosing remaining elements from the reduced pool",
      "cues": [
        "Constraints specify certain elements must be included or excluded from a subset",
        "Problem reduces to choosing remaining elements from a reduced pool after fixing specific inclusions/exclusions",
        "Counting formula involves C(n - fixed_count, k - fixed_inclusions)"
      ],
      "implementation": [
        "Handle fixed inclusions by ensuring required elements are present (reducing target size k)",
        "Handle fixed exclusions by removing forbidden elements from the available pool (reducing total n)",
        "Calculate result as Combinations(n - excluded_count, k - included_count)"
      ],
      "used_in": [
        "cmath_2147"
      ]
    },
    "Symmetry Exclusion": {
      "name": "Symmetry Exclusion",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "symmetry_condition",
          "typing": "boolean expression",
          "description": "Condition that identifies the symmetric case to exclude"
        }
      ],
      "description": "Identifying and excluding symmetric or degenerate cases where constraints become contradictory or redundant",
      "cues": [
        "Two complementary structures have equal sizes or parameters, causing constraints to become contradictory or redundant"
      ],
      "implementation": [
        "Exclude the symmetric case (e.g., when size_A == size_B or k == n-k) using a conditional skip like a continue statement"
      ],
      "used_in": [
        "cmath_2147"
      ]
    },
    "Law of Total Probability": {
      "name": "Law of Total Probability",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Computes the probability of an event by summing the conditional probabilities of the event given each partition of the sample space, weighted by the probability of each partition.",
      "cues": [
        "Problem involves mutually exclusive scenarios or hypotheses",
        "Need to compute marginal or predictive probability by averaging conditional probabilities over a distribution of states"
      ],
      "implementation": [
        "Computed total or predictive probability by summing conditional probabilities weighted by prior or posterior probabilities of each scenario"
      ],
      "used_in": [
        "cmath_2163"
      ]
    },
    "Bayes' Theorem": {
      "name": "Bayes' Theorem",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Updates the probability of a hypothesis based on new evidence, relating posterior probability to prior probability and likelihood.",
      "cues": [
        "Problem asks for the probability of a cause given an effect, requiring inversion of conditional probability (P(H|E) from P(E|H)) or updating beliefs after observing data"
      ],
      "implementation": [
        "Calculate the posterior probability of each hypothesis by combining prior probabilities with the likelihood of the observed evidence"
      ],
      "used_in": [
        "cmath_2163"
      ]
    },
    "Posterior Predictive Calculation": {
      "name": "Posterior Predictive Calculation",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Computes the probability of a future event by averaging the conditional probabilities over the posterior distribution of hypotheses.",
      "cues": [
        "Sequential problems with unknown parameters or hidden states (e.g., mixture models) asking for probability of next observation given past data"
      ],
      "implementation": [
        "Calculated predictive probability of third roll being six using posterior weights of each die type"
      ],
      "used_in": [
        "cmath_2163"
      ]
    },
    "Grid Dynamic Programming": {
      "name": "Grid Dynamic Programming",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "grid_size",
          "typing": "integer",
          "description": "The dimensions of the grid (e.g., N x N)."
        },
        {
          "name": "base_cases",
          "typing": "map",
          "description": "Initial values for boundary conditions (e.g., DP[0][0] = 1)."
        },
        {
          "name": "transition_rule",
          "typing": "function",
          "description": "The recurrence relation defining a cell's value based on neighbors."
        }
      ],
      "description": "Solving problems by defining states on a 2D grid and computing values iteratively based on transitions from previous states (e.g., top, left, diagonal).",
      "cues": [
        "2D state space or grid structure",
        "Sequential dependency where state (i, j) depends on (i-1, j), (i, j-1), etc.",
        "Path counting or probability propagation problems"
      ],
      "implementation": [
        "Initialized a 2D DP table of size (N+1) x (N+1).",
        "Set base cases DP[0][0] = 1 and boundaries to 0.",
        "Filled the table using nested loops with the recurrence DP[i][j] = (1/3) * sum(neighbors)."
      ],
      "used_in": [
        "cmath_2167"
      ]
    },
    "Worst-Case Guarantee Threshold": {
      "name": "Worst-Case Guarantee Threshold",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "target_count",
          "typing": "integer",
          "description": "The number of groups or specific outcomes required."
        },
        {
          "name": "category_count",
          "typing": "integer",
          "description": "The number of distinct categories or bins available."
        },
        {
          "name": "group_size",
          "typing": "integer",
          "description": "The number of items required to form one unit of the target."
        }
      ],
      "description": "Determines the minimum number of items to select to guarantee a property by constructing the maximum possible selection that fails the property and adding one.",
      "cues": [
        "minimum number to guarantee",
        "worst-case scenario",
        "at least k",
        "problems involving drawing items from categories"
      ],
      "implementation": [
        "Calculated maximum socks held with target_pairs - 1 complete pairs.",
        "Added one unpaired sock per color to maximize count without forming additional pairs.",
        "Added 1 to the sum to ensure the target number of pairs is formed."
      ],
      "used_in": [
        "cmath_2185"
      ]
    },
    "Supply Feasibility Check": {
      "name": "Supply Feasibility Check",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "available_counts",
          "typing": "list of integers",
          "description": "The quantity of items available in each category."
        },
        {
          "name": "min_required_per_category",
          "typing": "integer",
          "description": "The minimum number of items needed from any single category to support the target."
        }
      ],
      "description": "Verifies if the available quantity in each category is sufficient to meet the minimum requirements for the target configuration.",
      "cues": [
        "limited supply",
        "is it possible",
        "constraints on individual category counts"
      ],
      "implementation": [
        "Checked if MIN(color_counts) is less than 2 * target_pairs and returned an error indicator if insufficient."
      ],
      "used_in": [
        "cmath_2185"
      ]
    },
    "Linear Recurrence Counting": {
      "name": "Linear Recurrence Counting",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "state_definition",
          "typing": "string",
          "description": "Definition of what the sequence term dp[i] represents."
        },
        {
          "name": "base_cases",
          "typing": "list",
          "description": "Initial values for the sequence."
        },
        {
          "name": "transition_rule",
          "typing": "equation",
          "description": "The recurrence relation expressing dp[i] in terms of previous terms."
        }
      ],
      "description": "Solving counting problems by defining a sequence where each term depends on previous terms based on how valid configurations can be extended.",
      "cues": [
        "counting valid sequences of length n with local constraints where solutions can be built from smaller subproblems"
      ],
      "implementation": [
        "Define dp[i] as the count of valid configurations of length i, establish base cases, and derive a transition rule based on how valid configurations can be extended (e.g., dp[i] = dp[i-1] + dp[i-2] for appending '0' or '01')."
      ],
      "used_in": [
        "cmath_2190"
      ]
    },
    "Geometric Distribution Expectation": {
      "name": "Geometric Distribution Expectation",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "p",
          "typing": "float",
          "description": "Probability of success in a single trial"
        }
      ],
      "description": "The expected number of independent Bernoulli trials needed to achieve the first success is the reciprocal of the probability of success (1/p).",
      "cues": [
        "expected number of trials",
        "until first success",
        "repeated independent trials"
      ],
      "implementation": [
        "Computing expected rolls per day E_day = 1 / p"
      ],
      "used_in": [
        "cmath_2286"
      ]
    },
    "Linearity of Expectation": {
      "name": "Linearity of Expectation",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "Number of independent trials or periods"
        },
        {
          "name": "E_single",
          "typing": "float",
          "description": "Expected value of a single trial or period"
        }
      ],
      "description": "The expected value of a sum of random variables is equal to the sum of their individual expected values. For n identical variables, E[Total] = n * E[Single].",
      "cues": [
        "Total expected value via sum of expectations",
        "Aggregating over independent periods"
      ],
      "implementation": [
        "Computing total expected value E_total = n * E_single"
      ],
      "used_in": [
        "cmath_2286"
      ]
    },
    "Constraint-Ordered Counting": {
      "name": "Constraint-Ordered Counting",
      "kind": "counting method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "A strategy for constructive counting where variables are assigned values in descending order of constraint strictness. This ensures the number of available choices for subsequent variables remains constant regardless of specific previous choices, avoiding case analysis.",
      "cues": [
        "Multiple overlapping constraints creating dependencies (e.g., distinctness, parity, non-zero, strictly increasing)",
        "Need to avoid case splitting by leveraging fixed order for combination logic"
      ],
      "implementation": [
        "Assign variables in descending order of constraint strictness (e.g., parity, non-zero) to ensure constant option counts, enabling calculation via combinations from the available pool without case analysis"
      ],
      "used_in": [
        "cmath_2385",
        "cmath_2476"
      ]
    },
    "Graph Modeling": {
      "name": "Graph Modeling",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "entities",
          "typing": "set",
          "description": "The objects to be represented as vertices."
        },
        {
          "name": "relationships",
          "typing": "set of pairs",
          "description": "The interactions to be represented as edges."
        }
      ],
      "description": "Translating a problem involving entities and pairwise relationships into a graph structure (vertices and edges) to leverage graph theoretic tools.",
      "cues": [
        "handshakes",
        "network structure or pairwise relationships between entities"
      ],
      "implementation": [
        "Model entities as Vertices V and relationships as Edges in Graph G"
      ],
      "used_in": [
        "cmath_2462"
      ]
    },
    "Minimum Degree Constraint": {
      "name": "Minimum Degree Constraint",
      "kind": "definition",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "k",
          "typing": "integer",
          "description": "The minimum number of edges incident to each vertex."
        }
      ],
      "description": "A requirement that every vertex in a graph must have a degree greater than or equal to a specified integer k.",
      "cues": [
        "every vertex must have at least k neighbors (degree >= k)",
        "minimum interaction requirement where everyone connects to k others"
      ],
      "implementation": [
        "{'Enforce constraint': 'degree(v) >= k for all v in V'}"
      ],
      "used_in": [
        "cmath_2462"
      ]
    },
    "Cycle Graph Edge Count": {
      "name": "Cycle Graph Edge Count",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The number of vertices in the cycle."
        }
      ],
      "description": "A simple cycle graph containing n vertices possesses exactly n edges.",
      "cues": [
        "circular arrangement or closed loop structure",
        "2-regular graph constraints (every vertex has degree 2) or minimizing edges to maintain degree 2 for all vertices"
      ],
      "implementation": [
        "A simple cycle graph with n vertices has exactly n edges (e.g., min_handshakes = n_people where each person shakes hands with exactly two others in a circle)"
      ],
      "used_in": [
        "cmath_2462"
      ]
    },
    "Minimal Square Multiplier": {
      "name": "Minimal Square Multiplier",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Determines the smallest positive integer required to multiply a given number to make it a perfect square by identifying prime factors with odd exponents in its factorization.",
      "cues": [
        "Problems asking to find the smallest integer k such that n*k is a perfect square"
      ],
      "implementation": [
        "Iterate through the aggregated prime exponents",
        "Multiply the result by the prime base whenever the total exponent is odd"
      ],
      "used_in": [
        "cmath_4681"
      ]
    },
    "LCM Equation Verification": {
      "name": "LCM Equation Verification",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Verifying if a candidate integer satisfies a specific Least Common Multiple equation LCM(x, n) = L.",
      "cues": [
        "Problem asks for integers satisfying an LCM equation of the form LCM(x, n) = K"
      ],
      "implementation": [
        "Using the condition LCM(ν, Base_Number) == Target_LCM to filter valid candidates"
      ],
      "used_in": [
        "cmath_4733"
      ]
    },
    "Terminating Decimal Criterion": {
      "name": "Terminating Decimal Criterion",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "A fraction in lowest terms has a terminating decimal representation if and only if its denominator's prime factorization contains only the primes 2 and 5. Otherwise, the decimal representation is repeating.",
      "cues": [
        "Questions about whether a fraction's decimal representation terminates or repeats",
        "Analysis of denominator prime factorization in fraction problems"
      ],
      "implementation": [
        "Determine if a fraction has a repeating decimal by checking if the denominator (in lowest terms) has prime factors other than 2 or 5",
        "Invert the terminating criterion to count fractions with non-terminating (repeating) decimals"
      ],
      "used_in": [
        "cmath_4771"
      ]
    },
    "Prime Factor Removal Check": {
      "name": "Prime Factor Removal Check",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Method to verify if a number contains prime factors beyond a specified set by repeatedly dividing out those known factors and checking if the remainder exceeds 1.",
      "cues": [
        "Need to verify if a number contains prime factors outside a specified set of known primes"
      ],
      "implementation": [
        "Repeatedly divide the number by each known prime factor until no longer divisible, then check if the remaining value is greater than 1 to confirm the existence of other prime factors"
      ],
      "used_in": [
        "cmath_4771"
      ]
    },
    "Consecutive Integer Coprimality": {
      "name": "Consecutive Integer Coprimality",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Any two consecutive positive integers are relatively prime, i.e., gcd(n, n+1) = 1 for all n ≥ 1.",
      "cues": [
        "Problems involving GCD calculations, fractions, or simplification where the numerator and denominator are consecutive integers (differ by 1)"
      ],
      "implementation": [
        "Establish that n/(n+1) is already in lowest terms (gcd(n, n+1)=1), allowing direct application of properties like the terminating decimal criterion to the denominator"
      ],
      "used_in": [
        "cmath_4771"
      ]
    },
    "Quadratic Residue Enumeration": {
      "name": "Quadratic Residue Enumeration",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "p",
          "typing": "integer",
          "description": "The prime modulus for which residues are computed."
        }
      ],
      "description": "Generates the set of quadratic residues modulo p by iterating through integers in a range, squaring them, and reducing modulo p.",
      "cues": [
        "Problem involves squares modulo n or finding values x such that x = k^2 mod n.",
        "Analysis of quadratic residues properties (e.g., sum, count)."
      ],
      "implementation": [
        "Iterate integers from 1 to p - 1, compute r = (n^2) mod p, and collect results into a set of residues."
      ],
      "used_in": [
        "cmath_4845"
      ]
    },
    "Divisor Counting Formula": {
      "name": "Divisor Counting Formula",
      "kind": "formula",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Computes the total number of positive divisors of an integer given its prime factorization exponents using the product of (exponent + 1).",
      "cues": [
        "Problem asks for the count of divisors and prime factorization (or its exponents) is available or computable"
      ],
      "implementation": [
        "Calculate the total number of divisors as the product of (exponent + 1) for each prime factor in the factorization"
      ],
      "used_in": [
        "cmath_4855",
        "cmath_5532"
      ]
    },
    "Prime Factorization": {
      "name": "Prime Factorization",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Decomposing an integer into a product of prime powers to analyze its arithmetic properties.",
      "cues": [
        "Need to decompose a composite integer into prime powers",
        "Analyzing multiplicative functions (e.g., divisor counting or summing)",
        "GCD/LCM calculations",
        "Factors of 10 (2 * 5) or trailing zeros"
      ],
      "implementation": [
        "Call prime_factorize to retrieve exponents for divisor count calculations or identify specific components (e.g., largest prime factor)",
        "Analyze trailing zeros by decomposing the base (e.g., 10 -> 2 * 5) and comparing factor abundances in n! (e.g., 2s vs 5s)"
      ],
      "used_in": [
        "cmath_4855",
        "cmath_4950",
        "cmath_5545"
      ]
    },
    "Perfect Square Verification": {
      "name": "Perfect Square Verification",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Checking if a given integer is the square of an integer, often by computing the integer square root and squaring it back.",
      "cues": [
        "Equations involving squares (e.g., a^2 + b^2 = n) or conditions requiring a value to be a perfect square"
      ],
      "implementation": [
        "Verify a number is a perfect square by computing its integer square root and squaring it back (e.g., checking if n - a^2 yields a valid b)"
      ],
      "used_in": [
        "cmath_4949"
      ]
    },
    "Ordered Pair Symmetry Counting": {
      "name": "Ordered Pair Symmetry Counting",
      "kind": "counting method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Counting ordered pairs (a, b) by iterating through unordered sets {a, b} and applying weights (2 for distinct elements, 1 for identical) to account for permutations.",
      "cues": [
        "Problem asks for ordered pairs but iteration constraints imply unordered generation (e.g., a <= b)",
        "Symmetric equations (e.g., a^2 + b^2 = n)"
      ],
      "implementation": [
        "Add 2 to count when a != b (accounting for (a,b) and (b,a)), or 1 when a == b (accounting for (a,a))"
      ],
      "used_in": [
        "cmath_4949"
      ]
    },
    "Incremental Search for Minimum": {
      "name": "Incremental Search for Minimum",
      "kind": "algorithmic pattern",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Iterating integers from a theoretical lower bound upwards to find the smallest value satisfying a predicate, allowing early termination.",
      "cues": [
        "Problem asks for the \"smallest\", \"first\", or \"minimum\" integer satisfying a condition within an ordered search space starting from a known lower bound."
      ],
      "implementation": [
        "Iterate integers upwards from the theoretical lower bound, checking the condition at each step, and terminate immediately upon finding the first match to guarantee the minimum solution."
      ],
      "used_in": [
        "cmath_4949",
        "cmath_5274"
      ]
    },
    "Factorial Sum Factorization": {
      "name": "Factorial Sum Factorization",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Simplifying a sum of factorials by factoring out the smaller factorial term to convert the expression into a product, facilitating divisibility or prime factor analysis.",
      "cues": [
        "Expression involves a sum of factorials (e.g., n! + m!) where the goal is to find divisors, prime factors, or simplify the expression"
      ],
      "implementation": [
        "Factor out the smaller factorial term from the sum to convert the expression into a product (e.g., n! + m! = n! * (1 + product_of_remaining_terms))"
      ],
      "used_in": [
        "cmath_4950"
      ]
    },
    "Largest Prime Factor of Factorial": {
      "name": "Largest Prime Factor of Factorial",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The integer defining the factorial"
        }
      ],
      "description": "The greatest prime factor of n! is the largest prime number less than or equal to n.",
      "cues": [
        "Determining the greatest prime factor of a factorial term n!"
      ],
      "implementation": [
        "Determined the largest prime factor of 12! is the largest prime <= 12"
      ],
      "used_in": [
        "cmath_4950"
      ]
    },
    "Modular Power Cycle": {
      "name": "Modular Power Cycle",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "base",
          "typing": "integer",
          "description": "The base of the power (e.g., the prime p)."
        },
        {
          "name": "modulus",
          "typing": "integer",
          "description": "The modulus for the cycle (e.g., 10 for ones digit)."
        },
        {
          "name": "exponent",
          "typing": "integer",
          "description": "The large exponent to be reduced."
        }
      ],
      "description": "Exploits the periodic sequence of powers of an integer modulo m to reduce large exponents by computing the exponent modulo the cycle length.",
      "cues": [
        "Computing last digits or residues of large powers (including power towers)",
        "Detecting periodicity in sequences of powers modulo m"
      ],
      "implementation": [
        "Determine the cycle length of base^k mod m, then reduce the exponent modulo this length (mapping 0 to the cycle length)."
      ],
      "used_in": [
        "cmath_5031",
        "cmath_5177",
        "cmath_5543"
      ]
    },
    "Base-b Digit Count Formula": {
      "name": "Base-b Digit Count Formula",
      "kind": "formula",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The positive integer value to be represented."
        },
        {
          "name": "b",
          "typing": "integer",
          "description": "The target base for representation (b >= 2)."
        }
      ],
      "description": "Calculates the number of digits required to represent a positive integer n in base b using the formula floor(log_b(n)) + 1.",
      "cues": [
        "Calculate the number of digits in a specific base",
        "log_base",
        "floor"
      ],
      "implementation": [
        "Apply floor(log_b(n)) + 1 to determine the digit count for a given integer n and base b."
      ],
      "used_in": [
        "cmath_5075"
      ]
    },
    "Euler's Totient Theorem": {
      "name": "Euler's Totient Theorem",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "base",
          "typing": "integer",
          "description": "The integer base 'a' which must be coprime to the modulus"
        },
        {
          "name": "modulus",
          "typing": "integer",
          "description": "The modulus 'n' for the congruence"
        }
      ],
      "description": "States that if gcd(a, n) = 1, then a^phi(n) ≡ 1 (mod n), allowing exponent reduction modulo phi(n).",
      "cues": [
        "Computing a^b mod n where b is large",
        "Base and modulus are coprime (especially if modulus is prime)"
      ],
      "implementation": [
        "Reduce exponent modulo phi(n) using a^phi(n) ≡ 1 (mod n) (use n-1 if modulus is prime)"
      ],
      "used_in": [
        "cmath_5177",
        "cmath_5421"
      ]
    },
    "Modular Exponentiation": {
      "name": "Modular Exponentiation",
      "kind": "algorithm",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "base",
          "typing": "integer",
          "description": "The base of the power"
        },
        {
          "name": "exponent",
          "typing": "integer",
          "description": "The reduced exponent"
        },
        {
          "name": "modulus",
          "typing": "integer",
          "description": "The modulus for the operation"
        }
      ],
      "description": "Efficiently computes (base^exponent) % modulus using binary exponentiation (square-and-multiply).",
      "cues": [
        "Computing a power modulo m",
        "Base and exponent may be large",
        "Exponent is manageable after reduction"
      ],
      "implementation": [
        "Compute base^exponent % modulus as the final step to obtain the result"
      ],
      "used_in": [
        "cmath_5177",
        "cmath_5421"
      ]
    },
    "Linear Congruence Resolution": {
      "name": "Linear Congruence Resolution",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "coeff",
          "typing": "integer",
          "description": "The coefficient 'a' of the variable x."
        },
        {
          "name": "constant",
          "typing": "integer",
          "description": "The constant term 'b' on the RHS."
        },
        {
          "name": "modulus",
          "typing": "integer",
          "description": "The modulus 'm'."
        }
      ],
      "description": "Solves a linear congruence equation ax ≡ b (mod m) by reducing coefficients via GCD and computing the modular inverse to isolate x.",
      "cues": [
        "Linear congruence equation ax ≡ b (mod m) requiring isolation of x."
      ],
      "implementation": [
        "Reduced equation by dividing coeff, constant, and modulus by g = GCD(coeff, modulus).",
        "Computed modular inverse of reduced coefficient to find the residue."
      ],
      "used_in": [
        "cmath_5178"
      ]
    },
    "Chinese Remainder Theorem": {
      "name": "Chinese Remainder Theorem",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "congruences",
          "typing": "list of tuples",
          "description": "List of (residue, modulus) pairs representing x ≡ residue (mod modulus)."
        }
      ],
      "description": "Constructs a unique solution modulo the product of moduli for a system of linear congruences with pairwise coprime moduli.",
      "cues": [
        "System of multiple modular congruences.",
        "Moduli are pairwise coprime.",
        "Need to find a single integer satisfying all conditions."
      ],
      "implementation": [
        "Computed M_total as the product of all reduced moduli.",
        "Iterated through each congruence to compute partial terms (N_i * y_i * residue).",
        "Summed partial terms modulo M_total to find the base solution x_0."
      ],
      "used_in": [
        "cmath_5178"
      ]
    },
    "Polynomial Divisibility Reduction": {
      "name": "Polynomial Divisibility Reduction",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "polynomial",
          "typing": "expression",
          "description": "The polynomial expression P(n) being divided."
        },
        {
          "name": "linear_divisor",
          "typing": "expression",
          "description": "The linear expression L(n) that divides P(n)."
        },
        {
          "name": "variable",
          "typing": "symbol",
          "description": "The variable n common to both expressions."
        }
      ],
      "description": "Transforms a divisibility condition where a linear polynomial divides another polynomial into a constant divisibility condition using the Polynomial Remainder Theorem.",
      "cues": [
        "Divisibility constraint involving a polynomial and a linear term in the same variable.",
        "Need to find integer values of the variable satisfying the condition."
      ],
      "implementation": [
        "Evaluate the polynomial at the root of the linear divisor to find the remainder.",
        "Reduce the condition to the linear divisor dividing the remainder."
      ],
      "used_in": [
        "cmath_5235"
      ]
    },
    "Binary-to-Base-k Digit Mapping": {
      "name": "Binary-to-Base-k Digit Mapping",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "index",
          "typing": "integer",
          "description": "The position n in the sequence (1-based or 0-based)."
        },
        {
          "name": "target_base",
          "typing": "integer",
          "description": "The base k used for the sequence values (e.g., 3 for sums of distinct powers of 3)."
        }
      ],
      "description": "Determines the n-th term of a sequence formed by integers having only digits 0 and 1 in base k by interpreting the binary representation of n as a number in base k. This relies on the order-preserving bijection between the binary index and the restricted-digit values.",
      "cues": [
        "Sequence elements are sums of distinct powers of a base (digits 0/1), forming an order-preserving bijection with binary integers",
        "Finding the n-th term of such a sequence"
      ],
      "implementation": [
        "Map binary coefficients of n to powers of the target base to compute the term directly, avoiding brute-force generation"
      ],
      "used_in": [
        "cmath_5236"
      ]
    },
    "Leading Digit via Logarithmic Fractional Part": {
      "name": "Leading Digit via Logarithmic Fractional Part",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "number_expression",
          "typing": "mathematical expression",
          "description": "The expression representing the large number (e.g., b^k)."
        },
        {
          "name": "log_base",
          "typing": "integer",
          "description": "The base of the logarithm, typically 10 for decimal leading digits."
        }
      ],
      "description": "Determines the leading digit of a number N by computing the fractional part f of log10(N) and evaluating floor(10^f), avoiding direct computation of N.",
      "cues": [
        "Problem asks for the leading digit of a large power or product.",
        "Direct computation of the number is infeasible due to size."
      ],
      "implementation": [
        "Computed fractional_part as {k * LOG_9} representing the fractional part of log10(9^k).",
        "Derived leading_digit using floor(10 ^ fractional_part)."
      ],
      "used_in": [
        "cmath_5246"
      ]
    },
    "Difference of Squares Characterization": {
      "name": "Difference of Squares Characterization",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "n",
          "typing": "integer",
          "description": "The integer to test for representability as a difference of squares."
        }
      ],
      "description": "An integer n can be expressed as the difference of two squares (a^2 - b^2) if and only if n is not congruent to 2 modulo 4. This arises because factors (a+b) and (a-b) must have the same parity.",
      "cues": [
        "Problem involves expressing numbers as a^2 - b^2.",
        "Constraints on parity or modulo 4 appear in the problem statement or derivation.",
        "Need to filter integers based on arithmetic properties rather than brute force."
      ],
      "implementation": [
        "Use the identity n = (a+b)(a-b) to deduce that factors must share parity (both odd or both even).",
        "Conclude that n cannot be congruent to 2 (mod 4), as this is the only case where factors would have differing parity.",
        "Filter out integers satisfying k ≡ 2 (mod 4) to identify valid candidates."
      ],
      "used_in": [
        "cmath_5260"
      ]
    },
    "Arithmetic Progression Count": {
      "name": "Arithmetic Progression Count",
      "kind": "formula",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "start",
          "typing": "integer",
          "description": "The first term of the arithmetic progression."
        },
        {
          "name": "step",
          "typing": "integer",
          "description": "The common difference between consecutive terms."
        },
        {
          "name": "limit",
          "typing": "integer",
          "description": "The upper bound for the terms."
        }
      ],
      "description": "Calculates the number of terms in an arithmetic progression (start, start+step, ...) that are less than or equal to a given limit.",
      "cues": [
        "Need to count integers (included or excluded) in a range that form a regular sequence with constant difference (e.g., satisfying a linear congruence).",
        "Range is large, requiring an O(1) formula instead of iteration."
      ],
      "implementation": [
        "Identify sequence parameters (start, step) from the condition (e.g., k ≡ 2 mod 4 implies start=2, step=4).",
        "{'Compute count using formula': 'FLOOR((limit - start) / step) + 1.'}"
      ],
      "used_in": [
        "cmath_5260"
      ]
    },
    "Sum of Squares Formula": {
      "name": "Sum of Squares Formula",
      "kind": "formula",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "k",
          "typing": "integer",
          "description": "The number of terms to sum (upper bound of the sequence 1^2 + ... + k^2)"
        }
      ],
      "description": "Expresses the sum of the first k positive squares as a cubic polynomial k(k+1)(2k+1)/6.",
      "cues": [
        "Define S(k) = k(k + 1)(2k + 1) / 6"
      ],
      "implementation": [
        "Replaces the iterative summation of squares with a closed-form polynomial expression.",
        "Allows efficient computation of S(k) for each candidate k during the search."
      ],
      "used_in": [
        "cmath_5274"
      ]
    },
    "Minimal Scaling Factor for Integrality": {
      "name": "Minimal Scaling Factor for Integrality",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "expressions",
          "typing": "list of rational linear forms",
          "description": "The set of expressions in terms of k that must evaluate to integers."
        },
        {
          "name": "k",
          "typing": "integer",
          "description": "The scaling factor to be minimized."
        }
      ],
      "description": "Determines the smallest positive integer parameter k such that a set of linear expressions in k evaluate to integers, typically by computing the LCM of the denominators of the coefficients.",
      "cues": [
        "least positive integer k such that quantities with rational coefficients are integers"
      ],
      "implementation": [
        "Analyze expressions in terms of k to identify denominators of rational coefficients, then compute their LCM to find the minimal k ensuring all quantities are integers."
      ],
      "used_in": [
        "cmath_5283"
      ]
    },
    "Linear Diophantine Non-negative Counting": {
      "name": "Linear Diophantine Non-negative Counting",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "coefficients",
          "typing": "list of integers",
          "description": "Coefficients A and B of the variables in the linear equation"
        },
        {
          "name": "target",
          "typing": "integer",
          "description": "The constant term C on the right hand side"
        }
      ],
      "description": "Counts non-negative integer solutions to a linear equation Ax + By = C by parameterizing the general solution and determining the valid range of the parameter.",
      "cues": [
        "Linear equation on integer variables",
        "Non-negativity constraints",
        "Counting valid solutions"
      ],
      "implementation": [
        "Parameterized solution for y, derived bounds for parameter k from x>=0 and y>=0"
      ],
      "used_in": [
        "cmath_5291"
      ]
    },
    "Balanced Base Contiguous Range": {
      "name": "Balanced Base Contiguous Range",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "powers_count",
          "typing": "integer",
          "description": "The number of digit positions (powers of the base) available."
        },
        {
          "name": "base",
          "typing": "integer",
          "description": "The radix of the number system."
        }
      ],
      "description": "States that a balanced base system with coefficients {-1, 0, 1} uniquely represents all integers within the continuous range [-M, M], where M is the maximum representable value, ensuring no gaps in the representable set.",
      "cues": [
        "balanced base system with symmetric digit set {-1, 0, 1}",
        "need to verify continuous integer range coverage without gaps"
      ],
      "implementation": [
        "justify that representable non-negative integers form a contiguous range [0, max_val] by calculating the cardinality of the full symmetric range [-M, M]"
      ],
      "used_in": [
        "cmath_5330"
      ]
    },
    "Consecutive Digit Sum Relation": {
      "name": "Consecutive Digit Sum Relation",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "S_n",
          "typing": "integer",
          "description": "The sum of digits of the integer n"
        },
        {
          "name": "S_next",
          "typing": "integer",
          "description": "The sum of digits of the integer n+1"
        },
        {
          "name": "k",
          "typing": "integer",
          "description": "The number of trailing 9s in the decimal representation of n (number of carries)"
        }
      ],
      "description": "Relates the sum of digits of consecutive integers n and n+1 via the formula S(n+1) = S(n) + 1 - 9k, where k is the number of trailing 9s in n. This implies S(n+1) <= S(n) + 1 and S(n+1) is congruent to S(n) + 1 modulo 9.",
      "cues": [
        "Problems involving digit sums of consecutive integers",
        "Divisibility by 9 in digit sum differences",
        "Inequality constraints between consecutive digit sums"
      ],
      "implementation": [
        "Calculated theoretical maximum digit sum for n+1 as S_n + 1",
        "Validated candidate digit sums by checking if the difference from the maximum is a non-negative multiple of 9"
      ],
      "used_in": [
        "cmath_5334"
      ]
    },
    "Exponential Growth Bounding": {
      "name": "Exponential Growth Bounding",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "exponential_terms",
          "typing": "list of expressions",
          "description": "The terms containing variables in exponents"
        },
        {
          "name": "constant",
          "typing": "integer",
          "description": "The target value the terms sum to or differ by"
        }
      ],
      "description": "Limiting the search space for variables in exponential equations by observing that terms grow rapidly relative to the constant value, ensuring the search space is finite and small.",
      "cues": [
        "Variables appear in exponents in an equation equal to a small constant"
      ],
      "implementation": [
        "Determining bounds for x and y such that 2^(2x) and 3^(2y) do not excessively exceed 55 before starting iteration"
      ],
      "used_in": [
        "cmath_5342"
      ]
    },
    "Greedy Prime Exponent Assignment": {
      "name": "Greedy Prime Exponent Assignment",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "exponents",
          "typing": "list[int]",
          "description": "The multiset of exponents derived from the problem constraints."
        },
        {
          "name": "prime_sequence",
          "typing": "list[int]",
          "description": "The ordered sequence of distinct primes (e.g., 2, 3, 5...) to be used as bases."
        }
      ],
      "description": "To minimize an integer N = product(p_i ^ e_i) given a fixed multiset of exponents, assign the largest exponents to the smallest distinct prime bases.",
      "cues": [
        "Problem asks for the minimum integer where the multiset of prime exponents is derived from structural constraints (e.g., divisor count).",
        "The choice of prime bases is flexible (not fixed by the problem)."
      ],
      "implementation": [
        "Sort derived exponents in descending order and assign them to consecutive primes starting from 2.",
        "Evaluate each valid exponent partition configuration to find the global minimum."
      ],
      "used_in": [
        "cmath_5475"
      ]
    },
    "Consecutive Product Divisibility": {
      "name": "Consecutive Product Divisibility",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "The product of any k consecutive integers is divisible by k!.",
      "cues": [
        "Polynomial expression factors into consecutive integer terms (e.g., (n-1)n(n+1))",
        "Problem involves divisibility of polynomial values over all integers"
      ],
      "implementation": [
        "Used to establish a theoretical baseline divisor (3! = 6) for the factored expression (n-1)n(n+1)"
      ],
      "used_in": [
        "cmath_5540"
      ]
    },
    "Fixed Divisor Determination": {
      "name": "Fixed Divisor Determination",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "Determining the largest integer that divides a polynomial's value for all integer inputs by computing the GCD of the polynomial's values at a sufficient set of sample points.",
      "cues": [
        "Problem asks for the largest integer that divides a polynomial's value for all integer inputs"
      ],
      "implementation": [
        "Evaluate the polynomial at a sufficient set of small integer points and compute the GCD of the resulting values to determine the universal divisor"
      ],
      "used_in": [
        "cmath_5540"
      ]
    },
    "Exponent Divisibility Threshold": {
      "name": "Exponent Divisibility Threshold",
      "kind": "number theory tool",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "base",
          "typing": "integer",
          "description": "The base of the exponential expression (e.g., 2)."
        },
        {
          "name": "modulus",
          "typing": "integer",
          "description": "The divisor used to check divisibility (e.g., 4)."
        },
        {
          "name": "threshold",
          "typing": "integer",
          "description": "The minimum exponent value n such that base^n is divisible by modulus for all n >= threshold."
        }
      ],
      "description": "Determines the minimum value of an exponent variable beyond which a base raised to that exponent is guaranteed to be divisible by a specific modulus, allowing constant-time reduction of tower exponents.",
      "cues": [
        "power tower exponent reduction with non-coprime bases or detecting exponent thresholds where base^n becomes divisible by modulus"
      ],
      "implementation": [
        "Determine the minimum exponent threshold where base^n is guaranteed divisible by the modulus, then use a conditional check to bypass modular reduction for exponents exceeding this threshold."
      ],
      "used_in": [
        "cmath_5543"
      ]
    },
    "Complementary Probability": {
      "name": "Complementary Probability",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "p_event",
          "typing": "float",
          "description": "Probability of the event occurring in a single trial."
        }
      ],
      "description": "Calculates the probability of an event occurring at least once by subtracting the probability of it never occurring from 1.",
      "cues": [
        "at least one success",
        "target probability",
        "minimum trials"
      ],
      "implementation": [
        "Step 1 converts target success probability to max allowed failure probability using 1 - p_success."
      ],
      "used_in": [
        "cmath_8735"
      ]
    },
    "Independent Event Probability Product": {
      "name": "Independent Event Probability Product",
      "kind": "theorem",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "probabilities",
          "typing": "list of float",
          "description": "List of probabilities for each independent event."
        }
      ],
      "description": "The probability of multiple independent events all occurring is the product of their individual probabilities.",
      "cues": [
        "independent trials",
        "repeated experiments",
        "all failures"
      ],
      "implementation": [
        "Step 2 models P(all failures) as (p_failure)^n."
      ],
      "used_in": [
        "cmath_8735"
      ]
    },
    "Logarithmic Exponent Isolation": {
      "name": "Logarithmic Exponent Isolation",
      "kind": "algebraic manipulation",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "base",
          "typing": "float",
          "description": "The base of the exponential term."
        },
        {
          "name": "target",
          "typing": "float",
          "description": "The value the exponential term is compared against."
        }
      ],
      "description": "Solving for an exponent variable in an exponential inequality by applying logarithms to both sides.",
      "cues": [
        "variable in exponent",
        "exponential inequality",
        "base < 1"
      ],
      "implementation": [
        "Step 3 solves n using log(max_allowed) / log(p_failure)."
      ],
      "used_in": [
        "cmath_8735"
      ]
    },
    "Minimum Integer Ceiling": {
      "name": "Minimum Integer Ceiling",
      "kind": "technique",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [
        {
          "name": "real_bound",
          "typing": "float",
          "description": "The real-valued solution to the inequality."
        }
      ],
      "description": "Converting a real-valued lower bound derived from an inequality into the minimum satisfying integer using the ceiling function.",
      "cues": [
        "minimum integer",
        "discrete trials",
        "inequality solution"
      ],
      "implementation": [
        "Step 4 applies ceiling to n_real to find n_min."
      ],
      "used_in": [
        "cmath_8735"
      ]
    },
    "Principle of Inclusion-Exclusion": {
      "name": "Principle of Inclusion-Exclusion",
      "kind": "counting method",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "A combinatorial technique to calculate the number of elements satisfying none of several properties by alternately adding and subtracting the sizes of intersections of subsets of properties.",
      "cues": [
        "Problem involves counting objects satisfying conditions (e.g., surjectivity, derangements) where constraints are defined by the exclusion of specific properties.",
        "Solution structure involves an alternating summation with terms like (-1)^k."
      ],
      "implementation": [
        "Sum over the number of excluded properties `i`, alternating signs using `(-1)^i`.",
        "Compute term magnitude as the product of ways to choose excluded properties and ways to satisfy the remaining constraints."
      ],
      "used_in": [
        "cmath_9112"
      ]
    }
  },
  "solutions": {
    "cmath_10550": {
      "problem_id": "cmath_10550",
      "solution": null,
      "summary": "Parametrize integers by their GCD to simplify LCM constraints, fix one factor, and maximize the other under coprimality and bound conditions.",
      "pseudocode": "Function MaximizeSumGivenGCDandLCM(gcd_val, lcm_multiplier, upper_bound):\n    // Parametrize integers as x = gcd_val * a, y = gcd_val * b with gcd(a, b) = 1\n    // LCM condition: LCM(x, y) = lcm_multiplier * x implies b = lcm_multiplier\n    fixed_factor = lcm_multiplier\n    fixed_num = gcd_val * fixed_factor\n    \n    // Determine maximum possible value for factor 'a' based on upper_bound\n    max_a = floor((upper_bound - 1) / gcd_val)\n    \n    // Find largest 'a' <= max_a such that gcd(a, fixed_factor) == 1\n    For a from max_a down to 1:\n        If gcd(a, fixed_factor) == 1:\n            variable_num = gcd_val * a\n            Return variable_num + fixed_num"
    },
    "cmath_10564": {
      "problem_id": "cmath_10564",
      "solution": null,
      "summary": "Compute the summation of the recursively defined sequence terms and extract the units digit via modulo 10.",
      "pseudocode": "DEFINE FUNCTION DoubleFactorial(n):\n    IF n <= 1 RETURN 1\n    RETURN n * DoubleFactorial(n - 2)\n\nINITIALIZE total_sum = 0\nFOR each odd integer i FROM 1 TO 49:\n    total_sum += DoubleFactorial(i)\n\nRETURN total_sum MOD 10"
    },
    "cmath_10590": {
      "problem_id": "cmath_10590",
      "solution": null,
      "summary": "Convert base-specific digit constraints to base-10 value ranges, compute their intersection, and calculate the mean of the resulting consecutive integer sequence.",
      "pseudocode": "FUNCTION get_base_range(num_digits, base):\n    # Smallest number with n digits in base b is b^(n-1)\n    min_val = base^(num_digits - 1)\n    # Largest number with n digits in base b is b^n - 1\n    max_val = base^num_digits - 1\n    RETURN (min_val, max_val)\n\nFUNCTION solve():\n    # Convert base-specific digit constraints to base-10 value ranges\n    range_base3 = get_base_range(4, 3)\n    range_base6 = get_base_range(2, 6)\n    \n    # Find the intersection of the two value ranges\n    intersection_start = MAX(range_base3.min, range_base6.min)\n    intersection_end = MIN(range_base3.max, range_base6.max)\n    \n    # Calculate the average of the consecutive integers in the intersection\n    IF intersection_start <= intersection_end:\n        # Average of an arithmetic progression of consecutive integers\n        average = (intersection_start + intersection_end) / 2\n        RETURN average\n    ELSE:\n        RETURN 0"
    },
    "cmath_10600": {
      "problem_id": "cmath_10600",
      "solution": null,
      "summary": "Convert base-b numerals to polynomials in b and search for the integer root exceeding the maximum digit.",
      "pseudocode": "1. Identify the maximum digit D present in all numbers within the equation\n2. Set the minimum valid base b_min = D + 1\n3. Convert each number from base-b representation to a polynomial in b\n   (e.g., digits d_n...d_0 map to sum(d_i * b^i))\n4. Construct the algebraic equation: Polynomial(operand1) * Polynomial(operand2) = Polynomial(result)\n5. Iterate integer b starting from b_min upwards\n6. Evaluate the equation for each b\n7. Return the first b where the equation holds true"
    },
    "cmath_10604": {
      "problem_id": "cmath_10604",
      "solution": null,
      "summary": "Generate all possible sums via Cartesian product with replacement, collect distinct values, and compute their total.",
      "pseudocode": "Define value_set = {2, 4, 8}\nDefine pick_count = 3\nGenerate all outcomes via Cartesian_Product(value_set, repeat=pick_count)\nMap each outcome to its sum\nStore sums in a Set to ensure uniqueness\nCompute final answer as the Sum of all elements in the Set"
    },
    "cmath_10610": {
      "problem_id": "cmath_10610",
      "solution": null,
      "summary": "Derive the exponent for the product of proper divisors using the divisor count formula, equate coefficients with the given expression, and solve for parameters under GCD constraints.",
      "pseudocode": "Function CalculateParameterSum():\n    // Step 1: Establish the formula for the product of all divisors\n    // Concept: Product of divisors of n with count x is n^(x/2)\n    Let exponent_all = x / 2\n    \n    // Step 2: Adjust for proper divisors (exclude n itself)\n    // Concept: Proper product = Total product / n\n    Let exponent_proper = exponent_all - 1\n    Simplify exponent_proper to (x - 2) / 2\n    \n    // Step 3: Equate derived exponent to the given parameterized form\n    // Given form: (a*x + b) / c\n    Set (a*x + b) / c == (x - 2) / 2\n    \n    // Step 4: Solve for parameters by matching coefficients of x and constants\n    // Concept: Identity in x implies coefficients must match\n    Match coefficient of x: a/c = 1/2  => c = 2a\n    Match constant term: b/c = -1      => b = -c\n    \n    // Step 5: Determine integer values satisfying GCD constraint\n    // Constraint: gcd(a, b, c) = 1 and c > 0\n    Substitute c = 2a into b = -c => b = -2a\n    Ratio a : b : c is 1 : -2 : 2\n    Set a = 1, b = -2, c = 2 (satisfies gcd(1, -2, 2) = 1)\n    \n    // Step 6: Compute final result\n    Return a + b + c"
    },
    "cmath_10619": {
      "problem_id": "cmath_10619",
      "solution": null,
      "summary": "Classify integers with exactly four divisors as prime cubes or products of two distinct primes, generate candidates from small primes, and sum the five smallest.",
      "pseudocode": "FUNCTION SolveSmallestFourFactorSum(k):\n    // Concept: Divisor Count Structure\n    // An integer n has exactly 4 factors iff n = p^3 OR n = p * q (p, q distinct primes)\n    \n    primes = GENERATE_FIRST_N_PRIMES(sufficient_limit)\n    candidates = EMPTY_LIST\n    \n    // Generate Case 1: Cube of a prime\n    FOR EACH p IN primes:\n        APPEND p^3 TO candidates\n        \n    // Generate Case 2: Product of two distinct primes\n    FOR EACH pair (p, q) IN primes WHERE p < q:\n        APPEND p * q TO candidates\n        \n    // Selection and Aggregation\n    SORT candidates ASCENDING\n    smallest_k = TAKE_FIRST(candidates, k)\n    \n    RETURN SUM(smallest_k)"
    },
    "cmath_10621": {
      "problem_id": "cmath_10621",
      "solution": null,
      "summary": "Iterate through the valid range and count integers satisfying the single-digit GCD constraint with 100.",
      "pseudocode": "Initialize count to 0\nFor each integer m from 1 to 99:\n    Compute g = gcd(m, 100)\n    If g is a single-digit number (1 <= g <= 9):\n        Increment count\nReturn count"
    },
    "cmath_10627": {
      "problem_id": "cmath_10627",
      "solution": null,
      "summary": "Use prime valuation properties of LCM to derive the exponent of 2 in $m$, then determine the specific value using the 3-digit constraint.",
      "pseudocode": "Function SolveLCMEquation():\n    Decompose constants into prime factors: 10^10 = 2^10 * 5^10, 8 = 2^3, 4 = 2^2\n    Represent m as 2^a * 5^b * k, where gcd(k, 10) = 1\n    \n    // Apply property: v_p(lcm(x, y)) = max(v_p(x), v_p(y))\n    For prime p in {2, 5}:\n        LHS_val = max(v_p(8m), v_p(10^10))\n        RHS_val = v_p(4) + max(v_p(m), v_p(10^10))\n        Set LHS_val = RHS_val to form exponent equations\n    \n    Solve exponent equation for p=2: max(a + 3, 10) = 2 + max(a, 10)\n        Case 1 (a >= 7): a + 3 = 12 => a = 9\n        Case 2 (a < 7): 10 = a + 2 => a = 8 (Invalid)\n        Determine a = 9\n    \n    Solve exponent equation for p=5: max(b, 10) = max(b, 10)\n        Determine b is unconstrained by equation\n    \n    Construct candidate m = 2^9 * 5^b * k = 512 * 5^b * k\n    Apply constraint: 100 <= m <= 999\n    Find unique integers b >= 0, k >= 1 satisfying range\n    Return m"
    },
    "cmath_10630": {
      "problem_id": "cmath_10630",
      "solution": null,
      "summary": "Compute the prime factorization of the number and multiply the count of valid even exponent choices ($\\lfloor e/2 \\rfloor + 1$) for each prime factor.",
      "pseudocode": "FUNCTION count_perfect_square_factors(N):\n    factorization = get_prime_factorization(N)  // Returns {prime: exponent}\n    total_count = 1\n    FOR each exponent e IN factorization.values():\n        // Exponents in a perfect square factor must be even (0, 2, ..., 2k <= e)\n        num_even_choices = floor(e / 2) + 1\n        total_count = total_count * num_even_choices\n    RETURN total_count"
    },
    "cmath_10637": {
      "problem_id": "cmath_10637",
      "solution": null,
      "summary": "Determine valid bases by counting divisors of the difference between the number and the target digit that exceed the digit value.",
      "pseudocode": "INPUT: Integer N = 2013, Target Digit d = 3\nDERIVE: Condition for last digit d in base b is N mod b = d\nTRANSFORM: This implies b divides (N - d)\nCOMPUTE: Difference M = N - d = 2010\nFIND: Set of all positive divisors D of M\nAPPLY CONSTRAINT: Base b must be strictly greater than digit d (b > 3)\nFILTER: Valid Bases = {b in D | b > d}\nOUTPUT: Count of Valid Bases"
    },
    "cmath_10664": {
      "problem_id": "cmath_10664",
      "solution": null,
      "summary": "Equate the denominator to all integer divisors of the numerator, solve for the variable, and sum the resulting integer solutions.",
      "pseudocode": "1. Identify the condition: For the fraction to be an integer, the Denominator must divide the Numerator\n2. Find all integer divisors D of the Numerator (including negative divisors)\n3. Initialize ValidSum = 0\n4. For each divisor d in D:\n    a. Set Denominator Expression = d\n    b. Solve the resulting equation for x\n    c. Check if x is an integer\n    d. If x is an integer, add x to ValidSum\n5. Return ValidSum"
    },
    "cmath_10691": {
      "problem_id": "cmath_10691",
      "solution": null,
      "summary": "Count multiples of the truth and response divisors and their LCM to calculate correct answers using set difference logic.",
      "pseudocode": "FUNCTION calculate_correct_answers(total_items, true_divisor, mark_false_divisor, lcm_divisor):\n    // Count items satisfying the actual truth condition (multiples of 4)\n    count_actual_true <- FLOOR(total_items / true_divisor)\n    \n    // Count items satisfying the student's false marking condition (multiples of 3)\n    count_marked_false <- FLOOR(total_items / mark_false_divisor)\n    \n    // Count items satisfying both conditions (multiples of 12)\n    count_intersection <- FLOOR(total_items / lcm_divisor)\n    \n    // Correct True: Actually True AND Student marks True (not marked false)\n    correct_true <- count_actual_true - count_intersection\n    \n    // Correct False: Actually False AND Student marks False\n    correct_false <- count_marked_false - count_intersection\n    \n    RETURN correct_true + correct_false"
    },
    "cmath_10695": {
      "problem_id": "cmath_10695",
      "solution": null,
      "summary": "Translate base representations into polynomial equations, derive a linear relationship between the bases, and solve the resulting quadratic equation for positive integer solutions.",
      "pseudocode": "PROCEDURE SolveBaseSystem:\n    // Step 1: Convert base-c representation to algebraic equation\n    // Concept: Base Expansion (Polynomial Form)\n    EQUATION_1 <- b^2 = 1*c^2 + 2*c + 1\n    \n    // Step 2: Simplify to find relationship between b and c\n    // Concept: Factoring Perfect Squares\n    SIMPLIFY EQUATION_1 TO b^2 = (c + 1)^2\n    DERIVE LINEAR_RELATION: b = c + 1 (since b, c > 0)\n    \n    // Step 3: Convert base-b representation to algebraic equation\n    // Concept: Base Expansion (Polynomial Form)\n    EQUATION_2 <- c^2 = 7*b + 1\n    \n    // Step 4: Combine equations to solve for one variable\n    // Concept: Substitution\n    SUBSTITUTE LINEAR_RELATION INTO EQUATION_2\n    FORM_QUADRATIC: c^2 - 7c - 8 = 0\n    \n    // Step 5: Solve quadratic and apply domain constraints\n    // Concept: Quadratic Formula & Integer Constraints\n    ROOTS <- SOLVE(c^2 - 7c - 8 = 0)\n    c <- SELECT root FROM ROOTS WHERE root > 0 AND root IS INTEGER\n    \n    // Step 6: Compute final result\n    b <- c + 1\n    RETURN b + c\nEND PROCEDURE"
    },
    "cmath_10731": {
      "problem_id": "cmath_10731",
      "solution": null,
      "summary": "Model consumption fractions as a linear equation, apply divisibility constraints to simplify variables, and solve the resulting Diophantine equation for the family size.",
      "pseudocode": "Define M as total milk ounces, C as total coffee ounces\nSet up equation based on Angela's consumption: M/4 + C/6 = 8\nSimplify equation to integer coefficients: 3M + 2C = 96\nApply constraint: M and C must be multiples of 8 (let M = 8m, C = 8c)\nSubstitute constraints into simplified equation: 3m + 2c = 12\nIterate through positive integer values for m\n  Calculate c = (12 - 3m) / 2\n  If c is a positive integer:\n    Compute family size n = m + c\n    Return n"
    },
    "cmath_10774": {
      "problem_id": "cmath_10774",
      "solution": null,
      "summary": "Compute the modular multiplicative inverse of 160 modulo 1399 using the Extended Euclidean Algorithm to solve the linear Diophantine equation $160x + 1399y = 1$.",
      "pseudocode": "FUNCTION extended_gcd(a, b):\n    IF a == 0:\n        RETURN (b, 0, 1)\n    (gcd, x1, y1) <- extended_gcd(b MOD a, a)\n    x <- y1 - (b DIV a) * x1\n    y <- x1\n    RETURN (gcd, x, y)\n\nFUNCTION mod_inverse(a, m):\n    (gcd, x, y) <- extended_gcd(a, m)\n    ASSERT gcd == 1  // Verify existence of inverse\n    RETURN (x MOD m) // Normalize to range [0, m-1]\n\nFUNCTION solve():\n    n <- mod_inverse(160, 1399)\n    RETURN n"
    },
    "cmath_10816": {
      "problem_id": "cmath_10816",
      "solution": null,
      "summary": "Exhaustively enumerate all permutations and count those satisfying the pairwise consecutive coprime constraint.",
      "pseudocode": "Define digit set D = {1, 2, 3, 4, 5, 6}\nInitialize valid_count = 0\nGenerate all permutations P of D\nFor each permutation p in P:\n    is_valid = True\n    For each adjacent pair (u, v) in p:\n        If gcd(u, v) > 1:\n            is_valid = False\n            Break\n    If is_valid:\n        valid_count = valid_count + 1\nReturn valid_count"
    },
    "cmath_10822": {
      "problem_id": "cmath_10822",
      "solution": null,
      "summary": "Convert base-specific digit constraints to base 10 intervals, find their intersection, and compute the average of the resulting consecutive integers using the arithmetic mean property.",
      "pseudocode": "function solve():\n    // Determine base 10 range for 3-digit base 5 numbers\n    min_5 = value of smallest 3-digit number in base 5 (100_5)\n    max_5 = value of largest 3-digit number in base 5 (444_5)\n    \n    // Determine base 10 range for 2-digit base 8 numbers\n    min_8 = value of smallest 2-digit number in base 8 (10_8)\n    max_8 = value of largest 2-digit number in base 8 (77_8)\n    \n    // Find intersection of valid integer ranges\n    valid_min = max(min_5, min_8)\n    valid_max = min(max_5, max_8)\n    \n    // Calculate average of consecutive integers [valid_min, valid_max]\n    // Concept: Mean of arithmetic progression is (first + last) / 2\n    result = (valid_min + valid_max) / 2\n    \n    return result"
    },
    "cmath_10860": {
      "problem_id": "cmath_10860",
      "solution": null,
      "summary": "Compute the prime factorization exponents of the product and multiply (floor(e/3) + 1) for each exponent to count valid cube divisors.",
      "pseudocode": "1. Compute N = 3! * 5! * 7!\n2. Determine the prime factorization of N to get the set of exponents {e_1, e_2, ..., e_k}\n3. Initialize cube_divisor_count = 1\n4. For each exponent e in {e_1, ..., e_k}:\n    cube_divisor_count *= (floor(e / 3) + 1)\n5. Return cube_divisor_count"
    },
    "cmath_10934": {
      "problem_id": "cmath_10934",
      "solution": null,
      "summary": "Determine the number of multiples of the root power within each prime exponent's range and multiply these counts.",
      "pseudocode": "Function CountPerfectPowerFactors(PrimeExponents, RootPower):\n    TotalCombinations = 1\n    For each exponent E in PrimeExponents:\n        # A factor's exponent x must satisfy 0 <= x <= E\n        # For a perfect RootPower, x must be a multiple of RootPower\n        # Valid x values are {0, RootPower, 2*RootPower, ...}\n        NumValidChoices = Floor(E / RootPower) + 1\n        TotalCombinations = TotalCombinations * NumValidChoices\n    Return TotalCombinations\n\n# Problem Application\nExponents = [6, 10]  # From 3^6 * 5^10\nRootPower = 3        # Perfect cube\nResult = CountPerfectPowerFactors(Exponents, RootPower)"
    },
    "cmath_10942": {
      "problem_id": "cmath_10942",
      "solution": null,
      "summary": "Apply the identity $a^{-1}+b^{-1}=(a+b)(ab)^{-1}$ to simplify the expression and cancel the $(a+b)$ term.",
      "pseudocode": "Function SolveModularExpression(n, a, b):\n    Input: n >= 3, (ab) invertible mod n, (ab)^(-1) ≡ 2 mod n, (a+b) invertible mod n\n    Target: Compute E = (a+b)^(-1) * (a^(-1) + b^(-1)) mod n\n\n    // Step 1: Simplify sum of inverses using algebraic identity\n    // Identity: 1/a + 1/b = (a+b)/(ab)\n    Transform: (a^(-1) + b^(-1)) ≡ (a + b) * (ab)^(-1) mod n\n\n    // Step 2: Substitute the given value for the inverse of the product\n    Substitute: (ab)^(-1) → 2\n    Result: (a^(-1) + b^(-1)) ≡ 2 * (a + b) mod n\n\n    // Step 3: Evaluate the target expression\n    Substitute: E ≡ (a + b)^(-1) * [2 * (a + b)] mod n\n\n    // Step 4: Cancel terms using the inverse property\n    // Property: x^(-1) * x ≡ 1 mod n\n    Rearrange: E ≡ 2 * [(a + b)^(-1) * (a + b)] mod n\n    Simplify: E ≡ 2 * 1 mod n\n\n    Return 2"
    },
    "cmath_10978": {
      "problem_id": "cmath_10978",
      "solution": null,
      "summary": "Directly evaluate the sum of products of consecutive modular inverses modulo p by iterating through all terms.",
      "pseudocode": "Function EvaluateInverseSum(p):\n    Input: Prime integer p >= 7\n    Verify p satisfies constraints (p >= 7, p is prime)\n    Initialize Sum S = 0\n    For each integer k from 1 to p-2:\n        Compute modular inverse inv_k = k^(-1) mod p\n        Compute modular inverse inv_k1 = (k+1)^(-1) mod p\n        Term = (inv_k * inv_k1) mod p\n        S = (S + Term) mod p\n    Return S"
    },
    "cmath_10993": {
      "problem_id": "cmath_10993",
      "solution": null,
      "summary": "Partition the residue system modulo $n$ based on coprimality to compute the difference between the sums of invertible and non-invertible elements.",
      "pseudocode": "Define modulus n = 2^4\nDefine ResidueSystem = {0, 1, ..., n-1}\nDefine Condition(x): gcd(x, n) == 1  // Invertibility check\nA = Sum(x for x in ResidueSystem where Condition(x) is True)\nB = Sum(x for x in ResidueSystem where Condition(x) is False)\nResult = A - B\nReturn Result"
    },
    "cmath_10998": {
      "problem_id": "cmath_10998",
      "solution": null,
      "summary": "Parameterize $a$ and $b$ via GCD to reduce the problem to counting ordered coprime factor pairs of the quotient $\\text{lcm}/\\gcd$.",
      "pseudocode": "Function CountValidValues(gcd_val, lcm_val):\n    // Mathematical Reduction:\n    // Let a = gcd_val * m and b = gcd_val * n\n    // Condition gcd(a, b) = gcd_val implies gcd(m, n) = 1\n    // Condition lcm(a, b) = lcm_val implies m * n = lcm_val / gcd_val\n    \n    target_product = lcm_val / gcd_val\n    count = 0\n    \n    // Algorithmic Pattern: Iterate divisors up to square root to find pairs (m, n)\n    For m from 1 to floor(sqrt(target_product)):\n        If target_product % m == 0:\n            n = target_product / m\n            \n            // Check Properties: Coprimality and Order (a < b => m < n)\n            If gcd(m, n) == 1 AND m < n:\n                count = count + 1\n                \n    Return count"
    },
    "cmath_11055": {
      "problem_id": "cmath_11055",
      "solution": null,
      "summary": "Simplify the modular equation to a linear congruence, derive the general solution, and calculate the smallest value meeting the digit constraint.",
      "pseudocode": "Simplify congruence: Subtract r^2 and combine terms to get 2r ≡ -3 (mod 55)\nNormalize residue: Convert -3 to 52 mod 55, yielding 2r ≡ 52 (mod 55)\nSolve linear congruence: Divide by 2 (valid since gcd(2, 55)=1) to get r ≡ 26 (mod 55)\nFormulate general solution: r = 26 + 55 * k for integer k\nApply range constraint: Set inequality 26 + 55 * k ≥ 1000 for least four-digit number\nDetermine minimal k: Solve k ≥ (1000 - 26) / 55 and take ceiling integer\nCompute final solution: Substitute minimal k back into general solution formula"
    },
    "cmath_1854": {
      "problem_id": "cmath_1854",
      "solution": null,
      "summary": "Calculate the product of possible quantities for each identical item type and subtract the empty selection case.",
      "pseudocode": "FUNCTION count_non_empty_selections(item_counts):\n    total_combinations = 1\n    FOR count IN item_counts:\n        // For identical items, possible choices range from 0 to count\n        choices_per_type = count + 1\n        // Apply multiplication principle for independent choices\n        total_combinations = total_combinations * choices_per_type\n    // Apply exclusion principle to remove the empty set case (all zeros)\n    RETURN total_combinations - 1"
    },
    "cmath_1970": {
      "problem_id": "cmath_1970",
      "solution": null,
      "summary": "Apply complementary counting by subtracting the combinatorial count of integers with distinct digits from the total number of integers in the specified range.",
      "pseudocode": "FUNCTION Solve(RangeMin, RangeMax):\n    // Step 1: Calculate Total Integers in Range\n    TotalCount = RangeMax - RangeMin + 1\n    \n    // Step 2: Calculate Integers with All Distinct Digits (Complementary Set)\n    // Using Multiplication Principle for Permutations\n    HundredsChoices = CountValidDigitsForPlace(Place=100, Constraint=RangeMax) // e.g., 1-4\n    TensChoices = 10 - 1 // Any digit 0-9 except Hundreds digit\n    UnitsChoices = 10 - 2 // Any digit 0-9 except Hundreds and Tens digits\n    \n    DistinctCount = HundredsChoices * TensChoices * UnitsChoices\n    \n    // Step 3: Apply Complementary Counting\n    // Target = Total - (Count where condition is NOT met)\n    ResultCount = TotalCount - DistinctCount\n    \n    RETURN ResultCount\nEND FUNCTION"
    },
    "cmath_1988": {
      "problem_id": "cmath_1988",
      "solution": null,
      "summary": "Exhaustively iterate through all 3-digit numbers and count those where the middle digit is strictly greater than the outer digits.",
      "pseudocode": "count <- 0\nDEFINE domain D = {n | 100 <= n <= 999}\nFOR each n IN D:\n    (d1, d2, d3) <- decimal_digits(n)\n    IF d2 > d1 AND d2 > d3:\n        count <- count + 1\nRETURN count"
    },
    "cmath_2027": {
      "problem_id": "cmath_2027",
      "solution": null,
      "summary": "Model the distribution of distinct items into identical containers as a set partition problem solved using Bell numbers.",
      "pseudocode": "FUNCTION count_distributions(distinct_elements, identical_containers):\n    n = size(distinct_elements)\n    k = size(identical_containers)\n    IF containers are identical AND elements are distinct:\n        IF k >= n:\n            # Sufficient containers allow all set partitions\n            RETURN Bell_Number(n)\n        ELSE:\n            # Limit partitions to at most k non-empty subsets\n            RETURN SUM(Stirling_Second_Kind(n, i) for i in 1 to k)\n    RETURN 0"
    },
    "cmath_2077": {
      "problem_id": "cmath_2077",
      "solution": null,
      "summary": "Use the gap method by arranging non-restricted items to create slots for restricted items to ensure non-adjacency, then calculate the probability ratio.",
      "pseudocode": "IDENTIFY restricted_items and non_restricted_items with their respective counts\nCOMPUTE total_permutations using multinomial coefficient for all items combined\nARRANGE non_restricted_items and compute their distinct permutations\nGENERATE gaps from non_restricted_arrangement equal to (count + 1)\nSELECT positions for restricted_items from gaps using combinations to ensure non-adjacency\nCOMPUTE valid_permutations = non_restricted_permutations * selection_ways\nDERIVE probability = valid_permutations / total_permutations\nSIMPLIFY probability to lowest terms m/n\nOUTPUT m + n"
    },
    "cmath_2100": {
      "problem_id": "cmath_2100",
      "solution": null,
      "summary": "Generate candidates satisfying local constraints and filter by global constraints.",
      "pseudocode": "1. Precompute the set of all valid rows satisfying the local row sum constraint.\n2. Initialize a counter for valid matrices to 0.\n3. Iterate through all possible matrices formed by combining valid rows (Cartesian product).\n4. For each matrix, verify if it satisfies the global column sum constraints.\n5. If constraints are met, increment the counter.\n6. Return the final count."
    },
    "cmath_2102": {
      "problem_id": "cmath_2102",
      "solution": null,
      "summary": "Transform positive odd integer variables into non-negative integers via linear substitution, then apply the stars and bars combinatorial theorem to count the solutions.",
      "pseudocode": "Function SolveOddSumPartition(TargetSum S, NumVariables k):\n    // Step 1: Transform Constraints\n    // Each x_i is a positive odd integer, so let x_i = 2*y_i + 1 where y_i >= 0\n    // Substitute into equation: sum(2*y_i + 1) = S\n    // Simplify: 2 * sum(y_i) + k = S\n    \n    // Step 2: Determine New Target Sum\n    If (S - k) is odd or (S - k) < 0:\n        Return 0 // No valid integer solution\n    NewSum N = (S - k) / 2\n    \n    // Step 3: Count Non-Negative Solutions\n    // Apply Stars and Bars theorem for sum(y_i) = N with k variables\n    // Count = C(N + k - 1, k - 1)\n    n = BinomialCoefficient(N + k - 1, k - 1)\n    \n    // Step 4: Final Computation\n    Return n / 100\nEnd Function\n\n// Execute for specific problem\nResult = SolveOddSumPartition(98, 4)\nPrint Result"
    },
    "cmath_2104": {
      "problem_id": "cmath_2104",
      "solution": null,
      "summary": "Calculate total games to determine the probability space, treat unique win distributions as team permutations, and use Legendre's formula to compute the exponent of 2 in the simplified denominator.",
      "pseudocode": "FUNCTION CalculateLog2Denominator(num_teams):\n    // 1. Determine total games in a round-robin tournament\n    total_games <- num_teams * (num_teams - 1) / 2\n    \n    // 2. Identify probability structure: P = num_teams! / 2^(total_games)\n    // The denominator n in simplified form m/n depends on factors of 2\n    \n    // 3. Calculate the exponent of 2 in num_teams! using Legendre's Formula\n    v2_factorial <- 0\n    divisor <- 2\n    WHILE divisor <= num_teams:\n        v2_factorial <- v2_factorial + FLOOR(num_teams / divisor)\n        divisor <- divisor * 2\n    END WHILE\n    \n    // 4. Compute log2(n) by subtracting cancelled factors from total games\n    log2_n <- total_games - v2_factorial\n    \n    RETURN log2_n\nEND FUNCTION"
    },
    "cmath_2114": {
      "problem_id": "cmath_2114",
      "solution": null,
      "summary": "Construct the minimal triangle-free sequence starting from the lower bound to identify the threshold where a triangle-free subset of the target size becomes possible.",
      "pseudocode": "function solve_triangle_property_limit(min_val, subset_size):\n    # Initialize the smallest possible triangle-free sequence\n    # To avoid triangles, each element must be >= sum of previous two\n    sequence = [min_val, min_val + 1]\n    \n    # Extend the sequence until it reaches the target subset size\n    while length(sequence) < subset_size:\n        next_val = sequence[-1] + sequence[-2]\n        append next_val to sequence\n    \n    # The largest n is the value just before a triangle-free subset of size k can exist\n    # This corresponds to the largest element of the minimal triangle-free sequence minus 1\n    max_n = sequence[-1] - 1\n    \n    return max_n\n\n# Problem parameters\nstart_integer = 4\ntarget_subset_size = 10\n\n# Compute and return result\nresult = solve_triangle_property_limit(start_integer, target_subset_size)\nprint(result)"
    },
    "cmath_2147": {
      "problem_id": "cmath_2147",
      "solution": null,
      "summary": "Iterate over partition sizes and sum the counts of subsets satisfying cardinality exclusion constraints.",
      "pseudocode": "Set n = 12\nInitialize total_count = 0\nFor k from 1 to n - 1:\n    size_A = k\n    size_B = n - k\n    // Constraint 1: size_A is not an element of A\n    // Constraint 2: size_B is not an element of B (implies size_B is in A)\n    If size_A == size_B:\n        Continue // Impossible to satisfy both constraints simultaneously\n    // Count subsets A of size k that contain size_B but not size_A\n    // Fix 2 elements (include size_B, exclude size_A), choose remaining k-1 from n-2\n    ways = Combinations(n - 2, k - 1)\n    total_count = total_count + ways\nReturn total_count"
    },
    "cmath_2163": {
      "problem_id": "cmath_2163",
      "solution": null,
      "summary": "Use Bayes' theorem to find the posterior probabilities of each die given two sixes, then calculate the total probability of a third six.",
      "pseudocode": "Define prior probabilities for selecting Fair and Biased dice\nDefine probability of rolling a six for each die type\nCalculate likelihood of observing two consecutive sixes for each die type\nCompute total probability of observing two sixes using Law of Total Probability\nApply Bayes' Theorem to determine posterior probability of each die type given the evidence\nCalculate predictive probability of third roll being six using posterior weights\nSimplify the resulting fraction p/q and return p + q"
    },
    "cmath_2167": {
      "problem_id": "cmath_2167",
      "solution": null,
      "summary": "Apply dynamic programming with axis boundary conditions to compute the probability fraction, then extract and sum the numerator and denominator's exponent of 3.",
      "pseudocode": "Function ComputeHitProbability(N):\n    Initialize DP table of size (N+1) x (N+1)\n    Set DP[0][0] = 1\n    Set DP[i][0] = 0 and DP[0][i] = 0 for i from 1 to N\n    For i from 1 to N:\n        For j from 1 to N:\n            DP[i][j] = (1/3) * (DP[i-1][j] + DP[i][j-1] + DP[i-1][j-1])\n    Return DP[N][N]\n\nFunction Solve():\n    Probability = ComputeHitProbability(4)\n    Express Probability as m / 3^n where m is not divisible by 3\n    Return m + n"
    },
    "cmath_2185": {
      "problem_id": "cmath_2185",
      "solution": null,
      "summary": "Use the Pigeonhole Principle to calculate the worst-case selection by maximizing unpaired socks across all colors before completing the target number of pairs.",
      "pseudocode": "FUNCTION MinSocksForPairs(color_counts, target_pairs):\n    num_colors = COUNT(color_counts)\n    \n    # Verify supply is sufficient for the target (e.g., min(40) >= 2*10)\n    IF MIN(color_counts) < 2 * target_pairs:\n        RETURN \"Insufficient Socks\"\n    \n    # Worst-case analysis: Maximize socks held while having only (target_pairs - 1) pairs\n    # Each complete pair consumes 2 socks\n    socks_from_pairs = 2 * (target_pairs - 1)\n    \n    # To maximize count without forming extra pairs, keep 1 unpaired sock per color\n    max_unpaired_socks = num_colors\n    \n    # Maximum socks one can draw without guaranteeing the target number of pairs\n    threshold = socks_from_pairs + max_unpaired_socks\n    \n    # Drawing one additional sock forces the completion of the target_pairs\n    RETURN threshold + 1\nEND FUNCTION"
    },
    "cmath_2190": {
      "problem_id": "cmath_2190",
      "solution": null,
      "summary": "Count valid sequences using a Fibonacci-like recurrence relation, compute the simplified probability fraction, and sum its numerator and denominator.",
      "pseudocode": "DEFINE dp[i] AS number of binary sequences of length i with no consecutive 1s\nSET BASE CASES: dp[1] = 2, dp[2] = 3\nFOR i FROM 3 TO 10:\n    dp[i] = dp[i-1] + dp[i-2]\n    // Derivation: Append '0' to valid seqs of length i-1 OR append '01' to valid seqs of length i-2\nvalid_sequences = dp[10]\ntotal_sequences = 2^10\nprobability = valid_sequences / total_sequences\nREDUCE probability TO irreducible fraction m/n\nRETURN m + n"
    },
    "cmath_2286": {
      "problem_id": "cmath_2286",
      "solution": null,
      "summary": "Model the daily rolling process as a geometric distribution to find the expected rolls per day, then multiply by the number of days in a year.",
      "pseudocode": "Identify daily stopping condition (outcome != 1)\nCalculate probability of stopping p = 5/6\nCompute expected rolls per day E_day = 1 / p using geometric distribution mean\nCompute total expected rolls E_total = 365 * E_day using linearity of expectation\nReturn E_total"
    },
    "cmath_2385": {
      "problem_id": "cmath_2385",
      "solution": null,
      "summary": "Apply the multiplication principle by sequentially counting valid digit choices for each position while satisfying parity, distinctness, and leading non-zero constraints.",
      "pseudocode": "Function CountDistinctOddThreeDigitNumbers():\n    Define Constraints:\n        1. Structure: 3 digits (Hundreds, Tens, Units)\n        2. Parity: Units digit must be Odd {1, 3, 5, 7, 9}\n        3. Leading Zero: Hundreds digit cannot be 0\n        4. Distinctness: All digits must be unique\n\n    // Constructive Counting Strategy (Multiplication Principle)\n    // Order selection by strictness of constraints to manage dependencies\n    \n    Step 1: Determine choices for Units digit\n        Options = Count({1, 3, 5, 7, 9}) = 5\n    \n    Step 2: Determine choices for Hundreds digit\n        Options = Count({1..9} excluding chosen Units digit) = 8\n    \n    Step 3: Determine choices for Tens digit\n        Options = Count({0..9} excluding chosen Units and Hundreds digits) = 8\n    \n    Total Count = Step 1 Options * Step 2 Options * Step 3 Options\n    Return Total Count"
    },
    "cmath_2428": {
      "problem_id": "cmath_2428",
      "solution": null,
      "summary": "Apply the stars and bars theorem to calculate the number of ways to distribute n identical items into k distinct bins using the combination formula C(n + k - 1, k - 1).",
      "pseudocode": "FUNCTION CountDistributions(identical_items, distinct_bins):\n    // Identify Combinatorial Model: Distributing identical items into distinct bins\n    // Constraint: All items must be distributed, bins may be empty (non-negative integers)\n    // Technique: Stars and Bars Theorem\n    \n    n <- identical_items\n    k <- distinct_bins\n    \n    // Theorem Application: Number of ways is given by choosing positions for bars among stars\n    // Formula: BinomialCoefficient(n + k - 1, k - 1)\n    ways <- BinomialCoefficient(n + k - 1, k - 1)\n    \n    RETURN ways\nEND FUNCTION"
    },
    "cmath_2432": {
      "problem_id": "cmath_2432",
      "solution": null,
      "summary": "Iterate through feasible counts of the higher-cost item, derive the corresponding count of the lower-cost item from the budget constraint, and sum the products of their respective binomial coefficients.",
      "pseudocode": "SET count_E = 5, cost_E = 2\nSET count_M = 6, cost_M = 1\nSET total_budget = 12\nINITIALIZE total_ways = 0\n\nFOR num_E FROM 0 TO count_E:\n    required_cost_M = total_budget - (num_E * cost_E)\n    num_M = required_cost_M / cost_M\n    \n    IF num_M is integer AND 0 <= num_M <= count_M:\n        ways_E = BINOMIAL(count_E, num_E)\n        ways_M = BINOMIAL(count_M, num_M)\n        total_ways += ways_E * ways_M\n\nRETURN total_ways"
    },
    "cmath_2462": {
      "problem_id": "cmath_2462",
      "solution": null,
      "summary": "Model the scenario as a graph and minimize edges by constructing a 2-regular cycle graph satisfying the minimum degree constraint.",
      "pseudocode": "Function MinHandshakes(n_people):\n    Model people as Vertices V and handshakes as Edges E in Graph G\n    Constraint: degree(v) >= 2 for all v in V\n    Objective: Minimize |E|\n    Strategy: Construct a 2-regular graph (Cycle Graph) to satisfy constraint minimally\n    Property: A cycle graph with n vertices has exactly n edges\n    min_handshakes = n_people\n    Return min_handshakes"
    },
    "cmath_2476": {
      "problem_id": "cmath_2476",
      "solution": null,
      "summary": "Iterate over valid even last digits and sum the combinations of choosing two strictly smaller preceding digits.",
      "pseudocode": "Initialize total_count = 0\nDefine valid_last_digits = {2, 4, 6, 8}\nFor each last_digit in valid_last_digits:\n    // Preceding digits must be strictly smaller and non-zero (to ensure 3-digit number)\n    // Available pool for first two digits is {1, ..., last_digit - 1}\n    // Order is fixed by strictly increasing constraint, so use combinations\n    ways_to_choose_prefix = Binomial_Coefficient(last_digit - 1, 2)\n    total_count = total_count + ways_to_choose_prefix\nReturn total_count"
    },
    "cmath_4681": {
      "problem_id": "cmath_4681",
      "solution": null,
      "summary": "Decompose the number into prime factorization, sum exponents for each prime, and multiply the primes with odd total exponents to make all exponents even.",
      "pseudocode": "Function FindSmallestSquareMultiplier(ProductExpression):\n    // Concept: Aggregate total exponents for each prime base\n    Initialize prime_exponent_map\n    \n    For each term (base, exponent) in ProductExpression:\n        prime_factors = PrimeFactorize(base)\n        For each (prime, power) in prime_factors:\n            prime_exponent_map[prime] += power * exponent\n            \n    // Concept: Perfect square condition requires all exponents to be even\n    multiplier = 1\n    For each (prime, total_exponent) in prime_exponent_map:\n        If total_exponent is Odd:\n            // Multiply by prime once to make exponent even\n            multiplier *= prime\n            \n    Return multiplier"
    },
    "cmath_4689": {
      "problem_id": "cmath_4689",
      "solution": null,
      "summary": "Iteratively compute the sum of the decimal digits of $1/5^n$ for increasing $n$ until the sum exceeds 10.",
      "pseudocode": "Function FindSmallestN():\n    Initialize n = 1\n    Loop:\n        Compute value = 1 / 5^n\n        Extract digits D from the fractional part of the decimal expansion of value\n        Calculate digit_sum = Sum(D)\n        If digit_sum > 10:\n            Return n\n        Increment n"
    },
    "cmath_4733": {
      "problem_id": "cmath_4733",
      "solution": null,
      "summary": "Bounded iteration to sum all integers satisfying a specific least common multiple constraint with a base number.",
      "pseudocode": "Define Target_LCM ← 60\nDefine Base_Number ← 20\nInitialize Total_Sum ← 0\nFor each integer ν from 1 to Target_LCM:\n    If LCM(ν, Base_Number) == Target_LCM:\n        Total_Sum ← Total_Sum + ν\nReturn Total_Sum"
    },
    "cmath_4759": {
      "problem_id": "cmath_4759",
      "solution": null,
      "summary": "Filter integer divisors of the numerator by the denominator's parity constraint to determine valid variable values and compute their sum.",
      "pseudocode": "condition <- (2n - 1) must divide 20\ndivisors <- all_integer_divisors(20)\nvalid_divisors <- filter(divisors, is_odd)  // Enforce parity constraint of 2n - 1\nsolutions <- map(valid_divisors, d -> solve(2n - 1 = d))\nreturn sum(solutions)"
    },
    "cmath_4771": {
      "problem_id": "cmath_4771",
      "solution": null,
      "summary": "Count integers $n$ where the denominator $n+1$ contains prime factors other than 2 or 5, as this condition ensures the irreducible fraction $\\frac{n}{n+1}$ produces a repeating decimal.",
      "pseudocode": "Function has_prime_factors_other_than_2_or_5(num):\n    // Remove all factors of 2 and 5 from the number\n    While num is divisible by 2:\n        num = num / 2\n    While num is divisible by 5:\n        num = num / 5\n    // If remaining value > 1, other prime factors exist\n    Return num != 1\n\nInitialize count = 0\nFor n from 1 to 100:\n    denominator = n + 1\n    // Fraction n/(n+1) is irreducible since gcd(n, n+1) = 1\n    // A simplified fraction has a repeating decimal iff denominator has prime factors other than 2 or 5\n    If has_prime_factors_other_than_2_or_5(denominator):\n        count = count + 1\nReturn count"
    },
    "cmath_4818": {
      "problem_id": "cmath_4818",
      "solution": null,
      "summary": "Iterative search for the minimal integer $n$ where $n^2-n$ is divisible by a proper non-empty subset of $\\{1, \\dots, n\\}$.",
      "pseudocode": "n <- 1\nwhile true:\n    D <- {k : 1 <= k <= n and k divides (n^2 - n)}\n    if 0 < |D| < n:\n        return n\n    n <- n + 1"
    },
    "cmath_4845": {
      "problem_id": "cmath_4845",
      "solution": null,
      "summary": "Compute the sum of distinct quadratic residues modulo 11 generated by integers 1 to 10 and determine the integer quotient when divided by 11.",
      "pseudocode": "Set modulus p = 11\nInitialize set quadratic_residues = {}\nFor n from 1 to p - 1:\n    Compute residue r = (n^2) mod p\n    Add r to quadratic_residues\nCalculate m = sum of elements in quadratic_residues\nReturn floor(m / p)"
    },
    "cmath_4855": {
      "problem_id": "cmath_4855",
      "solution": null,
      "summary": "Count divisors of N divisible by k by calculating the total number of divisors of N/k using prime factorization.",
      "pseudocode": "function count_divisors_multiple(N, k):\n    if N % k != 0:\n        return 0\n    \n    # A divisor d of N is a multiple of k iff d = k * m, where m divides N/k\n    M = N / k\n    \n    # Get prime factorization of M: M = p1^e1 * p2^e2 * ...\n    factors = prime_factorize(M)\n    \n    # Apply divisor counting formula: product of (exponent + 1)\n    count = 1\n    for exponent in factors.values():\n        count *= (exponent + 1)\n        \n    return count"
    },
    "cmath_4869": {
      "problem_id": "cmath_4869",
      "solution": null,
      "summary": "Derive a combinatorial formula for the count of distinct-digit numbers in base $b$ and solve the resulting polynomial equation for the integer base.",
      "pseudocode": "Derive combinatorial formula for count of distinct 3-digit numbers in base b:\n    First digit choices: b - 1 (cannot be 0)\n    Second digit choices: b - 1 (cannot match first)\n    Third digit choices: b - 2 (cannot match first or second)\n    Total Count N(b) = (b - 1) * (b - 1) * (b - 2)\n\nSet equation N(b) = 100\nIterate integer b starting from 3\nReturn b where N(b) equals 100"
    },
    "cmath_4949": {
      "problem_id": "cmath_4949",
      "solution": null,
      "summary": "Iteratively search for the smallest positive integer n by counting its representations as a sum of two positive squares until the target count is met.",
      "pseudocode": "Function CountOrderedPairs(n):\n    count <- 0\n    For a from 1 to floor(sqrt(n)):\n        b_squared <- n - a^2\n        If b_squared is a perfect square:\n            b <- sqrt(b_squared)\n            If b > 0:\n                If a == b:\n                    count <- count + 1  // (a, a) is unique\n                Else:\n                    count <- count + 2  // (a, b) and (b, a) are distinct\n    Return count\n\nn <- 1\nWhile True:\n    If CountOrderedPairs(n) == 3:\n        Return n\n    n <- n + 1"
    },
    "cmath_4950": {
      "problem_id": "cmath_4950",
      "solution": null,
      "summary": "Factor out the smaller factorial to simplify the sum into a product, then determine the largest prime factor by comparing the factorial's prime limit with the residual term's factors.",
      "pseudocode": "# Represent the sum of factorials\nexpression = 12! + 14!\n\n# Algebraic Simplification: Factor out the smaller factorial\n# 12! + 14! = 12! * (1 + 14 * 13)\ncommon_factor = 12!\nresidual_integer = 1 + (14 * 13)\n\n# Analyze prime factors of the common factorial component\n# The prime factors of n! are all primes <= n\nmax_prime_from_factorial = largest_prime_less_than_or_equal(12)\n\n# Analyze prime factors of the residual integer component\nresidual_prime_factors = prime_factorization(residual_integer)\nmax_prime_from_residual = max(residual_prime_factors)\n\n# The greatest prime factor of the total sum is the maximum of the components\ngreatest_prime = max(max_prime_from_factorial, max_prime_from_residual)\nreturn greatest_prime"
    },
    "cmath_4974": {
      "problem_id": "cmath_4974",
      "solution": null,
      "summary": "Iterate through candidate bases, evaluate the base-n polynomial representation, and count instances satisfying the modular divisibility condition.",
      "pseudocode": "Define Polynomial P(n) = 2n^5 + 3n^4 + 5n^3 + 2n^2 + 3n + 6\nInitialize count = 0\nFor n from 2 to 100:\n    If P(n) ≡ 0 (mod 7):\n        count = count + 1\nReturn count"
    },
    "cmath_5031": {
      "problem_id": "cmath_5031",
      "solution": null,
      "summary": "Apply Legendre's Formula to find the exponent of 2 in 16!, then use the cyclic pattern of powers of 2 modulo 10 to determine the final ones digit.",
      "pseudocode": "FUNCTION find_ones_digit_of_largest_power(n, p):\n    // Step 1: Calculate the exponent of prime p in n! using Legendre's Formula\n    exponent <- 0\n    power_of_p <- p\n    WHILE power_of_p <= n:\n        exponent <- exponent + FLOOR(n / power_of_p)\n        power_of_p <- power_of_p * p\n    \n    // Step 2: Determine the cycle length of ones digits for powers of p\n    // For p=2, the cycle of ones digits [2, 4, 8, 6] has length 4\n    cycle_length <- 4 \n    \n    // Step 3: Map the large exponent to the corresponding position in the cycle\n    // Note: If exponent % cycle_length == 0, it corresponds to the last element of the cycle\n    effective_exponent <- exponent MOD cycle_length\n    IF effective_exponent == 0:\n        effective_exponent <- cycle_length\n        \n    // Step 4: Compute the ones digit\n    result <- (p ^ effective_exponent) MOD 10\n    \n    RETURN result\nEND FUNCTION\n\n// Application to specific problem\nn_val <- 2^4  // 16\np_val <- 2\nanswer <- find_ones_digit_of_largest_power(n_val, p_val)"
    },
    "cmath_5075": {
      "problem_id": "cmath_5075",
      "solution": null,
      "summary": "Convert the base-8 digit constraint into a decimal value range, compute the minimum and maximum base-2 digit counts for this range, and sum all integers between these counts.",
      "pseudocode": "FUNCTION SolveBaseConversionDigitSum():\n    // 1. Determine the decimal range for a 4-digit base-8 integer\n    // Smallest 4-digit base-8 number is 1000_8 = 8^3\n    min_val <- 8^(4 - 1)\n    // Largest 4-digit base-8 number is 7777_8 = 8^4 - 1\n    max_val <- 8^4 - 1\n    \n    // 2. Calculate the number of base-2 digits (d) for the bounds\n    // Formula: digits = floor(log_base(value)) + 1\n    min_d <- floor(log_2(min_val)) + 1\n    max_d <- floor(log_2(max_val)) + 1\n    \n    // 3. Sum all possible integer values for d within the calculated range\n    total_sum <- 0\n    FOR d FROM min_d TO max_d INCLUSIVE:\n        total_sum <- total_sum + d\n        \n    RETURN total_sum\nEND FUNCTION"
    },
    "cmath_5177": {
      "problem_id": "cmath_5177",
      "solution": null,
      "summary": "Apply Euler's Totient Theorem to reduce the exponent modulo $\\phi(25)$, then compute the result using binary modular exponentiation.",
      "pseudocode": "Function Solve():\n    Define base = 19, exponent = 1999, modulus = 25\n    \n    // Concept: Euler's Totient Theorem Application\n    // Requires gcd(base, modulus) == 1\n    phi = Calculate_Euler_Totient(modulus)\n    \n    // Concept: Exponent Reduction\n    reduced_exponent = exponent % phi\n    \n    // Concept: Binary Modular Exponentiation\n    result = Modular_Exponentiation(base, reduced_exponent, modulus)\n    \n    Return result"
    },
    "cmath_5178": {
      "problem_id": "cmath_5178",
      "solution": null,
      "summary": "Simplify linear congruences to standard residue form, combine using the Chinese Remainder Theorem, and shift by the modulus period to satisfy the minimum value constraint.",
      "pseudocode": "Function FindLeastConstrainedSolution(LinearCongruences, LowerBound):\n    SimplifiedPairs = []\n    For each (coeff, constant, modulus) in LinearCongruences:\n        // Step 1: Simplify ax ≡ b (mod m) to x ≡ r (mod m')\n        g = GCD(coeff, modulus)\n        modulus_reduced = modulus / g\n        coeff_reduced = coeff / g\n        constant_reduced = constant / g\n        inverse = ModularInverse(coeff_reduced, modulus_reduced)\n        residue = (constant_reduced * inverse) % modulus_reduced\n        Add (residue, modulus_reduced) to SimplifiedPairs\n    \n    // Step 2: Combine congruences using Chinese Remainder Theorem\n    M_total = Product of all modulus_reduced in SimplifiedPairs\n    x_0 = 0\n    For each (residue, modulus_reduced) in SimplifiedPairs:\n        N_i = M_total / modulus_reduced\n        y_i = ModularInverse(N_i, modulus_reduced)\n        x_0 = (x_0 + residue * N_i * y_i) % M_total\n    \n    // Step 3: Adjust base solution to meet range constraint\n    k = Ceiling((LowerBound - x_0) / M_total)\n    Return x_0 + k * M_total"
    },
    "cmath_5195": {
      "problem_id": "cmath_5195",
      "solution": null,
      "summary": "Apply the Extended Euclidean Algorithm to solve the Bezout identity for the modular inverse and normalize the resulting coefficient.",
      "pseudocode": "Function ModularInverse(a, m):\n    // Problem: Find x such that a * x ≡ 1 (mod m)\n    // Equivalent to solving Diophantine equation: a * x + m * y = 1\n    \n    // 1. Apply Extended Euclidean Algorithm to find gcd(a, m) and coefficients x, y\n    (g, x, y) = ExtendedEuclidean(a, m)\n    \n    // 2. Check existence condition: inverse exists iff gcd(a, m) = 1\n    If g != 1:\n        Return \"No Inverse\"\n    \n    // 3. The coefficient x satisfies a * x ≡ 1 (mod m)\n    // 4. Normalize x to the canonical range [0, m-1]\n    result = (x % m + m) % m\n    \n    Return result"
    },
    "cmath_5235": {
      "problem_id": "cmath_5235",
      "solution": null,
      "summary": "Apply the Polynomial Remainder Theorem to reduce the divisibility condition to a constant divisor constraint, then maximize the divisor to solve for n.",
      "pseudocode": "Define polynomial f(n) = n^3 + 100\nDefine divisor term d = n + 10\nApply Polynomial Remainder Theorem: evaluate f(-10) to determine constant remainder C\nCalculate C = -900\nReformulate divisibility condition: d must divide C (equivalently d divides |C|)\nTo maximize n, maximize d by setting d = |C|\nSolve linear equation n + 10 = 900 for n\nReturn n"
    },
    "cmath_5236": {
      "problem_id": "cmath_5236",
      "solution": null,
      "summary": "Interpret the binary representation of the index as a base-3 number to compute the term.",
      "pseudocode": "Input: index n\n// Key Insight: Sequence elements are sums of distinct powers of 3.\n// This implies their base-3 representation contains only digits 0 and 1.\n// There is an order-preserving bijection between binary integers and this sequence.\n\n1. Obtain the binary representation of n: n = Σ(b_i * 2^i) where b_i ∈ {0, 1}\n2. Map the binary coefficients to powers of 3 to find the nth term: T_n = Σ(b_i * 3^i)\n3. Calculate the sum of 3^i for every position i where the ith bit of n is 1\nOutput: T_n"
    },
    "cmath_5240": {
      "problem_id": "cmath_5240",
      "solution": null,
      "summary": "Iteratively search for integers satisfying the nice number definition by enumerating proper divisors and verifying their product equals the number.",
      "pseudocode": "Initialize empty list nice_numbers\nSet candidate n = 2\nWhile length(nice_numbers) < 10:\n    Determine set D of proper divisors of n (divisors d where 1 < d < n)\n    Compute product P = ∏_{d in D} d\n    If P == n:\n        Append n to nice_numbers\n    Increment n\nReturn sum of elements in nice_numbers"
    },
    "cmath_5246": {
      "problem_id": "cmath_5246",
      "solution": null,
      "summary": "Count powers of 9 with leading digit 9 by evaluating the fractional part of their base-10 logarithms.",
      "pseudocode": "Define LOG_9 = log10(9)\nInitialize count = 0\nFor k from 0 to 4000:\n    // Calculate fractional part of the logarithm of 9^k\n    fractional_part = {k * LOG_9}\n    // Determine leading digit from the fractional part\n    leading_digit = floor(10 ^ fractional_part)\n    If leading_digit == 9:\n        Increment count\nReturn count"
    },
    "cmath_5260": {
      "problem_id": "cmath_5260",
      "solution": null,
      "summary": "Characterize integers expressible as a difference of squares using parity arguments to exclude numbers congruent to 2 modulo 4, then apply complementary counting.",
      "pseudocode": "FUNCTION CountDifferenceOfSquares(upper_bound):\n    // Step 1: Algebraic Characterization\n    // Express n = a^2 - b^2 as n = (a+b)(a-b)\n    // Let x = a+b, y = a-b. Note x and y must have same parity.\n    \n    // Step 2: Derive Modular Constraint\n    // If x, y both odd => n is odd\n    // If x, y both even => n is divisible by 4\n    // Therefore, n cannot be congruent to 2 modulo 4\n    \n    // Step 3: Complementary Counting\n    total_count ← upper_bound\n    \n    // Count integers k in [1, upper_bound] where k ≡ 2 (mod 4)\n    // Sequence forms arithmetic progression: 2, 6, 10, ...\n    excluded_count ← FLOOR((upper_bound - 2) / 4) + 1\n    \n    valid_count ← total_count - excluded_count\n    \n    RETURN valid_count"
    },
    "cmath_5271": {
      "problem_id": "cmath_5271",
      "solution": null,
      "summary": "Use the integer mean property to establish modular congruence among elements, constrain the set size using divisors of the difference between known elements, and validate the maximum size via sum divisibility.",
      "pseudocode": "1. Let n be the number of elements and S be the sum of elements in set S.\n2. From the condition that (S - x) / (n - 1) is an integer for all x, deduce that all elements are congruent modulo (n - 1).\n3. Since 1 and 2002 are in the set, require (2002 - 1) to be divisible by (n - 1).\n4. Find all divisors of 2001 and sort them in descending order.\n5. For each divisor d:\n    a. Set candidate size n = d + 1.\n    b. Verify if a valid set of size n exists (checking if a constructed sum S is divisible by n).\n    c. If verification passes, return n as the maximum size."
    },
    "cmath_5274": {
      "problem_id": "cmath_5274",
      "solution": null,
      "summary": "Exhaustively search integers k starting from 1 until the sum of squares formula yields a multiple of 200.",
      "pseudocode": "Define S(k) = k(k + 1)(2k + 1) / 6\nInitialize k = 1\nWhile S(k) ≢ 0 (mod 200):\n    k ← k + 1\nReturn k"
    },
    "cmath_5283": {
      "problem_id": "cmath_5283",
      "solution": null,
      "summary": "Model the sequential distribution as a linear system linking initial takes to final holdings, then minimize the total subject to integer constraints derived from the target ratio.",
      "pseudocode": "1. Define variables x, y, z for the quantity of bananas taken by the first, second, and third monkey respectively.\n2. Formulate linear expressions for the final holdings of each monkey based on the fractions kept and distributed at each step.\n3. Set the final holdings proportional to the given ratio using a common scaling factor k.\n4. Substitute the ratio-based holdings into the distribution expressions to generate a system of linear equations.\n5. Solve the system to express the taken quantities x, y, z in terms of the scaling factor k.\n6. Determine the least positive integer k such that x, y, z and all intermediate shared amounts are integers.\n7. Compute the total bananas B = x + y + z using the minimal valid k.\n8. Return the minimum total B."
    },
    "cmath_5291": {
      "problem_id": "cmath_5291",
      "solution": null,
      "summary": "Transform the logarithmic sum of a geometric sequence into a linear Diophantine equation on the exponents of the base's prime factor and count the non-negative integer solutions.",
      "pseudocode": "FUNCTION count_geometric_log_pairs(n_terms, log_sum, log_base):\n    // 1. Derive exponents from the product of geometric sequence terms\n    // Product = a^n * r^(0+1+...+n-1) = a^n * r^(n*(n-1)/2)\n    exp_a <- n_terms\n    exp_r <- n_terms * (n_terms - 1) / 2\n    \n    // 2. Simplify logarithmic equation to linear form\n    // log_base(a^exp_a * r^exp_r) = log_sum\n    // exp_a * log_base(a) + exp_r * log_base(r) = log_sum\n    \n    // 3. Convert to prime base p (where log_base = p^k) to enforce integer constraints\n    // log_base(x) = log_p(x) / k\n    k <- log_p(log_base)\n    coeff_a <- exp_a / k\n    coeff_r <- exp_r / k\n    target <- log_sum\n    \n    // 4. Form Linear Diophantine Equation: coeff_a * x + coeff_r * y = target\n    // where x = log_p(a), y = log_p(r) must be non-negative integers\n    \n    // 5. Determine valid integer solutions\n    // Analyze parity/modulo to parameterize one variable (e.g., y = step * k_param + offset)\n    // Calculate bounds for k_param such that x >= 0 and y >= 0\n    max_k <- floor((target - coeff_r * offset) / (coeff_r * step))\n    min_k <- 0\n    \n    // 6. Return count of valid parameters\n    RETURN max_k - min_k + 1\nEND FUNCTION"
    },
    "cmath_5295": {
      "problem_id": "cmath_5295",
      "solution": null,
      "summary": "Sum the 3-adic valuations of each integer in the sequence of the first 100 positive odd numbers to find the total exponent of 3 in their product.",
      "pseudocode": "Function CountPrimeValuation(n, p):\n    exponent <- 0\n    While n is divisible by p:\n        n <- n / p\n        exponent <- exponent + 1\n    Return exponent\n\nFunction Solve():\n    total_k <- 0\n    Sequence <- GenerateFirstNOddIntegers(100)  // Yields 1, 3, 5, ..., 199\n    For each number n in Sequence:\n        total_k <- total_k + CountPrimeValuation(n, 3)\n    Return total_k"
    },
    "cmath_5330": {
      "problem_id": "cmath_5330",
      "solution": null,
      "summary": "Calculate the maximum representable value in the balanced ternary system and count the non-negative integers up to that limit.",
      "pseudocode": "FUNCTION CountBalancedRepresentation(powers_count, base):\n    // Calculate the maximum magnitude representable with coefficients {-1, 0, 1}\n    max_val = 0\n    FOR i FROM 0 TO powers_count - 1:\n        max_val += base^i\n    \n    // Mathematical Property: A balanced base system uniquely represents \n    // all integers in the continuous range [-max_val, max_val]\n    \n    // Count the non-negative integers in the range [0, max_val]\n    count = max_val + 1\n    \n    RETURN count"
    },
    "cmath_5334": {
      "problem_id": "cmath_5334",
      "solution": null,
      "summary": "Check which candidate value satisfies the digit sum transition property $S(n+1) = S(n) + 1 - 9k$ for some non-negative integer $k$.",
      "pseudocode": "function find_valid_digit_sum(S_n, options):\n    # When incrementing n by 1, the digit sum changes based on trailing 9s.\n    # If there are k trailing 9s, S(n+1) = S(n) + 1 - 9*k.\n    # This implies S(n+1) <= S(n) + 1 and (S(n) + 1 - S(n+1)) is divisible by 9.\n    \n    base_sum = S_n + 1\n    \n    for option in options:\n        difference = base_sum - option\n        \n        # Check if the difference corresponds to a valid number of carries (k >= 0)\n        if difference >= 0 AND difference is divisible by 9:\n            return option\n            \n    return None"
    },
    "cmath_5342": {
      "problem_id": "cmath_5342",
      "solution": null,
      "summary": "Apply bounded exhaustive search to identify integer pairs satisfying the exponential Diophantine equation.",
      "pseudocode": "FUNCTION count_integer_solutions():\n    Initialize solution_count = 0\n    # Concept: Limit search space based on exponential growth relative to the constant\n    DETERMINE bounds for x and y such that 2^(2x) and 3^(2y) do not excessively exceed 55\n    FOR x FROM 1 TO bound_x:\n        FOR y FROM 1 TO bound_y:\n            # Concept: Direct verification of the Diophantine condition\n            IF 2^(2*x) - 3^(2*y) == 55:\n                INCREMENT solution_count\n    RETURN solution_count\nEND FUNCTION"
    },
    "cmath_5349": {
      "problem_id": "cmath_5349",
      "solution": null,
      "summary": "Enumerate all valid distinct-digit permutations, construct integers via place value expansion, accumulate the sum, and compute the remainder modulo 1000.",
      "pseudocode": "Define digit set D = {0, 1, ..., 9}\nInitialize total_sum = 0\nFor each ordered triple (d1, d2, d3) from Permutations(D, 3):\n    If d1 != 0:  // Constraint: leading digit cannot be zero\n        value = 100 * d1 + 10 * d2 + d3  // Place value construction\n        total_sum = total_sum + value\nReturn total_sum mod 1000"
    },
    "cmath_5421": {
      "problem_id": "cmath_5421",
      "solution": null,
      "summary": "Utilizes Fermat's Little Theorem to reduce the base modulo 11 and exponent modulo 10 before calculating the final modular exponentiation.",
      "pseudocode": "Define prime modulus P = 11\nDefine base A = 333, exponent B = 333\nReduce base: A_reduced = A mod P\nReduce exponent: B_reduced = B mod (P - 1) using Fermat's Little Theorem\nCompute result: Result = (A_reduced ^ B_reduced) mod P\nReturn Result"
    },
    "cmath_5475": {
      "problem_id": "cmath_5475",
      "solution": null,
      "summary": "Convert restricted divisor count to total divisors, decompose into multiplicative factors for exponent structures, and minimize by assigning smallest primes to largest exponents.",
      "pseudocode": "1. Calculate total divisors D = restricted_count + 2 (accounting for exclusions of 1 and N)\n2. Generate all multiplicative partitions of D (sets of integers whose product is D)\n3. For each partition, derive prime exponents E = [factor - 1 for factor in partition]\n4. Construct candidate number by assigning smallest distinct primes to largest exponents in E\n5. Return the minimum value across all constructed candidates"
    },
    "cmath_5477": {
      "problem_id": "cmath_5477",
      "solution": null,
      "summary": "Find the maximum value satisfying an upper bound and modular congruence by iterating downwards from the theoretical maximum.",
      "pseudocode": "SET limit = 1000\nSET multiplier = 20\nSET modulus = 26\nSET remainder = 4\nCALCULATE max_n = floor(limit / multiplier)\nFOR n FROM max_n DOWN TO 1:\n    candidate = n * multiplier\n    IF candidate < limit AND candidate % modulus == remainder:\n        RETURN candidate"
    },
    "cmath_5532": {
      "problem_id": "cmath_5532",
      "solution": null,
      "summary": "Characterize inputs as squares of distinct primes to determine the prime factorization of the target expression, then apply the divisor counting formula.",
      "pseudocode": "FUNCTION solve_factor_count():\n    IDENTIFY property: natural number has exactly 3 factors iff it is square of a prime (p^2)\n    REPRESENT x, y, z as squares of distinct primes: p1^2, p2^2, p3^2\n    SUBSTITUTE into target expression: E = (p1^2)^2 * (p2^2)^3 * (p3^2)^4\n    SIMPLIFY exponents: E = p1^4 * p2^6 * p3^8\n    APPLY divisor counting formula: product of (exponent + 1) for each prime factor\n    COMPUTE result: (4 + 1) * (6 + 1) * (8 + 1)\n    RETURN result"
    },
    "cmath_5540": {
      "problem_id": "cmath_5540",
      "solution": null,
      "summary": "Factor the polynomial to establish a baseline divisor, then compute the GCD of the expression evaluated at small composite integers to find the largest universal divisor.",
      "pseudocode": "Function FindLargestUniversalDivisor():\n    // 1. Algebraic Factorization\n    Expression <- n^3 - n\n    FactoredForm <- (n - 1) * n * (n + 1)\n    \n    // 2. Establish Theoretical Baseline\n    // Product of k consecutive integers is divisible by k!\n    // Here k=3, so divisible by 3! = 6 for all integers n\n    BaselineDivisor <- 6\n    \n    // 3. Empirical Verification on Domain\n    // Evaluate expression for the smallest composite integers to find constraints\n    Values <- []\n    For n in SmallestCompositeIntegers:\n        Values.append(Evaluate(Expression, n))\n    \n    // 4. Compute Tight Bound\n    // The largest integer dividing all cases is the GCD of the generated values\n    MaxDivisor <- GCD(Values)\n    \n    Return MaxDivisor\nEnd Function"
    },
    "cmath_5543": {
      "problem_id": "cmath_5543",
      "solution": null,
      "summary": "Compute the units digit by reducing the exponent tower modulo the periodicity of powers of 2 modulo 10.",
      "pseudocode": "FUNCTION find_Fermat_units_digit(n):\n    // Goal: Compute (2^(2^n) + 1) mod 10\n    modulus = 10\n    base = 2\n    cycle_length = 4  // Periodicity of 2^k mod 10\n\n    // Reduce the tower exponent (2^n) modulo the cycle length\n    // Mathematical Property: 2^n is divisible by 4 for all n >= 2\n    IF n >= 2:\n        reduced_exponent = cycle_length\n    ELSE:\n        reduced_exponent = (2^n) mod cycle_length\n\n    // Compute units digit of the power term using the reduced exponent\n    power_units_digit = (base^reduced_exponent) mod modulus\n\n    // Apply Fermat number definition offset\n    result = (power_units_digit + 1) mod modulus\n\n    RETURN result"
    },
    "cmath_5545": {
      "problem_id": "cmath_5545",
      "solution": null,
      "summary": "Determine the number of trailing zeroes in n! by calculating the total multiplicity of the prime factor 5 using Legendre's Formula.",
      "pseudocode": "Function CountTrailingZeroes(n):\n    // A trailing zero is produced by a factor of 10 = 2 * 5\n    // In n!, factors of 2 are more abundant than factors of 5\n    // Thus, the count of zeroes equals the exponent of 5 in the prime factorization of n!\n    // Apply Legendre's Formula for prime p = 5\n    count = 0\n    power_of_5 = 5\n    While power_of_5 <= n:\n        // Add the number of multiples of 5^k in the range [1, n]\n        count += floor(n / power_of_5)\n        power_of_5 *= 5\n    Return count"
    },
    "cmath_8735": {
      "problem_id": "cmath_8735",
      "solution": null,
      "summary": "Transform the \"at least one success\" condition into a complementary \"all failures\" probability inequality and solve for the minimum integer $n$ using logarithms.",
      "pseudocode": "Function MinTrialsForSuccess(p_success, target_probability):\n    // Step 1: Use Complementary Probability\n    // P(at least one success) = 1 - P(all failures)\n    p_failure <- 1 - p_success\n    max_allowed_failure_prob <- 1 - target_probability\n    \n    // Step 2: Model Independent Events\n    // P(all failures in n trials) = (p_failure)^n\n    // Inequality: (p_failure)^n <= max_allowed_failure_prob\n    \n    // Step 3: Solve Exponential Inequality using Logarithms\n    n_real <- log(max_allowed_failure_prob) / log(p_failure)\n    \n    // Step 4: Discretize to Minimum Integer\n    n_min <- ceiling(n_real)\n    \n    Return n_min\nEnd Function"
    },
    "cmath_8896": {
      "problem_id": "cmath_8896",
      "solution": null,
      "summary": "Apply the stars and bars theorem to count distributions of identical items into distinct bins.",
      "pseudocode": "IDENTIFY n = 6 // number of identical items\nIDENTIFY k = 3 // number of distinct bins\n// Recognize combinatorial pattern: distributing identical items into distinct bins\n// Equivalent to finding non-negative integer solutions to x_1 + ... + x_k = n\nAPPLY Stars_and_Bars_Theorem\nCALCULATE result = BinomialCoefficient(n + k - 1, k - 1)\nRETURN result"
    },
    "cmath_9094": {
      "problem_id": "cmath_9094",
      "solution": null,
      "summary": "Enumerate all subsets of size at least 2, calculate their sums, and count the number of unique results.",
      "pseudocode": "Let S be the input set of numbers\nInitialize U as an empty set to store unique sums\nFor each cardinality k from 2 to |S|:\n    For each subset C ⊆ S where |C| = k:\n        Compute s = Σ_{x ∈ C} x\n        Insert s into U\nReturn |U|"
    },
    "cmath_9112": {
      "problem_id": "cmath_9112",
      "solution": null,
      "summary": "Calculate the number of surjective functions from the set of cars to the set of lanes using the Principle of Inclusion-Exclusion.",
      "pseudocode": "function count_surjective_mappings(num_elements, num_targets):\n    total_ways = 0\n    for i from 0 to num_targets:\n        # Apply Principle of Inclusion-Exclusion\n        # i is the number of targets excluded (forced to be empty)\n        sign = (-1) ^ i\n        ways_to_choose_excluded = binomial_coefficient(num_targets, i)\n        ways_to_assign_to_remaining = (num_targets - i) ^ num_elements\n        term = sign * ways_to_choose_excluded * ways_to_assign_to_remaining\n        total_ways += term\n    return total_ways"
    },
    "cmath_9126": {
      "problem_id": "cmath_9126",
      "solution": null,
      "summary": "Determine trailing zeros by summing the counts of factor 5 in each factorial using Legendre's Formula.",
      "pseudocode": "Function Legendre_Count(n, prime):\n    count <- 0\n    power <- prime\n    While power <= n:\n        count <- count + floor(n / power)\n        power <- power * prime\n    Return count\n\nTotal_Zeros <- 0\nFor each N in [100, 200, 300]:\n    // Trailing zeros determined by exponent of 5 in prime factorization\n    Total_Zeros <- Total_Zeros + Legendre_Count(N, 5)\n\nReturn Total_Zeros"
    }
  },
  "custom_types": {}
}