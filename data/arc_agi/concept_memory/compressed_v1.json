{
  "concepts": {
    "extract objects": {
      "name": "extract objects",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": null,
      "parameters": [
        {
          "name": "input grid",
          "typing": "grid",
          "description": "grid (or region of a grid) to extract objects from"
        },
        {
          "name": "single color",
          "typing": "bool",
          "description": "if True, only extract objects of a single color"
        },
        {
          "name": "connectivity",
          "typing": "str",
          "description": "object connectedness (4-way, 8-way, or none). None admits non-contiguous objects."
        },
        {
          "name": "background color",
          "typing": "str",
          "description": "the background color to ignore when extracting objects. Default value is 0 or black."
        },
        {
          "name": "criteria",
          "typing": "selection criteria := Callable[[object], bool]",
          "description": "filter extracted objects to those satisfying the criteria (e.g., being inside a container)"
        }
      ],
      "description": null,
      "cues": [],
      "implementation": [],
      "used_in": [
        "prelim",
        "8e1813be",
        "5c2c9af4",
        "23581191",
        "f9012d9b",
        "d06dbe63",
        "25ff71a9",
        "6e19193c",
        "4c5c2cf0",
        "025d127b",
        "d2abd087",
        "017c7c7b",
        "6855a6e4",
        "810b9b61",
        "aedd82e4",
        "97a05b5b",
        "a78176bb",
        "1a07d186",
        "623ea044",
        "a8c38be5",
        "6e82a1ae",
        "29c11459",
        "2dd70a9a",
        "db3e9e38",
        "8d510a79",
        "25d487eb",
        "7447852a",
        "d6ad076f",
        "db93a21d",
        "239be575",
        "56dc2b01",
        "508bd3b6",
        "7e0986d6",
        "6b9890af",
        "f8b3ba0a",
        "150deff5",
        "6a1e5592",
        "a9f96cdd",
        "7f4411dc",
        "05f2a901",
        "90c28cc7",
        "3ac3eb23",
        "5168d44c",
        "e9614598",
        "08ed6ac7",
        "b775ac94",
        "fcc82909",
        "178fcbfb",
        "72ca375d",
        "3bdb4ada",
        "1caeab9d",
        "3befdf3e",
        "e8dc4411",
        "bc1d5164",
        "6d58a25d",
        "eb5a1d5d",
        "0a938d79",
        "54d82841",
        "681b3aeb",
        "b7249182",
        "1f642eb9",
        "5daaa586",
        "1fad071e",
        "ce602527",
        "1cf80156",
        "834ec97d",
        "d4a91cb9",
        "746b3537",
        "ea786f4a",
        "aba27056",
        "b527c5c6",
        "6ecd11f4",
        "41e4d17e",
        "a79310a0",
        "e509e548",
        "e73095fd",
        "8d5021e8",
        "3345333e",
        "045e512c",
        "444801d8",
        "995c5fa3",
        "f8a8fe49",
        "3f7978a0",
        "0962bcdd",
        "2204b7a8",
        "b782dc8a",
        "0e206a2e",
        "7c008303",
        "00d62c1b",
        "d4f3cd78",
        "44d8ac46",
        "d9f24cd1",
        "137eaa0f",
        "57aa92db",
        "2bcee788",
        "46f33fce"
      ]
    },
    "filter objects": {
      "name": "filter objects",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": null,
      "parameters": [
        {
          "name": "input objects",
          "typing": "list[object]",
          "description": "the list of objects to filter"
        },
        {
          "name": "criteria",
          "typing": "selection criteria := Callable[[object], bool]",
          "description": "filter criteria"
        }
      ],
      "description": "filter a list of objects based on some criteria",
      "cues": [],
      "implementation": [],
      "used_in": [
        "prelim",
        "8e1813be",
        "6e19193c",
        "6855a6e4",
        "97a05b5b",
        "1a07d186",
        "a8c38be5",
        "8d510a79",
        "239be575",
        "7e0986d6",
        "5168d44c",
        "b775ac94",
        "e8dc4411",
        "caa06a1f",
        "1f642eb9",
        "5daaa586",
        "1fad071e",
        "3eda0437",
        "af902bf9",
        "aba27056",
        "aabf363d",
        "045e512c",
        "11852cab",
        "f8a8fe49",
        "2204b7a8",
        "b782dc8a",
        "0e206a2e",
        "d4f3cd78",
        "d9f24cd1",
        "57aa92db"
      ]
    },
    "find object": {
      "name": "find object",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": null,
      "parameters": [
        {
          "name": "input objects",
          "typing": "list[object]",
          "description": "the list of objects to search in"
        },
        {
          "name": "criteria",
          "typing": "selection criteria",
          "description": "criteria to find the object"
        }
      ],
      "description": "find an object in a list of objects based on some criteria",
      "cues": [
        "if the solution selects the largest or smallest region/object among candidates"
      ],
      "implementation": [],
      "used_in": [
        "prelim",
        "8e1813be",
        "23581191",
        "d06dbe63",
        "4c5c2cf0",
        "6855a6e4",
        "97a05b5b",
        "1a07d186",
        "e179c5f4",
        "29c11459",
        "2dd70a9a",
        "8d510a79",
        "25d487eb",
        "56dc2b01",
        "508bd3b6",
        "6b9890af",
        "6a1e5592",
        "a9f96cdd",
        "05f2a901",
        "5168d44c",
        "1caeab9d",
        "6d58a25d",
        "0b148d64",
        "09629e4f",
        "1f642eb9",
        "3eda0437",
        "d4a91cb9",
        "ea786f4a",
        "b527c5c6",
        "6ecd11f4",
        "3345333e",
        "045e512c",
        "00d62c1b",
        "137eaa0f",
        "2bcee788"
      ]
    },
    "shape match criteria": {
      "name": "shape match criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": null
        },
        {
          "name": "other",
          "typing": "shape",
          "description": null
        },
        {
          "name": "size",
          "typing": "dimensions := tuple[int, int]",
          "description": "the shape to match (e.g., (2,2) for 2x2 squares)"
        },
        {
          "name": "allow_scale",
          "typing": "bool",
          "description": "whether to allow matching shapes up to scaling (i.e., one is a scaled version of the other)"
        },
        {
          "name": "allow_partial",
          "typing": "bool",
          "description": "whether to allow matching even if one object is partially off-grid"
        }
      ],
      "description": "condition on whether an object matches the other shape",
      "cues": [
        "if the solution checks if multiple regions or objects are identical, possibly allowing for symmetry, reflection, or scaling",
        "if only objects of a specific size or proportional dimensions are selected for further processing",
        "if the output depends on counting, detecting, or selecting objects of a fixed shape or scaled version of another object"
      ],
      "implementation": [
        "compare the object's bounding box dimensions or aspect ratio to the given size or shape",
        "for allow_scale, check if one shape is an integer multiple of the other in both dimensions",
        "for allow_partial, ignore pixels that are off-grid when comparing shapes"
      ],
      "used_in": [
        "prelim",
        "776ffc46",
        "228f6490",
        "2dee498d",
        "1fad071e",
        "ce602527"
      ]
    },
    "recolor object": {
      "name": "recolor object",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid | object",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object or pixel to recolor"
        },
        {
          "name": "color scheme",
          "typing": "dict[color, color]",
          "description": "mapping from original color to new color"
        },
        {
          "name": "object | object | position - the object or pixel to recolor",
          "typing": null,
          "description": null
        },
        {
          "name": "color scheme | dict[color, color] - mapping from original color to new color",
          "typing": null,
          "description": null
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color to assign to the object"
        }
      ],
      "description": "recolor an object based on a color scheme",
      "cues": [
        "if structures or objects from the input grid appear in the output grid with different colors",
        "if all pixels of one color in the output grid are replaced with another color (systematic color swap)",
        "if regions or objects are recolored based on a property (e.g., size, position, or matching a specific pixel)",
        "if the output grid contains regions filled with a new color not present in the input",
        "if background or other colors are systematically replaced in the output grid",
        "if the output grid is visually similar to the input except for a color swap",
        "if colored pixels or regions appear in the output grid at positions that were black or missing in the input, especially adjacent to colored pixels or aligned with features of input objects",
        "if a region or contiguous area is uniformly recolored, possibly based on a pixel in a special position (e.g., corner, interior of a container)",
        "if an input pixel or object is removed or replaced with background color in the output grid (deletion by recoloring)",
        "if a special color (e.g., grey or yellow) appears at a position determined by the interaction or meeting of input objects or paths"
      ],
      "implementation": [
        "for a single pixel, set grid[position] = color",
        "after drawing operations that may overwrite a pixel, restore that pixel to its intended color",
        "for each pixel, if its color is in the color scheme, replace it with the mapped color",
        "for a region or object, iterate over its pixels and set each to the target color or according to the color scheme",
        "for a region, if a pixel is background (e.g., black), set it to the specified color; otherwise, leave it unchanged",
        "at special positions (e.g., meeting points or intersections), set the pixel to a designated color (e.g., grey) instead of either input color"
      ],
      "used_in": [
        "prelim",
        "776ffc46",
        "0d3d703e",
        "4093f84a",
        "1b60fb0c",
        "23581191",
        "f9012d9b",
        "d06dbe63",
        "4c5c2cf0",
        "d2abd087",
        "017c7c7b",
        "810b9b61",
        "aedd82e4",
        "a78176bb",
        "6455b5f5",
        "e179c5f4",
        "6e82a1ae",
        "29c11459",
        "2dd70a9a",
        "7447852a",
        "d6ad076f",
        "10fcaaa3",
        "56dc2b01",
        "7e0986d6",
        "150deff5",
        "1b2d62fb",
        "3de23699",
        "6a1e5592",
        "a9f96cdd",
        "7f4411dc",
        "6cf79266",
        "6d75e8bb",
        "08ed6ac7",
        "25d8a9c8",
        "b775ac94",
        "3befdf3e",
        "e8dc4411",
        "caa06a1f",
        "54d82841",
        "3eda0437",
        "0ca9ddb6",
        "0dfd9992",
        "3428a4f5",
        "aba27056",
        "06df4c85",
        "a79310a0",
        "e509e548",
        "e73095fd",
        "f15e1fac",
        "aabf363d",
        "3345333e",
        "045e512c",
        "11852cab",
        "444801d8",
        "2204b7a8",
        "7c008303",
        "00d62c1b",
        "d4f3cd78",
        "44d8ac46",
        "57aa92db"
      ]
    },
    "split grid": {
      "name": "split grid",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "where the grid is split into multiple regions that are treated as distinct",
      "cues": [
        "divider lines (of any color) that span the grid and partition it into regions",
        "visually distinct regions or objects that are processed separately, often separated by colored or black lines, columns, or rows",
        "color-based regions where pixels of a certain color only appear within specific sections of the grid"
      ],
      "implementation": [],
      "used_in": [
        "prelim",
        "cf98881b",
        "7447852a",
        "239be575",
        "25d8a9c8",
        "0b148d64",
        "8d5021e8",
        "995c5fa3"
      ]
    },
    "split regions": {
      "name": "split regions",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[grid]",
      "parameters": [
        {
          "name": "input grid",
          "typing": "grid",
          "description": "the grid to split into regions"
        },
        {
          "name": "splitting scheme",
          "typing": "splitting scheme := str | Callable[[grid], list[grid]]",
          "description": "logic to determine how to split the grid into regions"
        }
      ],
      "description": null,
      "cues": [],
      "implementation": [],
      "used_in": [
        "prelim",
        "cf98881b",
        "9f236235",
        "6455b5f5",
        "29623171",
        "941d9a10",
        "1b2d62fb",
        "780d0b14",
        "1e32b0e9",
        "0520fde7",
        "0b148d64",
        "09629e4f",
        "3428a4f5",
        "06df4c85",
        "8e5a5113"
      ]
    },
    "draw object": {
      "name": "draw object",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "sprite",
          "typing": "grid",
          "description": "the sprite to draw"
        },
        {
          "name": "base",
          "typing": "grid",
          "description": "the grid to draw onto"
        },
        {
          "name": "position",
          "typing": "position",
          "description": "the position to place the sprite"
        },
        {
          "name": "background",
          "typing": "color",
          "description": "the color to treat as background when overlaying (optional)"
        }
      ],
      "description": "draw a sprite on top of a base grid, drawing over the base grid with the sprite's non-background pixels",
      "cues": [
        "if input objects are replicated or overlaid one or more times in the output",
        "if a sprite, motif, or pattern is drawn or overlaid at a specific position in the output grid",
        "if a completed, modified, or transformed region is overlaid back onto the original grid at its original or a specified position",
        "if colored regions, patterns, or sprites are overlaid at specific positions or inside larger objects/frames in the output grid",
        "if layers or patterns are built up by drawing on top of each other, or objects are redrawn to restore outlines or details",
        "if the output grid is constructed by assembling multiple copies of an object at specified positions"
      ],
      "implementation": [
        "overlay the sprite's non-background pixels onto the base grid at the specified position, leaving background pixels unchanged"
      ],
      "used_in": [
        "prelim",
        "cf98881b",
        "1b60fb0c",
        "5c2c9af4",
        "025d127b",
        "d2abd087",
        "6855a6e4",
        "810b9b61",
        "97a05b5b",
        "1a07d186",
        "6455b5f5",
        "a8c38be5",
        "db93a21d",
        "56dc2b01",
        "941d9a10",
        "6b9890af",
        "150deff5",
        "6a1e5592",
        "a9f96cdd",
        "1e32b0e9",
        "05f2a901",
        "5168d44c",
        "6cf79266",
        "6d75e8bb",
        "e9614598",
        "b775ac94",
        "fcc82909",
        "3bdb4ada",
        "1caeab9d",
        "3befdf3e",
        "e8dc4411",
        "eb281b96",
        "bc1d5164",
        "eb5a1d5d",
        "feca6190",
        "b7249182",
        "41e4d17e",
        "a79310a0",
        "e73095fd",
        "8d5021e8",
        "f8a8fe49",
        "0e206a2e",
        "8e5a5113",
        "44d8ac46",
        "137eaa0f",
        "57aa92db",
        "2bcee788",
        "46f33fce"
      ]
    },
    "is color criteria": {
      "name": "is color criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": null
        },
        {
          "name": "color",
          "typing": "color",
          "description": null
        }
      ],
      "description": "condition on whether an object is a given color",
      "cues": [],
      "implementation": [],
      "used_in": [
        "prelim",
        "228f6490",
        "4093f84a",
        "48d8fb45",
        "8e1813be",
        "23581191",
        "f9012d9b",
        "d06dbe63",
        "6e19193c",
        "6855a6e4",
        "97a05b5b",
        "e179c5f4",
        "2dd70a9a",
        "8d510a79",
        "1190e5a7",
        "239be575",
        "56dc2b01",
        "508bd3b6",
        "6a1e5592",
        "a9f96cdd",
        "05f2a901",
        "5168d44c",
        "1caeab9d",
        "caa06a1f",
        "feca6190",
        "1f642eb9",
        "1fad071e",
        "3618c87e",
        "af902bf9",
        "0ca9ddb6",
        "d4a91cb9",
        "ea786f4a",
        "aba27056",
        "b527c5c6",
        "aabf363d",
        "11852cab",
        "2204b7a8",
        "b782dc8a",
        "00d62c1b",
        "d4f3cd78",
        "d9f24cd1",
        "137eaa0f"
      ]
    },
    "move object": {
      "name": "move object",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid | object",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to move"
        },
        {
          "name": "position",
          "typing": "position",
          "description": "the position to move the object to"
        },
        {
          "name": "direction",
          "typing": "direction",
          "description": "direction to move in (optional, for relative moves)"
        },
        {
          "name": "step",
          "typing": "int",
          "description": "number of steps to move in the given direction (optional)"
        }
      ],
      "description": "move an object to a new position in the grid, updating the grid accordingly",
      "cues": [
        "if existing structures from the input grid appear in the output grid with different positions",
        "if the output grid is a shifted version of the input grid or of an object in the input grid",
        "if objects are repositioned to align with another object's coordinate (e.g., matching y or x position)",
        "if pixels or objects in the input grid appear to \"fall\" or move vertically to the lowest available position in their column in the output grid, or are shifted downward, possibly stacking on a baseline or other pixels",
        "if a pixel or object in the input grid appears shifted by one row or column in the output grid, including single colored pixels moving to a new position",
        "if the solution checks for adjacency by moving an object one step in a direction and testing for overlap/contact"
      ],
      "implementation": [
        "erase the object pixels from the old position before drawing the object at the new position",
        "to move an object by one pixel in a direction, increment the object's coordinate(s) accordingly and redraw it at the new position",
        "to align objects along a coordinate, set the desired coordinate (e.g., y) to match the reference object while keeping the other coordinate unchanged",
        "for relative moves, update all pixel positions of the object by the direction and step"
      ],
      "used_in": [
        "prelim",
        "228f6490",
        "25ff71a9",
        "1caeab9d",
        "3618c87e",
        "834ec97d",
        "a79310a0",
        "2bcee788"
      ]
    },
    "tile object": {
      "name": "tile object",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to tile"
        },
        {
          "name": "start",
          "typing": "position",
          "description": "the starting position to tile the object from"
        },
        {
          "name": "direction",
          "typing": "direction",
          "description": "the direction to tile the object in"
        },
        {
          "name": "gap",
          "typing": "int",
          "description": "the gap between tiled objects (can be 0 for contiguous tiling, or a positive integer for spaced tiling)"
        },
        {
          "name": "pattern",
          "typing": "grid",
          "description": "a patch to tile (if multiple objects should be tiled as a unit)"
        },
        {
          "name": "repetitions",
          "typing": "tuple[int, int]",
          "description": "number of times to repeat the object in each direction (rows, columns)"
        }
      ],
      "description": "repeatedly copy an object in a specified direction",
      "cues": [
        "if an object or motif from the input grid is repeated in a regular, evenly spaced pattern in the output grid (e.g., filling a dimension, forming a rectangular grid, or along a line)",
        "if the output grid is larger than the input grid and consists of exact or regularly spaced copies of the input or its sub-objects",
        "if an object is repeatedly moved and drawn at regular intervals in a fixed direction in the output grid"
      ],
      "implementation": [
        "use numpy.tile or nested loops to repeat the input grid or object the specified number of times along each axis or direction, applying the specified gap between repetitions",
        "repeatedly move and draw the object by the specified gap in the given direction, stopping when the placement would go out of bounds"
      ],
      "used_in": [
        "prelim",
        "e21d9049",
        "8403a5d5",
        "017c7c7b",
        "10fcaaa3",
        "045e512c"
      ]
    },
    "create new grid": {
      "name": "create new grid",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "dimensions",
          "typing": "dimensions := tuple[int, int]",
          "description": "the dimensions of the new grid to create (rows, columns)"
        },
        {
          "name": "fill color",
          "typing": "color",
          "description": "the color to fill the new grid with (default is 0)"
        }
      ],
      "description": "create a new grid with specified dimensions, initialized with a fill color",
      "cues": [
        "if output grid dimensions differ from input grid dimensions",
        "if output grid content is initialized as blank or filled with a single color before further drawing or tiling",
        "if output grid is a fixed size (e.g., 1x1, single row/column, or specific pattern) regardless of input grid size or content",
        "if output grid dimensions depend on the number of objects or layers in the input",
        "if output grid is larger or smaller than any input region and not a direct copy of any input region"
      ],
      "implementation": [
        "use numpy.full or numpy.zeros to create a new grid with the specified dimensions and fill color",
        "ensure the grid is initialized before any drawing or overlay operations",
        "parameterize the grid size and fill color to allow for flexible reuse in different contexts"
      ],
      "used_in": [
        "prelim",
        "ff28f65a",
        "44f52bb0",
        "d2abd087",
        "017c7c7b",
        "1a07d186",
        "6455b5f5",
        "623ea044",
        "a8c38be5",
        "db93a21d",
        "1190e5a7",
        "239be575",
        "56dc2b01",
        "941d9a10",
        "6b9890af",
        "f8b3ba0a",
        "1b2d62fb",
        "a9f96cdd",
        "05f2a901",
        "90c28cc7",
        "3ac3eb23",
        "5168d44c",
        "6cf79266",
        "fcc82909",
        "178fcbfb",
        "0520fde7",
        "1caeab9d",
        "eb281b96",
        "bc1d5164",
        "eb5a1d5d",
        "e48d4e1a",
        "caa06a1f",
        "28e73c20",
        "feca6190",
        "09629e4f",
        "1fad071e",
        "6f8cd79b",
        "746b3537",
        "3428a4f5",
        "a79310a0",
        "e73095fd",
        "8d5021e8",
        "995c5fa3",
        "31aa019c",
        "0e206a2e",
        "44d8ac46",
        "137eaa0f",
        "2bcee788"
      ]
    },
    "reflect grid": {
      "name": "reflect grid",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to reflect"
        },
        {
          "name": "axis",
          "typing": "axis := Literal[\"horizontal\", \"vertical\", \"both\"]",
          "description": "the axis to reflect the grid across (horizontal, vertical, or both)"
        }
      ],
      "description": "reflect a grid across a specified axis, creating a mirrored version of the grid",
      "cues": [
        "if existing structures from the input grid appear in the output grid with mirrored positions"
      ],
      "implementation": [
        "use np.flip"
      ],
      "used_in": [
        "prelim",
        "9f236235",
        "6fa7a44f",
        "eb281b96"
      ]
    },
    "rotate object": {
      "name": "rotate object",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid | object",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to rotate"
        },
        {
          "name": "angle",
          "typing": "int",
          "description": "the angle to rotate the object by (in degrees)"
        },
        {
          "name": "center",
          "typing": "position",
          "description": "the center of rotation (optional; default is grid center)"
        }
      ],
      "description": "rotate an object by a specified angle, updating the grid accordingly",
      "cues": [
        "Presence of an object in the input grid that appears rotated in the output grid",
        "Same object appears multiple times with different rotations",
        "Emergence of rotational symmetry in the output grid not present in the input"
      ],
      "implementation": [
        "Use numpy functions such as np.rot90 or affine transformations to rotate the object's pixels around the specified center"
      ],
      "used_in": [
        "prelim",
        "1b60fb0c",
        "97a05b5b",
        "3bdb4ada",
        "b7249182",
        "11852cab",
        "8e5a5113"
      ]
    },
    "size criteria": {
      "name": "size criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object whose size is to be checked"
        },
        {
          "name": "comparison operator",
          "typing": "comparison operator := Literal[\"==\", \"!=\", \"<\", \"<=\", \">\", \">=\"]",
          "description": "the operator to use for comparison"
        },
        {
          "name": "comparison value",
          "typing": "int",
          "description": "the value to compare the object's size against"
        }
      ],
      "description": "condition on whether an object meets a size criteria (numerical comparison on object size against some other value)",
      "cues": [
        "if objects are colored differently based on their size",
        "if the output grid shows objects of a particular area or pixel count treated specially",
        "if only 1x1, 2x2, or other specific-sized objects are affected in the output"
      ],
      "implementation": [
        "compare the object's size attribute (such as area or pixel count) to the given value using the specified operator"
      ],
      "used_in": [
        "prelim",
        "3e980e27",
        "d2abd087",
        "aedd82e4",
        "6e82a1ae",
        "25d487eb",
        "239be575",
        "7e0986d6",
        "b775ac94",
        "e8dc4411",
        "6d58a25d",
        "0e206a2e"
      ]
    },
    "has color criteria": {
      "name": "has color criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": null
        },
        {
          "name": "color",
          "typing": "color",
          "description": null
        }
      ],
      "description": "condition on whether a target object's colors include a given color",
      "cues": [],
      "implementation": [],
      "used_in": [
        "prelim",
        "3e980e27",
        "6cdd2623",
        "1a07d186",
        "6b9890af",
        "f8a8fe49",
        "2204b7a8",
        "31aa019c",
        "7c008303",
        "2bcee788"
      ]
    },
    "draw line": {
      "name": "draw line",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "start",
          "typing": "position",
          "description": "the starting position to draw the line from"
        },
        {
          "name": "end",
          "typing": "position",
          "description": "the ending position to draw the line to"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color of the line to draw"
        },
        {
          "name": "direction",
          "typing": "direction := Literal[\"up\", \"down\", \"left\", \"right\", \"up-right\", \"up-left\", \"down-right\", \"down-left\"]",
          "description": "the direction to draw the line in (up, down, left, or right)"
        },
        {
          "name": "length",
          "typing": "int | str",
          "description": "the length of the line to draw (can be \"to_edge\" to indicate spanning the grid)"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to draw the line on"
        },
        {
          "name": "stop_at_color",
          "typing": "color",
          "description": "color at which to stop drawing the line (optional; if present, line stops when this color is encountered)"
        },
        {
          "name": "step",
          "typing": "int",
          "description": "the step size between colored pixels along the line (e.g., 2 for every other pixel)"
        },
        {
          "name": "until",
          "typing": "stopping criteria := Callable[[position, grid], bool]",
          "description": "stopping condition for drawing the line (e.g., out of bounds)"
        },
        {
          "name": "stop_at",
          "typing": "object | grid",
          "description": "optional; stop drawing when this object/grid is reached"
        }
      ],
      "description": "draw a line between two pixels in a grid, updating the grid accordingly",
      "cues": [
        "output grid contains lines not present in the input grid",
        "output grid contains lines passing through, extending from, or adjacent to specific pixels or objects in the input grid",
        "lines span the entire grid in a direction from a given pixel, or terminate at a colored object or grid edge",
        "lines are drawn in straight, diagonal, or staircase patterns, possibly alternating directions or forming an \"X\"",
        "lines are drawn from specific points (e.g., object corners, edges, or centers) outward in one or more directions",
        "output grid contains lines connecting objects, pixels, or scattered points to the edge of a region or frame",
        "lines are repeated at regular intervals along a row or column, or show periodic gaps (e.g., every other cell colored)",
        "output grid contains new horizontal or vertical bars aligned with colored pixels in the input grid, possibly replacing single pixels with full-length bars",
        "lines are drawn from or to specific colored pixels and stop at another color, object, or grid boundary",
        "output grid contains lines that \"navigate\" around obstacles or change direction at the grid edge",
        "output grid shows objects with longer arms or bars than in the input, or arms extended from a central axis",
        "output grid contains new colored bars or lines at the center or top of rectangles or other shapes"
      ],
      "implementation": [
        "draw the line pixel by pixel from the starting point, updating the position by the direction vector until the end point, grid edge, or stopping condition is met",
        "for lines spanning the grid, set length to grid height (vertical) or grid width (horizontal); for \"to_edge\", continue until the grid boundary",
        "use a loop to set each pixel along the line to the specified color; for step > 1, color every step-th pixel",
        "for diagonal lines, increment/decrement both x and y according to the direction",
        "for staircase or alternating patterns, update the direction and starting position as needed",
        "stop drawing if the next pixel is the stop_at_color, stop_at object, or if a custom stopping criteria is met",
        "for repeated lines at regular intervals, loop over offsets and call the line-drawing routine for each",
        "for vertical or horizontal bars, fix one coordinate and vary the other across the grid dimension",
        "to extend arms or bars, use the center or relevant object edge as the start and draw in each direction with the desired length",
        "for lines that must avoid obstacles, include logic to change direction or skip blocked positions",
        "return the last position reached (end_pixel) if further processing is needed"
      ],
      "used_in": [
        "prelim",
        "6cdd2623",
        "8403a5d5",
        "8e1813be",
        "23581191",
        "d06dbe63",
        "6e19193c",
        "a78176bb",
        "e179c5f4",
        "623ea044",
        "db3e9e38",
        "8d510a79",
        "db93a21d",
        "508bd3b6",
        "3ac3eb23",
        "178fcbfb",
        "6d58a25d",
        "0a938d79",
        "b7249182",
        "5daaa586",
        "6f8cd79b",
        "834ec97d",
        "05269061",
        "d4a91cb9",
        "ea786f4a",
        "aba27056",
        "b527c5c6",
        "41e4d17e",
        "444801d8",
        "995c5fa3",
        "0962bcdd",
        "d4f3cd78",
        "d9f24cd1"
      ]
    },
    "inside container criteria": {
      "name": "inside container criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": null
        }
      ],
      "description": "condition on whether an object is inside a container",
      "cues": [],
      "implementation": [
        "determine if the grid edge is reachable from the would-be inner object. The inner and outer objects only have the containment relationship if the inner object only reaches the grid edge through outer object pixels."
      ],
      "used_in": [
        "776ffc46"
      ]
    },
    "container": {
      "name": "container",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "an object that contains other objects, often used to define a region of interest",
      "cues": [
        "if there is an object with a cavity",
        "if there are objects with an empty interior and a single pixel inside, and the output fills the interior with that pixel's color"
      ],
      "implementation": [],
      "used_in": [
        "776ffc46",
        "444801d8"
      ]
    },
    "fixed color mapping": {
      "name": "fixed color mapping",
      "kind": "routine",
      "routine_subtype": "color scheme",
      "output_typing": "color",
      "parameters": [
        {
          "name": "input",
          "typing": "object",
          "description": "the object/pixel to recolor"
        }
      ],
      "description": "use a fixed, predetermined mapping from original -> new color",
      "cues": [
        "if a specific color is systematically replaced by another in the output grid",
        "if a specific color is systematically assigned based on object rank or order, or if output grid colors follow a fixed palette in a ranked or ordered fashion"
      ],
      "implementation": [
        "assign colors to objects in the order determined by sorting or ranking"
      ],
      "used_in": [
        "0d3d703e",
        "017c7c7b",
        "6a1e5592",
        "08ed6ac7"
      ]
    },
    "split on divider lines": {
      "name": "split on divider lines",
      "kind": "routine",
      "routine_subtype": "splitting scheme",
      "output_typing": "list[grid]",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to split"
        },
        {
          "name": "divider_color",
          "typing": "color",
          "description": "the color used for divider lines to partition the grid"
        }
      ],
      "description": "identify lines that divide the grid into regions, extract these regions",
      "cues": [
        "if the grid is visually partitioned into rectangles by lines of a specific color (e.g., black or grey)"
      ],
      "implementation": [
        "identify continuous lines of the divider color that span the grid and use them to slice the grid into regions via array slicing"
      ],
      "used_in": [
        "cf98881b",
        "6455b5f5",
        "29623171",
        "941d9a10",
        "1b2d62fb",
        "1e32b0e9",
        "0520fde7",
        "0b148d64",
        "09629e4f",
        "3428a4f5",
        "8e5a5113"
      ]
    },
    "divider lines": {
      "name": "divider lines",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "lines that divide the grid into regions, often used to define a grid of regions",
      "cues": [
        "if there are lines that span the grid and partition it"
      ],
      "implementation": [],
      "used_in": [
        "cf98881b",
        "9f236235",
        "6455b5f5",
        "29623171",
        "941d9a10",
        "780d0b14",
        "1e32b0e9",
        "09629e4f",
        "3428a4f5",
        "06df4c85"
      ]
    },
    "get object holes": {
      "name": "get object holes",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[object]",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to get holes from"
        }
      ],
      "description": "get the holes in an object, i.e. the empty spaces inside the object",
      "cues": [
        "Presence of objects in the input grid with empty regions or cavities inside them.",
        "Output grid distinguishes between objects with internal holes and solid objects."
      ],
      "implementation": [
        "Use a background color mask to identify holes within the object if the background color is known.",
        "Alternatively, perform a flood fill from non-object pixels to determine if empty regions inside the object are not connected to the grid edge, indicating holes."
      ],
      "used_in": [
        "228f6490",
        "810b9b61",
        "444801d8",
        "44d8ac46"
      ]
    },
    "hole": {
      "name": "hole",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "an empty space inside an object, often used to define a region of interest",
      "cues": [
        "if there is an object with a cavity"
      ],
      "implementation": [],
      "used_in": [
        "228f6490",
        "810b9b61",
        "444801d8"
      ]
    },
    "direction between objects": {
      "name": "direction between objects",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "direction",
      "parameters": [
        {
          "name": "object1",
          "typing": "object",
          "description": null
        },
        {
          "name": "object2",
          "typing": "object",
          "description": null
        },
        {
          "name": "allowed_directions",
          "typing": "list[direction]",
          "description": "restricts the set of directions considered for movement (optional)"
        }
      ],
      "description": "determine the direction from one object to another, often used for sliding or moving objects towards a target",
      "cues": [
        "when you need to determine the direction from one object or part of an object to another, such as from colored to background pixels",
        "when the output depends on the orientation or pointing direction of an object",
        "when movement or transformation is constrained to cardinal directions (up, down, left, right), or output grids show pixels moving only along rows or columns"
      ],
      "implementation": [
        "can be applied to positions, such as using the mean position of colored pixels versus background pixels",
        "compute the vector from the source to the target and select the closest matching direction from allowed_directions"
      ],
      "used_in": [
        "4093f84a",
        "6e19193c",
        "1a07d186",
        "a8c38be5",
        "56dc2b01",
        "e8dc4411",
        "1f642eb9",
        "aba27056",
        "b527c5c6"
      ]
    },
    "slide object": {
      "name": "slide object",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid | object",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to slide"
        },
        {
          "name": "direction",
          "typing": "object",
          "description": "direction to slide in"
        },
        {
          "name": "stopping criteria",
          "typing": "stopping criteria := Callable[[object, grid], bool]",
          "description": "criteria to determine when to stop sliding the object"
        },
        {
          "name": "steps",
          "typing": "int",
          "description": "number of steps to slide the object (optional; default is to slide until stopping_criteria is met)"
        }
      ],
      "description": "moving an object in a specified direction step by step until a stopping condition is met",
      "cues": [
        "If objects or structures in the input grid appear in the output grid shifted in a cardinal direction, often stopping just before contacting another object or the grid boundary.",
        "If movement is limited to a certain number of steps, or objects move stepwise in a direction until a condition is met (such as collision or reaching a target).",
        "If pixels or objects move in straight lines toward a target or region, with the output showing their new positions after such movement."
      ],
      "implementation": [
        "Move the object one step at a time in the specified direction, checking the stopping_criteria after each step; stop when the criteria is met or after the specified number of steps.",
        "Alternatively, consider all possible displacements in the direction and select the furthest valid position before a collision or boundary, according to the stopping_criteria."
      ],
      "used_in": [
        "4093f84a",
        "1a07d186",
        "56dc2b01",
        "05f2a901",
        "5168d44c",
        "1f642eb9"
      ]
    },
    "collision criteria": {
      "name": "collision criteria",
      "kind": "routine",
      "routine_subtype": "stopping criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": null
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": null
        },
        {
          "name": "other",
          "typing": "object",
          "description": "the object to check collision with (e.g., teal object)"
        }
      ],
      "description": "detects a collision when an object is in contact with another object in the direction of movement",
      "cues": [
        "if movement stops when a pixel contacts a specific object (not just any non-background pixel)",
        "if output grid shows pixels stopping at a colored region or object"
      ],
      "implementation": [
        "check if the object is adjacent to the specified target object in the movement direction after each step"
      ],
      "used_in": [
        "4093f84a",
        "56dc2b01",
        "1f642eb9"
      ]
    },
    "region grid": {
      "name": "region grid",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "where the grid is partitioned into a grid of distinct regions",
      "cues": [
        "presence of horizontal and vertical lines that partition the grid into non-overlapping regions or tiles",
        "input grid is visually organized as a grid of distinct regions, or output grid has one pixel per input region, preserving region order"
      ],
      "implementation": null,
      "used_in": [
        "9f236235",
        "1e32b0e9",
        "90c28cc7",
        "0b148d64",
        "09629e4f",
        "06df4c85"
      ]
    },
    "split region grid": {
      "name": "split region grid",
      "kind": "routine",
      "routine_subtype": "splitting scheme",
      "output_typing": "list[list[grid]]",
      "parameters": [
        {
          "name": "input grid",
          "typing": "grid",
          "description": "the grid to split into regions"
        }
      ],
      "description": "split grid into a grid of regions",
      "cues": [],
      "implementation": [
        "use divider lines and array slicing to extract regions from the grid"
      ],
      "used_in": [
        "9f236235",
        "780d0b14"
      ]
    },
    "convert region grid to pixel grid": {
      "name": "convert region grid to pixel grid",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "region_grid",
          "typing": "list[list[grid]]",
          "description": "the grid of regions to convert to a pixel grid"
        },
        {
          "name": "color selection",
          "typing": "color selection := Callable[[grid], color]",
          "description": "logic to select a color for each region"
        }
      ],
      "description": "convert a grid of regions into a pixel grid where each pixel corresponds to a region",
      "cues": [
        "Input grid contains a region grid, but output grid does not preserve the region grid structure.",
        "Output grid dimensions match the number of regions along each axis of the input region grid (i.e., one output pixel per region).",
        "Output pixel colors correspond to a representative color from each region in the input grid."
      ],
      "implementation": [
        "Create a new grid with the same dimensions as the region grid; for each region, use the color selection logic to determine a representative color (e.g., the color of the top-left pixel or the dominant/only color in the region) and assign it to the corresponding output pixel."
      ],
      "used_in": [
        "9f236235",
        "780d0b14",
        "90c28cc7"
      ]
    },
    "split object": {
      "name": "split object",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[object]",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to split"
        },
        {
          "name": "object splitting scheme",
          "typing": "object splitting scheme := str | Callable[[object], list[object]]",
          "description": "logic to determine how to split the object into parts"
        }
      ],
      "description": "split an object into two parts based on a specified scheme",
      "cues": [
        "if a region is divided into two halves along a symmetry axis for further processing",
        "if the output grid contains mirrored or transformed halves of an input pattern"
      ],
      "implementation": null,
      "used_in": [
        "e21d9049",
        "f8a8fe49",
        "7c008303"
      ]
    },
    "split cross": {
      "name": "split cross",
      "kind": "routine",
      "routine_subtype": "object splitting scheme",
      "output_typing": "list[object]",
      "parameters": [
        {
          "name": "cross",
          "typing": "object",
          "description": "the cross object to split"
        }
      ],
      "description": "split a cross object into its horizontal and vertical bars",
      "cues": [],
      "implementation": [
        "identify the center of the cross and split it into horizontal and vertical bars based on the center"
      ],
      "used_in": [
        "e21d9049"
      ]
    },
    "count objects": {
      "name": "count objects",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "objects",
          "typing": "list[object]",
          "description": "the list of objects to count"
        },
        {
          "name": "criteria",
          "typing": "selection criteria",
          "description": "criteria to filter objects before counting (optional)"
        },
        {
          "name": "by",
          "typing": "str",
          "description": "attribute to group counts by (e.g., \"color\") (optional)"
        }
      ],
      "description": "count the number of objects in a list, optionally filtering by criteria",
      "cues": [
        "if the output depends on the frequency or count of objects of each color",
        "if colors are selected or ordered based on how many objects have that color",
        "if the output grid size or content depends on the number of unique colors in the input grid, excluding background"
      ],
      "implementation": [
        "if by=\"color\", count the number of objects for each color and return a dict mapping color to count",
        "can use collections.Counter or similar to tally counts by attribute"
      ],
      "used_in": [
        "ff28f65a",
        "f8b3ba0a",
        "feca6190",
        "1fad071e"
      ]
    },
    "draw expandable shape": {
      "name": "draw expandable shape",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "pattern",
          "typing": "pattern := str | Callable[[int], grid]",
          "description": "the pattern to draw (e.g., \"checkerboard\")"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color to use for the pattern"
        },
        {
          "name": "scale",
          "typing": "int",
          "description": "the scale factor for the pattern, determining how many times to repeat it"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to draw the pattern on"
        }
      ],
      "description": "draw a pattern on a grid, scaling it based on a specified factor",
      "cues": [
        "if a region is extended from an edge or indicator pixel, with width or height matching another object's extent or extending to the grid border in a specific direction",
        "if output grid contains bars or rectangles extending from an object to the grid edge, with size determined by the object's dimensions"
      ],
      "implementation": [
        "for a \"rectangle_bar\" pattern, create a rectangle of the appropriate width or height starting at the indicator and extending in the given direction to the grid edge; scale parameter determines the width (if extending horizontally) or height (if vertically)"
      ],
      "used_in": [
        "ff28f65a",
        "b527c5c6"
      ]
    },
    "new pixels criteria": {
      "name": "new pixels criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to check if it is new"
        },
        {
          "name": "old",
          "typing": "grid",
          "description": "the old grid to compare against"
        }
      ],
      "description": "condition on whether an object is new, i.e. does not exist in the old grid",
      "cues": [],
      "implementation": [],
      "used_in": [
        "1b60fb0c"
      ]
    },
    "reflect object": {
      "name": "reflect object",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid | object",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to reflect"
        },
        {
          "name": "axis",
          "typing": "axis",
          "description": "the axis to reflect across"
        },
        {
          "name": "mirror_axis",
          "typing": "int | float",
          "description": "the coordinate value of the mirror axis (e.g., x=5 or y=3)"
        },
        {
          "name": "mirror_axis | position",
          "typing": "int | float | position",
          "description": "the coordinate or position of the mirror axis (optional; for reflecting across a specific edge)"
        }
      ],
      "description": "reflect an object across a specified axis, updating the grid accordingly",
      "cues": [
        "if structures or objects in the input grid appear in the output grid with mirrored orientation",
        "if objects in the output are mirrored versions of input objects, especially when the axis of reflection is not always the grid center",
        "if reflection occurs relative to another object, such as a frame, guide, or adjacent colored pixel",
        "if the output grid contains repeated or tiled mirrored copies of an input object or region, possibly with different orientations (e.g., original, horizontally flipped, vertically flipped)",
        "if the solution tests for equality up to reflection",
        "if the axis of reflection is determined by the position of an indicator, marker, or is aligned with an object's edge",
        "if mirrored halves or regions are reflected before being placed or used to cover another region in the output"
      ],
      "implementation": [
        "use np.flip for standard horizontal or vertical axis reflections",
        "calculate the mirror axis (line of symmetry) based on the position of a reference object, indicator, or specified coordinate",
        "for each pixel in the object, compute its reflected position across the specified axis and mirror_axis; for non-grid-aligned axes, perform custom coordinate transforms",
        "for grid-aligned axes, use np.flip; for arbitrary axes or positions, compute new coordinates manually",
        "reflect the object across the specified axis and position, ensuring placement aligns with the intended region or adjacent object"
      ],
      "used_in": [
        "3e980e27",
        "4c5c2cf0",
        "6855a6e4",
        "2dee498d",
        "b775ac94",
        "8d5021e8",
        "f8a8fe49",
        "2bcee788"
      ]
    },
    "complete partial sprite": {
      "name": "complete partial sprite",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "full sprite",
          "typing": "object",
          "description": "the object to draw"
        },
        {
          "name": "partial sprite",
          "typing": "object",
          "description": "specifies the position of where to draw the full sprite; is a subset of the full sprite"
        }
      ],
      "description": "complete a partial sprite by drawing the full sprite in a position that aligns matching pixels (in the z-axis) with the partial sprite",
      "cues": [],
      "implementation": [
        "determine the position the full sprite should be drawn to align with the partial sprite and draw it there"
      ],
      "used_in": [
        "3e980e27"
      ]
    },
    "contact criteria": {
      "name": "contact criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": null
        },
        {
          "name": "other",
          "typing": "object",
          "description": null
        },
        {
          "name": "background",
          "typing": "color",
          "description": "background color to ignore when checking contact (optional)"
        }
      ],
      "description": "condition on whether an object is in contact with another object, i.e. they share a pixel or edge",
      "cues": [
        "if objects or pixels move until they reach another object in the output grid",
        "if output pixels stop at the edge of a bar or larger object",
        "if the output depends on whether two objects are connected, touching, or form a single contiguous region",
        "if the presence of a path or connection between objects determines the output",
        "if objects are grouped, merged, or considered in contact based on adjacency or connectivity (i.e., not separated by background pixels)",
        "if the output grid shows two objects just touching, with one moved to abut the other",
        "if the stopping condition for movement is adjacency or overlap with a target object"
      ],
      "implementation": [
        "check if the moved object is adjacent to or overlapping the target object after each step",
        "for each pair of objects, check if their pixel sets are adjacent or overlap (using 4-way or 8-way connectivity as appropriate), ignoring background color",
        "can use connected components labeling to see if two regions are part of the same component"
      ],
      "used_in": [
        "48d8fb45",
        "1a07d186",
        "239be575",
        "56dc2b01",
        "05f2a901",
        "b775ac94",
        "e8dc4411"
      ]
    },
    "crop around objects": {
      "name": "crop around objects",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "objects",
          "typing": "list[object]",
          "description": "the list of objects to crop"
        },
        {
          "name": "border",
          "typing": "int",
          "description": "number of pixels to trim from the border of the cropped region (optional; default 0)"
        },
        {
          "name": "background",
          "typing": "color",
          "description": "color to treat as background and exclude from the cropped region (optional)"
        }
      ],
      "description": "create a new grid that is a contiguous sub region of the input grid, containing the minimum bounding box of the specified objects",
      "cues": [
        "if the output grid is smaller than the input grid",
        "if the output grid contains only a subset of the objects in the input grid",
        "if the output grid is a contiguous subregion of the input grid, especially one corresponding to a single object, region of interest, frame, or container",
        "if a central pattern or minimal sprite is extracted from a larger grid for further manipulation",
        "if only the content of an object (without surrounding background) is drawn elsewhere in the output grid",
        "if patterns or objects are copied from the input grid but appear tightly cropped in the output",
        "if the output grid is a rectangle bounded by colored lines or a minimal bounding box containing a single object from the input grid",
        "if you need to extract the content of a region or square, ignoring divider lines or background"
      ],
      "implementation": [
        "find the extrema for x and y coordinates of the specified objects and use them to slice the grid",
        "to remove a border, crop the bounding box of the object and then trim the specified number of pixels from each edge",
        "after cropping, optionally trim away a border of background color pixels or mask out pixels of the background color if specified",
        "to extract a sprite or region, crop the bounding box of the object, possibly by specifying (row, col, height, width)"
      ],
      "used_in": [
        "48d8fb45",
        "8e1813be",
        "f9012d9b",
        "97a05b5b",
        "6b9890af",
        "3de23699",
        "6a1e5592",
        "1e32b0e9",
        "2dee498d",
        "6d75e8bb",
        "72ca375d",
        "bc1d5164",
        "0b148d64",
        "09629e4f",
        "5daaa586",
        "ce602527",
        "1cf80156",
        "aba27056"
      ]
    },
    "unique colors": {
      "name": "unique colors",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[color]",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to extract unique colors from"
        },
        {
          "name": "exclude",
          "typing": "list[color]",
          "description": "colors to ignore when extracting unique colors"
        }
      ],
      "description": "extract a list of unique colors from a grid",
      "cues": [
        "if a region or object contains a single colored pixel and that color is used elsewhere in the output",
        "if the output grid uses a color that appears only inside another object in the input grid"
      ],
      "implementation": [
        "use np.unique, then filter out excluded colors"
      ],
      "used_in": [
        "6cdd2623",
        "29623171",
        "fcc82909",
        "6d58a25d",
        "0b148d64",
        "feca6190",
        "ce602527",
        "444801d8"
      ]
    },
    "on edge criteria": {
      "name": "on edge criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": null
        },
        {
          "name": "parent",
          "typing": "grid | object",
          "description": "the parent object or grid to check against"
        }
      ],
      "description": "check if target object is on the edge of a parent object or grid",
      "cues": [
        "if only edge pixels are selected for further processing or movement",
        "if output grid features originate from the border of the input grid",
        "if the process starts from colored pixels on a specific edge (e.g., bottom row)"
      ],
      "implementation": [
        "for grid, check if object's pixel positions coincide with the border (i.e., row or column index is 0 or at max index)"
      ],
      "used_in": [
        "6cdd2623",
        "29c11459",
        "1f642eb9",
        "5daaa586",
        "d9f24cd1"
      ]
    },
    "alignment criteria": {
      "name": "alignment criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "object1",
          "typing": "object",
          "description": null
        },
        {
          "name": "object2",
          "typing": "object",
          "description": null
        }
      ],
      "description": "condition on whether two objects are aligned, i.e. they share the same rows or columns",
      "cues": [],
      "implementation": [],
      "used_in": [
        "6cdd2623"
      ]
    },
    "draw border outside": {
      "name": "draw border outside",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to draw a border around"
        },
        {
          "name": "border color",
          "typing": "color",
          "description": "the color of the border to draw"
        }
      ],
      "description": "draw a border around the outside of an object",
      "cues": [
        "if input objects appear with extra layer(s) of pixels around them in the output grid",
        "if a single pixel in the input grid is surrounded by a colored border in the output grid, with all other pixels set to background",
        "if the output grid contains a square or rectangular border centered on a unique pixel"
      ],
      "implementation": [
        "identify outermost pixels of the object and color their empty neighbors to create the border",
        "for a border of width 1, create a 3x3 square centered at the target pixel and set the border pixels to the border color, using array slicing or coordinate offsets",
        "alternatively, draw a larger version of the object (including the border), then overwrite the original object pixels to preserve their color"
      ],
      "used_in": [
        "4258a5f9",
        "31aa019c"
      ]
    },
    "sort objects": {
      "name": "sort objects",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[object]",
      "parameters": [
        {
          "name": "objects",
          "typing": "list[object]",
          "description": "the list of objects to sort (e.g., patterns)"
        },
        {
          "name": "key",
          "typing": "Callable[[object], Any]",
          "description": "function to extract a comparison key from each object (e.g., x or y coordinate)"
        },
        {
          "name": "reverse",
          "typing": "bool",
          "description": "whether to sort in descending order (optional)"
        }
      ],
      "description": "sort a list of objects according to a key function, often used to order objects spatially",
      "cues": [
        "if objects or regions need to be processed in a specific spatial order (e.g., top-to-bottom, left-to-right, diagonal, or by position)",
        "if objects are processed in an order determined by a property (e.g., size, area, color count, frequency, or another attribute)",
        "if the output grid's arrangement, coloring, or features depend on the order or ranking of objects by position, size, or attribute",
        "if nested, layered, or composite objects must be processed from outermost to innermost (or vice versa)",
        "if distinguishing or extracting inner and outer components by size is required",
        "if the crop region or output arrangement is defined by the spatial order of boundary or container objects",
        "if multiple frames, containers, lines, or bars must be processed in a specific spatial order (e.g., left-to-right, top-to-bottom)"
      ],
      "implementation": [
        "use Python's sorted() with a lambda function extracting the relevant key (e.g., x or y coordinate, position tuple, size, area, count, or attribute)",
        "for diagonal ordering, use a lambda extracting the diagonal index (e.g., x+y or x-y)",
        "for left-to-right or top-to-bottom sorting, use a lambda extracting the object's minimum x or y coordinate (e.g., bounding box edge)",
        "for sorting by frequency or size, use the count or area as the key and set reverse=True for descending order if needed",
        "for top-left ordering, use a lambda extracting (y, x) from the object's position attribute",
        "set reverse=True to sort from largest to smallest (e.g., tallest to shortest, outermost to innermost)"
      ],
      "used_in": [
        "8e1813be",
        "5c2c9af4",
        "97a05b5b",
        "7447852a",
        "941d9a10",
        "f8b3ba0a",
        "1e32b0e9",
        "90c28cc7",
        "08ed6ac7",
        "3befdf3e",
        "eb5a1d5d",
        "b7249182",
        "746b3537",
        "995c5fa3",
        "f8a8fe49",
        "3f7978a0"
      ]
    },
    "remove consecutive duplicates": {
      "name": "remove consecutive duplicates",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[Any]",
      "parameters": [
        {
          "name": "sequence",
          "typing": "list[Any]",
          "description": "the sequence to remove consecutive duplicates from"
        }
      ],
      "description": "remove consecutive duplicate elements from a sequence, preserving order",
      "cues": [
        "if a sequence of colors or objects is extracted and consecutive repetitions should be collapsed"
      ],
      "implementation": [
        "iterate through the sequence and only keep an element if it differs from the previous one"
      ],
      "used_in": [
        "8e1813be"
      ]
    },
    "stripe": {
      "name": "stripe",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "a contiguous object that is either one row (horizontal) or one column (vertical) in extent, often used to fill or pattern a region",
      "cues": [
        "if the grid contains objects that are long and thin, spanning the width or height of a region",
        "if the output grid consists of a single row or column of colored pixels, especially with one color per pixel",
        "if the output grid is a vertical or horizontal line of colors"
      ],
      "implementation": null,
      "used_in": [
        "8e1813be",
        "f8b3ba0a",
        "1fad071e",
        "746b3537"
      ]
    },
    "orientation detection": {
      "name": "orientation detection",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "Literal[\"horizontal\", \"vertical\"]",
      "parameters": [
        {
          "name": "objects",
          "typing": "list[object]",
          "description": "the objects whose orientation is to be determined"
        }
      ],
      "description": "determine if a set of objects are all horizontal (height 1) or all vertical (width 1)",
      "cues": [
        "if objects are all of height 1 or all of width 1",
        "if objects are all aligned in a row or column (e.g., stripes, green dots, lines)",
        "if the direction of movement, extension, or symmetry depends on the orientation or alignment of objects",
        "if the output grid's orientation (vertical/horizontal) depends on the arrangement of input objects",
        "if the track or path is defined by a set of aligned markers"
      ],
      "implementation": [
        "check if all objects have height 1 (horizontal) or width 1 (vertical)",
        "check if all objects have the same x (vertical alignment) or y (horizontal alignment) coordinate"
      ],
      "used_in": [
        "8e1813be",
        "6855a6e4",
        "2dd70a9a",
        "8d510a79",
        "5168d44c",
        "0a938d79",
        "746b3537"
      ]
    },
    "diagonal order": {
      "name": "diagonal order",
      "kind": "routine",
      "routine_subtype": "Callable[[object], int]",
      "output_typing": "int",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object whose diagonal index is to be computed"
        }
      ],
      "description": "ordering objects by their position along the main diagonal (e.g., x+y or x-y)",
      "cues": [
        "if objects are arranged along a diagonal in the grid"
      ],
      "implementation": [
        "for main diagonal use x+y, for anti-diagonal use x-y"
      ],
      "used_in": [
        "5c2c9af4"
      ]
    },
    "create square border": {
      "name": "create square border",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "center",
          "typing": "position",
          "description": "the center position of the square border"
        },
        {
          "name": "half_width",
          "typing": "int",
          "description": "half the side length of the square border"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color of the border"
        }
      ],
      "description": "create a square border (frame) of a specified color centered at a given position, with a specified half-width",
      "cues": [
        "if output grid contains concentric square frames or borders centered on a point or object",
        "if there are repeated square outlines expanding from a central point",
        "if frames are always a fixed multiple of the object size (e.g., twice as large)"
      ],
      "implementation": [
        "create a grid with pixels set to the color on the four sides of the square defined by center and half_width",
        "compute the side length as twice the object's size (or another scale factor), center the frame on the object, and set the border pixels to the specified color"
      ],
      "used_in": [
        "5c2c9af4",
        "db93a21d"
      ]
    },
    "distance": {
      "name": "distance",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "position1",
          "typing": "position",
          "description": "first position"
        },
        {
          "name": "position2",
          "typing": "position",
          "description": "second position"
        }
      ],
      "description": "compute the distance between two positions, often used for spacing or measuring",
      "cues": [
        "if spacing or alignment between objects is important"
      ],
      "implementation": [
        "use Manhattan or Euclidean distance depending on context"
      ],
      "used_in": [
        "5c2c9af4"
      ]
    },
    "border fits within grid": {
      "name": "border fits within grid",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "border",
          "typing": "grid | object",
          "description": "the border object to check"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to check against"
        }
      ],
      "description": "check if a border (or any object) fits entirely within the boundaries of a grid",
      "cues": [
        "if you need to ensure that a drawn object does not exceed the grid dimensions"
      ],
      "implementation": [
        "check that all coordinates of the border are within the grid's shape"
      ],
      "used_in": [
        "5c2c9af4"
      ]
    },
    "border is redundant": {
      "name": "border is redundant",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "border",
          "typing": "grid | object",
          "description": "the border object to check"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to check against"
        }
      ],
      "description": "check if a border would not add any new colored pixels to the grid (i.e., is already present)",
      "cues": [
        "if repeated drawing of borders could result in no visible change"
      ],
      "implementation": [
        "compare the pixels of the border to the grid; if all are already set to the intended color, the border is redundant"
      ],
      "used_in": [
        "5c2c9af4"
      ]
    },
    "is symmetric": {
      "name": "is symmetric",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid or object to check for symmetry"
        },
        {
          "name": "axis",
          "typing": "axis := Literal[\"horizontal\", \"vertical\", \"both\", \"diagonal\", \"rotational\"]",
          "description": "the axis or type of symmetry to check for (can be a list of axes/types)"
        }
      ],
      "description": "check if a grid is symmetric (mirror symmetry) along a specified axis",
      "cues": [
        "if the output depends on whether the input grid is symmetric or not",
        "if the input grid appears unchanged or is referenced as a whole in the output logic",
        "if output grid contains only an object that is symmetric (mirror or rotational) and other objects are omitted",
        "if the solution logic selects objects based on their symmetry properties",
        "if the output grid is a cropped symmetric object from the input grid"
      ],
      "implementation": [
        "compare the grid or object to its reflection along the specified axis using np.flip or similar",
        "for rotational symmetry, check if the object is invariant under 90/180/270 degree rotation using np.rot90 or equivalent"
      ],
      "used_in": [
        "44f52bb0",
        "72ca375d"
      ]
    },
    "intersection of lines": {
      "name": "intersection of lines",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "the position(s) where two or more lines overlap, often marked with a special color or object",
      "cues": [
        "if output grid contains special markings or a distinct color at the crossing points of lines",
        "if lines of different colors cross and a third color appears at the intersection",
        "if lines cross at a single pixel, especially where a colored pixel exists in the input grid"
      ],
      "implementation": [
        "Detect line segments in the grid, then identify overlapping positions by checking for shared coordinates among lines",
        "Mark intersection points with a special color or object as specified by the transformation rule"
      ],
      "used_in": [
        "23581191",
        "623ea044"
      ]
    },
    "detect translational symmetry": {
      "name": "detect translational symmetry",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "symmetry := Callable[[position], position]",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to analyze for translational symmetry"
        },
        {
          "name": "ignore colors",
          "typing": "list[color]",
          "description": "colors to ignore when detecting symmetry (optional)"
        },
        {
          "name": "direction",
          "typing": "Literal[\"vertical\", \"horizontal\"]",
          "description": "the direction in which to detect translational symmetry (optional)"
        },
        {
          "name": "background",
          "typing": "color",
          "description": "background color to ignore (optional)"
        }
      ],
      "description": "detect the translational symmetry transformation(s) present in a grid, optionally ignoring specified colors",
      "cues": [
        "presence of a repeating pattern or objects along a specific direction in the grid",
        "output grid fills or reconstructs regions by repeating content from the input",
        "regions of the grid are missing but the rest exhibits a translationally repeating pattern"
      ],
      "implementation": [
        "compare shifted versions of the grid, excluding ignored colors, to identify translation vectors that map the pattern onto itself",
        "use cross-correlation or brute-force shifting and comparison to detect repeating units",
        "for vertical or horizontal symmetry, specifically check for repeating rows or columns or objects at regular intervals in the specified direction"
      ],
      "used_in": [
        "f9012d9b",
        "017c7c7b",
        "caa06a1f",
        "0dfd9992"
      ]
    },
    "orbit": {
      "name": "orbit",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[position]",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the starting position"
        },
        {
          "name": "symmetry",
          "typing": "symmetry := Callable[[position], position]",
          "description": "the symmetry transformation to apply (e.g., rotation)"
        },
        {
          "name": "order",
          "typing": "int",
          "description": "the number of symmetry operations (e.g., 4 for 90-degree rotational symmetry)"
        }
      ],
      "description": "compute the set of positions (the orbit) that a given position maps to under repeated application of a symmetry transformation",
      "cues": [
        "if filling in missing pixels by referencing symmetric positions in the grid",
        "if the output grid contains repeated copies of a pixel or object at positions related by symmetry",
        "if the solution logic involves mapping a pixel to all its symmetric counterparts"
      ],
      "implementation": [
        "repeatedly apply the symmetry transformation to the position, collecting all unique positions until a cycle is detected or for a fixed number of steps (order)",
        "for each i in 0 to order-1, apply the symmetry transformation i times to the starting position and collect the results (e.g., for rotational symmetry, rotate the position by i * angle around the center)"
      ],
      "used_in": [
        "f9012d9b",
        "11852cab"
      ]
    },
    "move position": {
      "name": "move position",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "position",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the starting position"
        },
        {
          "name": "direction",
          "typing": "direction := Literal[\"up\", \"down\", \"left\", \"right\"]",
          "description": "the direction to move"
        },
        {
          "name": "distance",
          "typing": "int",
          "description": "the number of steps to move in the given direction (optional, default 1)"
        }
      ],
      "description": "compute the new position by moving from the given position in the specified direction by a given distance",
      "cues": [
        "if pixels are placed at a fixed offset from a reference position, especially along diagonals",
        "if output grid contains features grown outward from a central pixel in diagonal directions",
        "if a process moves stepwise in a direction, possibly changing direction to avoid obstacles",
        "if output features are constructed by updating a position iteratively"
      ],
      "implementation": [
        "update the position coordinates according to the direction and distance (e.g., for \"up\", subtract from row index; for \"right\", add to column index)",
        "for each direction and distance, add the direction vector multiplied by the step to the starting position"
      ],
      "used_in": [
        "d06dbe63",
        "025d127b",
        "8d510a79",
        "25d487eb",
        "28e73c20",
        "f15e1fac",
        "0962bcdd",
        "d9f24cd1"
      ]
    },
    "create staircase pattern": {
      "name": "create staircase pattern",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "start",
          "typing": "position",
          "description": "the starting position of the staircase"
        },
        {
          "name": "directions",
          "typing": "tuple[direction, direction]",
          "description": "the two directions to alternate between (e.g., (\"up\", \"right\"))"
        },
        {
          "name": "step_size",
          "typing": "int",
          "description": "the length of each step in the staircase"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color of the staircase"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to draw the staircase on"
        }
      ],
      "description": "draw a staircase pattern by alternately drawing lines in two directions from a starting position, with a fixed step size and color",
      "cues": [
        "if output grid contains L-shaped or zigzag patterns extending from a point",
        "if lines in the output are arranged in a staircase or stepped pattern"
      ],
      "implementation": [
        "starting from the given position, alternately draw lines of the specified length in each direction, updating the position after each line"
      ],
      "used_in": [
        "d06dbe63"
      ]
    },
    "bounding box corners": {
      "name": "bounding box corners",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[position]",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object whose bounding box corners are to be found"
        }
      ],
      "description": "compute the four corner positions of the bounding box of an object",
      "cues": [
        "if lines or features in the output originate from the corners of objects",
        "if logic depends on or selects the color of a corner pixel of a cropped or bounded region or object"
      ],
      "implementation": [
        "find min and max x and y coordinates among the object's pixels to determine the four corners",
        "can be used to extract the color of a corner pixel for use in recoloring"
      ],
      "used_in": [
        "6e19193c",
        "3de23699"
      ]
    },
    "bounding box center": {
      "name": "bounding box center",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "position",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object whose bounding box center is to be found"
        }
      ],
      "description": "compute the center position of the bounding box of an object",
      "cues": [
        "if output features are aligned with the center of an object or its bounding box"
      ],
      "implementation": [
        "average the min and max x and y coordinates of the object's pixels"
      ],
      "used_in": [
        "6e19193c"
      ]
    },
    "mean position": {
      "name": "mean position",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "position",
      "parameters": [
        {
          "name": "pixels",
          "typing": "list[position]",
          "description": "the list of pixel positions to average"
        }
      ],
      "description": "compute the mean (average) position of a set of pixels, often used to summarize the \"center of mass\" of a region",
      "cues": [
        "if the solution needs to find the \"center\" or directionality of a non-rectangular object"
      ],
      "implementation": [
        "compute the average of x and y coordinates separately"
      ],
      "used_in": [
        "6e19193c"
      ]
    },
    "has mirror symmetry criteria": {
      "name": "has mirror symmetry criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to check for mirror symmetry"
        },
        {
          "name": "axes",
          "typing": "list[axis]",
          "description": "axes to check for symmetry"
        }
      ],
      "description": "condition on whether an object is symmetric across specified axes",
      "cues": [
        "if some objects in the grid are symmetric and others are not",
        "if the output grid contains reflected versions of an object"
      ],
      "implementation": [
        "compare the object to its reflection along the specified axes using np.flip or similar"
      ],
      "used_in": [
        "4c5c2cf0"
      ]
    },
    "detect mirror symmetry": {
      "name": "detect mirror symmetry",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[axis]",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to analyze for mirror symmetry"
        },
        {
          "name": "ignore colors",
          "typing": "list[color]",
          "description": "colors to ignore when checking for symmetry"
        },
        {
          "name": "background",
          "typing": "color",
          "description": "background color to ignore"
        }
      ],
      "description": "detect which axes (horizontal, vertical, both) an object is symmetric across",
      "cues": [
        "if you need to determine the axes of symmetry for an object",
        "if output grid contains reflected versions of an object"
      ],
      "implementation": [
        "for each axis, compare the object to its reflection along that axis, ignoring specified colors"
      ],
      "used_in": [
        "4c5c2cf0"
      ]
    },
    "reflect pixel across axes": {
      "name": "reflect pixel across axes",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "list[position]",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the pixel position to reflect"
        },
        {
          "name": "axes",
          "typing": "list[axis]",
          "description": "axes to reflect across (e.g., [\"vertical\"])"
        },
        {
          "name": "center",
          "typing": "position",
          "description": "the center of symmetry to reflect about"
        }
      ],
      "description": "compute all positions obtained by reflecting a pixel across the specified axes through a given center",
      "cues": [
        "if output grid contains reflected copies of an object or pixel, especially around the center of a symmetric object",
        "if the output grid restores symmetry by mirroring pixels across an axis",
        "if pixels in the output grid appear in symmetric positions relative to an axis"
      ],
      "implementation": [
        "for each axis, compute the reflected position with respect to the center; for multiple axes, produce all combinations"
      ],
      "used_in": [
        "4c5c2cf0",
        "3345333e"
      ]
    },
    "shift pixel within object": {
      "name": "shift pixel within object",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "object",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object whose pixels are to be shifted"
        },
        {
          "name": "direction",
          "typing": "direction := Literal[\"up\", \"down\", \"left\", \"right\", \"up-right\", \"up-left\", \"down-right\", \"down-left\"]",
          "description": "the direction in which to shift pixels (e.g., \"right\")"
        },
        {
          "name": "shift condition",
          "typing": "shift condition := Callable[[position, object], bool]",
          "description": "logic to determine if a pixel should be shifted"
        }
      ],
      "description": "shift pixels within an object in a specified direction if a condition is met for each pixel",
      "cues": [
        "if the output grid shows objects with pixels shifted in a consistent direction, but not all pixels are shifted",
        "if the shape of objects is preserved except for a directional \"slide\" or \"smear\" of pixels",
        "if the shifting of pixels depends on the presence or absence of other pixels in a specific direction"
      ],
      "implementation": [
        "for each pixel in the object, check the shift condition; if true, move the pixel in the specified direction",
        "ensure that shifting does not overwrite other pixels unless intended",
        "can be implemented by creating a new pixel set for the object based on the condition"
      ],
      "used_in": [
        "025d127b"
      ]
    },
    "pixel has neighbor in direction criteria": {
      "name": "pixel has neighbor in direction criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the pixel position to check from"
        },
        {
          "name": "object",
          "typing": "object",
          "description": "the object containing the pixels"
        },
        {
          "name": "direction",
          "typing": "direction",
          "description": "the direction to check for a neighbor (e.g., \"down-right\")"
        }
      ],
      "description": "condition on whether a pixel has another object pixel in a specified direction",
      "cues": [
        "if pixel-level movement or transformation depends on the presence of other pixels in a direction"
      ],
      "implementation": [
        "for the given position, check if there exists another pixel in the object at position offset by the direction"
      ],
      "used_in": [
        "025d127b"
      ]
    },
    "draw objects": {
      "name": "draw objects",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "objects",
          "typing": "list[object]",
          "description": "the list of objects to draw"
        },
        {
          "name": "base",
          "typing": "grid",
          "description": "the grid to draw the objects onto"
        },
        {
          "name": "positions",
          "typing": "list[position]",
          "description": "the positions to place each object"
        },
        {
          "name": "bounding_box_only",
          "typing": "bool",
          "description": "if True, only draw the minimal bounding rectangle containing all objects"
        }
      ],
      "description": "draw a list of objects onto a base grid, overlaying each object's pixels at their respective positions",
      "cues": [
        "if multiple objects are drawn onto a blank or new grid in the output",
        "if the output grid is constructed by overlaying recolored or transformed objects",
        "if the output grid is a minimal bounding rectangle containing all objects, with no empty space"
      ],
      "implementation": [
        "for each object, draw its pixels onto the base grid at its position, possibly using the draw object routine",
        "if bounding_box_only is True, crop the output to the minimal rectangle containing all objects"
      ],
      "used_in": [
        "d2abd087",
        "681b3aeb"
      ]
    },
    "closest to criteria": {
      "name": "closest to criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to test"
        },
        {
          "name": "reference",
          "typing": "object",
          "description": "the object to measure distance from"
        }
      ],
      "description": "condition on whether a candidate object is the closest to a reference object among a set",
      "cues": [
        "if each object is paired with its nearest neighbor of a certain type (e.g., frame, anchor)",
        "if the output depends on spatial proximity between objects"
      ],
      "implementation": [
        "compute the distance between the candidate and the reference, and select the minimum among all candidates"
      ],
      "used_in": [
        "6855a6e4"
      ]
    },
    "get mirror axis": {
      "name": "get mirror axis",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int | float",
      "parameters": [
        {
          "name": "frame",
          "typing": "object",
          "description": "the frame object to reflect across"
        },
        {
          "name": "object",
          "typing": "object",
          "description": "the primary object to be mirrored"
        },
        {
          "name": "orientation",
          "typing": "Literal[\"horizontal\", \"vertical\"]",
          "description": "the axis along which to reflect"
        },
        {
          "name": "reference",
          "typing": "object",
          "description": "the indicator or reference object to determine the mirror axis relative to"
        }
      ],
      "description": "compute the coordinate of the mirror axis (line of symmetry) for reflection, based on the frame and the object's position",
      "cues": [
        "If the reflection axis is not fixed but depends on the spatial relationship between objects, such as when reflection is determined by the position of another object or pixel.",
        "If mirrored objects appear adjacent to indicator pixels in the output grid.",
        "If the mirror axis must be computed dynamically for each object-frame pair, especially when reflection is not always across the frame center but depends on which side the object is on."
      ],
      "implementation": [
        "For vertical or horizontal orientation, determine the mirror axis coordinate (row or column) based on the object's position relative to the frame or indicator; this may be just beyond the object's edge closest to the indicator or relative to the frame's center.",
        "Compare the object's position to the frame's center or to the indicator's position to determine the correct side and select the appropriate axis and coordinate for reflection."
      ],
      "used_in": [
        "6855a6e4",
        "b775ac94"
      ]
    },
    "has hole criteria": {
      "name": "has hole criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to check for holes"
        }
      ],
      "description": "condition on whether an object contains at least one hole (i.e., has empty space inside)",
      "cues": [
        "if output grid recolors only objects with cavities or internal empty space",
        "if some objects are visually hollow and are treated differently in the output",
        "if \"get object holes\" is used and the result is non-empty"
      ],
      "implementation": [
        "use \"get object holes\" and check if the returned list is non-empty"
      ],
      "used_in": [
        "810b9b61"
      ]
    },
    "count pixels": {
      "name": "count pixels",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object or region to count pixels in"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color to count pixels of (optional, if not specified, count all non-background pixels)"
        },
        {
          "name": "color | criteria",
          "typing": "color | Callable[[color], bool]",
          "description": "color or predicate to select which pixels to count"
        }
      ],
      "description": "count the number of pixels of a specific color within an object",
      "cues": [
        "if objects or regions are selected, sorted, or processed based on the number of pixels of a certain color or their area (number of colored pixels)"
      ],
      "implementation": [
        "count the number of pixels in the object's mask or region that match the specified color or satisfy the given criteria; for regions, count pixels not equal to the background or divider color; can use np.sum or boolean masks for implementation"
      ],
      "used_in": [
        "97a05b5b",
        "29623171",
        "6e82a1ae",
        "1190e5a7",
        "e48d4e1a",
        "09629e4f",
        "57aa92db"
      ]
    },
    "all positions": {
      "name": "all positions",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[position]",
      "parameters": [
        {
          "name": "container",
          "typing": "object",
          "description": "the object or grid in which to place another object"
        },
        {
          "name": "object",
          "typing": "object",
          "description": "the object to be placed"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid whose positions to enumerate"
        }
      ],
      "description": "generate all possible positions where an object can be placed within a container such that it fits entirely inside",
      "cues": [
        "if the solution tries all possible placements of an object within a region",
        "if the output grid is constructed by fitting pieces into a container",
        "if logic iterates over every pixel in a grid"
      ],
      "implementation": [
        "slide the object's bounding box over all positions where it remains within the container's bounding box, typically using nested loops over the grid's shape to yield all (row, col) positions"
      ],
      "used_in": [
        "97a05b5b",
        "1b2d62fb",
        "6a1e5592",
        "0520fde7"
      ]
    },
    "red pixels": {
      "name": "red pixels",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[position]",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to extract red pixel positions from"
        },
        {
          "name": "offset",
          "typing": "position",
          "description": "offset to add to each pixel position (optional)"
        }
      ],
      "description": "extract the positions of all red pixels in an object, optionally offset by a given position",
      "cues": [
        "if alignment or matching is based on the positions of pixels of a specific color"
      ],
      "implementation": [
        "for each pixel in the object, if its color is red, include its position plus offset"
      ],
      "used_in": [
        "97a05b5b"
      ]
    },
    "find farthest border pixel": {
      "name": "find farthest border pixel",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "position",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object whose border pixel is to be found"
        },
        {
          "name": "reference_object",
          "typing": "object",
          "description": "the object to measure distance from"
        }
      ],
      "description": "find the border pixel of the object that is farthest from the reference object, often used to identify tips or extremities.",
      "cues": [
        "if lines are drawn from the tip or extremity of an object towards or away from another object",
        "if the output grid features lines or marks originating from a \"corner\" or \"tip\" of an input object"
      ],
      "implementation": [
        "for each border pixel of the object, compute the distance to the reference object (e.g., to its pixels or bounding box) and select the one with the maximum distance"
      ],
      "used_in": [
        "a78176bb"
      ]
    },
    "get diagonal direction": {
      "name": "get diagonal direction",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "direction := Literal[\"up-right\", \"down-right\", \"up-left\", \"down-left\"]",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object whose orientation is to be determined"
        }
      ],
      "description": "determine the diagonal direction (e.g., up-right or down-right) of an object, often used to guide line drawing or pattern extension",
      "cues": [
        "if an object in the input grid is a diagonal line and its orientation determines the direction of new lines in the output",
        "if output lines follow the same diagonal as an input object"
      ],
      "implementation": [
        "analyze the object's pixel positions to determine which diagonal direction it spans (e.g., by comparing row and column increments)"
      ],
      "used_in": [
        "a78176bb"
      ]
    },
    "reverse direction": {
      "name": "reverse direction",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "direction",
      "parameters": [
        {
          "name": "direction",
          "typing": "direction := Literal[\"up-right\", \"down-right\", \"up-left\", \"down-left\", \"up\", \"down\", \"left\", \"right\"]",
          "description": "the direction to reverse"
        }
      ],
      "description": "compute the opposite of a given direction (e.g., reverse(\"down-right\") -> \"up-left\")",
      "cues": [
        "if lines or objects are drawn in both a direction and its opposite from a point",
        "if lines or objects change direction at the edge of the grid or upon collision with a wall",
        "if a \"bouncing\" or reflection effect is observed in the output grid"
      ],
      "implementation": [
        "map each direction to its reverse (e.g., \"up-right\" <-> \"down-left\", \"up\" <-> \"down\", \"left\" <-> \"right\")",
        "reverse the x component for horizontal bounces and the y component for vertical bounces"
      ],
      "used_in": [
        "a78176bb",
        "e179c5f4",
        "56dc2b01"
      ]
    },
    "bar": {
      "name": "bar",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "an object that spans the full width or height of the grid, often serving as a target or anchor for other objects",
      "cues": [
        "if the grid contains objects that are as wide or as tall as the grid itself",
        "if output pixels are aligned with or stop at such objects",
        "if the output grid consists of colored rectangles or lines spanning the grid"
      ],
      "implementation": null,
      "used_in": [
        "1a07d186",
        "56dc2b01",
        "08ed6ac7",
        "178fcbfb",
        "0a938d79"
      ]
    },
    "pixel object": {
      "name": "pixel object",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "an object consisting of a single pixel, often treated as a movable or target entity",
      "cues": [
        "presence of isolated single pixels in the input grid that are moved or removed in the output",
        "output grid is a single pixel (1x1), possibly with its color encoding a result"
      ],
      "implementation": [
        "represent as a tuple of (row, column, color) or as a mask identifying single non-background pixels",
        "detect by scanning for grid positions where a non-background color is surrounded by background pixels"
      ],
      "used_in": [
        "1a07d186",
        "29c11459",
        "8d510a79",
        "239be575",
        "a9f96cdd",
        "e8dc4411",
        "0a938d79",
        "1f642eb9"
      ]
    },
    "delete object": {
      "name": "delete object",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object or pixel to delete from the grid"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to delete the object from"
        }
      ],
      "description": "remove an object from the grid, leaving background color in its place",
      "cues": [
        "if some input objects or pixels disappear in the output grid"
      ],
      "implementation": [
        "set the object's pixels in the grid to the background color (usually 0)"
      ],
      "used_in": [
        "1a07d186"
      ]
    },
    "region size": {
      "name": "region size",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "region",
          "typing": "grid",
          "description": "the region whose size (area) is to be computed"
        }
      ],
      "description": "compute the area (number of pixels) of a region",
      "cues": [
        "if regions are recolored or selected based on their size or area",
        "if the output grid treats the largest or smallest regions differently"
      ],
      "implementation": [
        "count the number of non-background pixels in the region, e.g., using np.sum(region != background_color)"
      ],
      "used_in": [
        "6455b5f5",
        "239be575"
      ]
    },
    "pixel is inside grid criteria": {
      "name": "pixel is inside grid criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the pixel position to check"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to check against"
        }
      ],
      "description": "check if a pixel position is within the bounds of the grid",
      "cues": [
        "if an iterative process (e.g., line drawing or movement) stops when reaching the grid edge",
        "if logic depends on whether a pixel is still inside the grid"
      ],
      "implementation": [
        "check that 0 <= x < grid width and 0 <= y < grid height"
      ],
      "used_in": [
        "e179c5f4"
      ]
    },
    "center": {
      "name": "center",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "position",
      "parameters": [
        {
          "name": "object",
          "typing": "object | grid",
          "description": "the object or grid whose center is to be found"
        },
        {
          "name": "color",
          "typing": "color | Callable[[color], bool]",
          "description": "restrict to pixels of this color or color predicate (optional)"
        }
      ],
      "description": "compute the center position of an object, optionally restricted to pixels of a specified color or color predicate",
      "cues": [
        "if the solution needs to find the \"center\" or \"center of mass\" of a colored region, object, or grid",
        "if movement or direction is determined from the center of one region to another within the same object",
        "if objects are aligned or overlaid at the center of a grid or another object"
      ],
      "implementation": [
        "if color is specified, only consider pixels matching the color (or those selected by the predicate)",
        "compute the center by averaging the x and y coordinates of the selected pixels (center of mass)"
      ],
      "used_in": [
        "a8c38be5",
        "54d82841",
        "aba27056",
        "41e4d17e",
        "0962bcdd",
        "137eaa0f"
      ]
    },
    "slide from center": {
      "name": "slide from center",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "position",
      "parameters": [
        {
          "name": "direction",
          "typing": "direction",
          "description": "the direction to slide in"
        },
        {
          "name": "grid_size",
          "typing": "dimensions := tuple[int, int]",
          "description": "the size of the grid to slide within"
        },
        {
          "name": "object_size",
          "typing": "dimensions := tuple[int, int]",
          "description": "the size of the object being placed"
        }
      ],
      "description": "compute the position to place an object by starting at the center of the grid and sliding in the given direction until the object reaches the grid edge",
      "cues": [
        "if objects are placed at the edge of a grid, aligned along a direction from the center",
        "if output objects are always at maximal extent in a direction from the center"
      ],
      "implementation": [
        "start from the grid center, move stepwise in the direction until the object would exceed the grid bounds if moved further",
        "ensure that the object's bounding box remains within the grid at the final position"
      ],
      "used_in": [
        "a8c38be5"
      ]
    },
    "has shape criteria": {
      "name": "has shape criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to check"
        },
        {
          "name": "shape",
          "typing": "dimensions := tuple[int, int]",
          "description": "the shape to match"
        }
      ],
      "description": "condition on whether an object has the specified shape (height, width)",
      "cues": [
        "if only objects of a specific size are selected for further processing"
      ],
      "implementation": [
        "compare the object's bounding box dimensions to the given shape"
      ],
      "used_in": [
        "a8c38be5",
        "150deff5"
      ]
    },
    "contains color criteria": {
      "name": "contains color criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to check"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color to check for"
        }
      ],
      "description": "condition on whether an object contains at least one pixel of the specified color",
      "cues": [
        "if only objects containing a certain color are selected"
      ],
      "implementation": [
        "check if the object's color set contains the specified color"
      ],
      "used_in": [
        "a8c38be5"
      ]
    },
    "is blank criteria": {
      "name": "is blank criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to check"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color considered as blank (background)"
        }
      ],
      "description": "condition on whether an object is blank (i.e., contains only the specified color)",
      "cues": [
        "if blank or empty objects are filtered out from further processing"
      ],
      "implementation": [
        "check if all pixels in the object are equal to the specified color"
      ],
      "used_in": [
        "a8c38be5"
      ]
    },
    "fill region": {
      "name": "fill region",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "region",
          "typing": "grid | object",
          "description": "the region or grid to fill"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color to fill with"
        },
        {
          "name": "region | grid | object",
          "typing": "grid | object",
          "description": "the region or grid to fill"
        }
      ],
      "description": "fill all pixels in a region or object with a specified color",
      "cues": [
        "if regions, rows, or bars in the output grid are uniformly filled with a single color",
        "if the output grid shows regions recolored based on a property (e.g., size, count, or position)",
        "if a bar, region, or path is extended and filled with a color in the output grid",
        "if output grid shows new colored pixels extending from a base pixel, object, or along a sequence (path/trail)",
        "if the output grid is initialized as blank and then filled with colored pixels based on a count or property"
      ],
      "implementation": [
        "set all pixels in the specified region, row, or path to the given color, optionally using array assignment or masking",
        "for each position along the intended region or path, set the pixel to the specified color if it matches a condition (e.g., is background), possibly using a loop until a stopping condition is met",
        "set the first N pixels (in a specified order, e.g., left-to-right, top-to-bottom) to the color, where N is determined by a count or property"
      ],
      "used_in": [
        "29623171",
        "25d487eb",
        "941d9a10",
        "bd4472b8",
        "28e73c20",
        "1fad071e",
        "af902bf9",
        "aba27056"
      ]
    },
    "combine regions": {
      "name": "combine regions",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "regions",
          "typing": "list[grid]",
          "description": "the list of regions to combine into a single grid"
        }
      ],
      "description": "compose a list of regions back into a single grid, placing each region in its original position",
      "cues": [
        "if the grid is split into regions for processing and then reconstructed"
      ],
      "implementation": [
        "create a blank grid and copy each region into its corresponding position"
      ],
      "used_in": [
        "29623171"
      ]
    },
    "not_in criteria": {
      "name": "not_in criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "color",
          "typing": "color",
          "description": "the color to check"
        },
        {
          "name": "exclude",
          "typing": "list[color]",
          "description": "colors to exclude"
        }
      ],
      "description": "condition on whether a pixel's color is not in a list of excluded colors",
      "cues": [
        "if pixel counting or selection ignores certain colors (e.g., background or divider)",
        "if the logic applies to all colors except a specific set (e.g., black and teal, or black and line colors)"
      ],
      "implementation": [
        "return True if color not in exclude"
      ],
      "used_in": [
        "29623171",
        "10fcaaa3",
        "6b9890af",
        "09629e4f",
        "5daaa586"
      ]
    },
    "is opposite edge criteria": {
      "name": "is opposite edge criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to check for being on the opposite edge"
        },
        {
          "name": "reference",
          "typing": "object",
          "description": "the reference object to compare against"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to check edge positions within"
        }
      ],
      "description": "condition on whether a target pixel object is on the edge opposite to a reference pixel object, in the same row or column",
      "cues": [
        "if colored pixels on one edge are paired with colored pixels on the opposite edge in the output",
        "if output features connect edge pixels across the grid"
      ],
      "implementation": [
        "for a given pixel on an edge, check for another pixel with the same row or column but on the opposite edge of the grid"
      ],
      "used_in": [
        "29c11459"
      ]
    },
    "interpolate paths": {
      "name": "interpolate paths",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "tuple[list[position], list[position]]",
      "parameters": [
        {
          "name": "start",
          "typing": "position",
          "description": "the starting position of the first path"
        },
        {
          "name": "end",
          "typing": "position",
          "description": "the ending position of the second path"
        }
      ],
      "description": "compute the sequences of positions forming straight paths from two endpoints toward each other, meeting in the middle",
      "cues": [
        "if output grid contains colored trails or lines connecting pairs of edge pixels, meeting at a central point",
        "if two objects or pixels are connected by a path that meets in the middle"
      ],
      "implementation": [
        "for pixels aligned in the same row or column, generate the list of positions from each endpoint toward the other",
        "for each step, advance positions toward each other until they meet or cross"
      ],
      "used_in": [
        "29c11459"
      ]
    },
    "pathfinding with custom movement rules": {
      "name": "pathfinding with custom movement rules",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "list[position]",
      "parameters": [
        {
          "name": "initial_states",
          "typing": "list[tuple[position, direction]]",
          "description": "list of starting positions and movement directions"
        },
        {
          "name": "goal_criteria",
          "typing": "Callable[[tuple[position, direction]], bool]",
          "description": "function to determine if a state is a goal"
        },
        {
          "name": "successor_fn",
          "typing": "Callable[[tuple[position, direction]], list[tuple[position, direction]]]",
          "description": "function to generate successor states given current state"
        }
      ],
      "description": "find a path from a set of initial states to a goal state, expanding successors according to custom movement rules",
      "cues": [
        "output grid contains a path or trail connecting two objects or regions, especially with turns only at specific pixels",
        "movement is constrained by barriers or only allowed to turn at special markers",
        "path is colored in the output grid following a specific rule set",
        "process moves stepwise, changing direction only when blocked, and fills a path or region in the output grid"
      ],
      "implementation": [
        "use BFS or DFS to explore possible states, expanding successors according to the movement rules",
        "maintain visited states to avoid cycles",
        "return the sequence of positions forming the path once a goal is reached"
      ],
      "used_in": [
        "2dd70a9a",
        "28e73c20"
      ]
    },
    "custom successors": {
      "name": "custom successors",
      "kind": "routine",
      "routine_subtype": "Callable[[tuple[position, direction]], list[tuple[position, direction]]]",
      "output_typing": "list[tuple[position, direction]]",
      "parameters": [
        {
          "name": "barriers",
          "typing": "list[object]",
          "description": "objects that block movement or allow turning"
        },
        {
          "name": "turn_only_on_contact",
          "typing": "bool",
          "description": "if True, only allow direction changes when contacting a barrier"
        }
      ],
      "description": "generate possible successor states for pathfinding, allowing movement in the current direction unless blocked, and only allowing turns at specified pixels (e.g., teal)",
      "cues": [
        "if movement in the grid is only allowed to turn at certain colored pixels",
        "if movement is blocked by specific objects or colors"
      ],
      "implementation": [
        "for a given state (position, direction), check if the next position in the current direction is blocked by a barrier",
        "if not blocked, allow moving forward",
        "if at a barrier and turn_only_on_contact is True, allow right-angle turns to other directions not blocked by a barrier"
      ],
      "used_in": [
        "2dd70a9a"
      ]
    },
    "is adjacent criteria": {
      "name": "is adjacent criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the position to check adjacency for"
        },
        {
          "name": "object",
          "typing": "object",
          "description": "the object to check adjacency against"
        }
      ],
      "description": "check if a given position is adjacent (4-connected) to any pixel in the specified object",
      "cues": [
        "if the goal of a pathfinding or movement process is to reach a position next to an object",
        "if output features stop at the edge of a target object"
      ],
      "implementation": [
        "for the given position, check if any of the four neighboring positions are in the object's pixel set"
      ],
      "used_in": [
        "2dd70a9a"
      ]
    },
    "pyramid of lines": {
      "name": "pyramid of lines",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "a visual pattern where lines of alternating colors and decreasing lengths are arranged symmetrically around a central axis, forming a pyramid or triangle shape",
      "cues": [
        "if output grid contains a central line with shorter lines extending to both sides, forming a triangle or pyramid shape",
        "if the lengths of lines decrease by one as they move away from the center",
        "if colors alternate between two values in the pattern"
      ],
      "implementation": [],
      "used_in": [
        "db3e9e38"
      ]
    },
    "alternating color pattern": {
      "name": "alternating color pattern",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[color]",
      "parameters": [
        {
          "name": "colors",
          "typing": "list[color]",
          "description": "the list of colors to alternate between"
        },
        {
          "name": "length",
          "typing": "int",
          "description": "the number of elements in the pattern"
        }
      ],
      "description": "generate a sequence of colors by alternating between the provided colors for the specified length",
      "cues": [
        "if output grid contains repeated patterns with alternating colors (e.g., orange, teal, orange, teal)",
        "if lines or objects are colored in an alternating sequence"
      ],
      "implementation": [
        "cycle through the colors list, repeating as necessary to reach the desired length"
      ],
      "used_in": [
        "db3e9e38"
      ]
    },
    "decrementing length pattern": {
      "name": "decrementing length pattern",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[int]",
      "parameters": [
        {
          "name": "start_length",
          "typing": "int",
          "description": "the initial length of the pattern"
        },
        {
          "name": "count",
          "typing": "int",
          "description": "number of steps to decrement"
        }
      ],
      "description": "generate a sequence of decreasing integers starting from start_length, decrementing by 1 each time",
      "cues": [
        "if output grid contains lines or objects whose sizes decrease in a regular fashion away from a central axis",
        "if a pyramid or triangle shape is formed by stacking shorter lines next to longer ones"
      ],
      "implementation": [
        "create a list [start_length - i for i in range(count)] or similar"
      ],
      "used_in": [
        "db3e9e38"
      ]
    },
    "concatenate grids": {
      "name": "concatenate grids",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "grids",
          "typing": "list[grid]",
          "description": "the list of grids to concatenate"
        },
        {
          "name": "axis",
          "typing": "axis := Literal[\"horizontal\", \"vertical\"]",
          "description": "the axis along which to concatenate the grids"
        }
      ],
      "description": "concatenate multiple grids along the specified axis to form a single larger grid",
      "cues": [
        "if the output grid contains the input grid repeated or mirrored side by side or stacked",
        "if the output grid is larger than the input grid and appears to be a combination of multiple grids"
      ],
      "implementation": [
        "use numpy.concatenate or similar to join the grids along the specified axis"
      ],
      "used_in": [
        "6fa7a44f"
      ]
    },
    "is line criteria": {
      "name": "is line criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to check"
        },
        {
          "name": "orientation",
          "typing": "Literal[\"horizontal\", \"vertical\"]",
          "description": "the orientation to check for (optional; if not specified, any line)"
        }
      ],
      "description": "condition on whether an object is a line (i.e., height 1 or width 1), optionally with a specified orientation",
      "cues": [
        "presence of objects in the grid that are a single row or column in extent",
        "output lines are aligned with or terminate at such single-row or single-column objects"
      ],
      "implementation": [
        "determine if the object's height is 1 (for horizontal) or width is 1 (for vertical)",
        "if orientation is specified, check only the corresponding dimension; otherwise, check if either dimension is 1"
      ],
      "used_in": [
        "8d510a79",
        "5daaa586"
      ]
    },
    "is in bounds": {
      "name": "is in bounds",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the position to check"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to check against"
        }
      ],
      "description": "check if a given position is within the valid bounds of the grid",
      "cues": [
        "if a process (e.g., line drawing or movement) stops at the grid edge",
        "if logic must avoid out-of-bounds errors when updating grid pixels"
      ],
      "implementation": [
        "check that 0 <= x < grid width and 0 <= y < grid height"
      ],
      "used_in": [
        "25d487eb"
      ]
    },
    "get neighbor pixel": {
      "name": "get neighbor pixel",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "object | position",
      "parameters": [
        {
          "name": "pixel",
          "typing": "object | position",
          "description": "the pixel or position whose neighbor is to be found"
        },
        {
          "name": "direction",
          "typing": "direction := Literal[\"up\", \"down\", \"left\", \"right\", \"up-right\", \"up-left\", \"down-right\", \"down-left\"]",
          "description": "the direction in which to find the neighbor"
        }
      ],
      "description": "get the neighboring pixel or position in a specified direction",
      "cues": [
        "if logic needs to check adjacency or expand from a pixel in a direction"
      ],
      "implementation": [
        "add the direction offset to the pixel's coordinates"
      ],
      "used_in": [
        "25d487eb",
        "0ca9ddb6"
      ]
    },
    "is inside object": {
      "name": "is inside object",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the pixel position to check"
        },
        {
          "name": "object",
          "typing": "object",
          "description": "the object to check containment within"
        }
      ],
      "description": "check if a given position is inside the specified object",
      "cues": [
        "if logic depends on whether a pixel is part of an object or not",
        "if movement or extension is blocked by an object's boundary"
      ],
      "implementation": [
        "check if the position is in the object's pixel set or mask"
      ],
      "used_in": [
        "25d487eb",
        "aba27056",
        "d4f3cd78"
      ]
    },
    "opposite direction": {
      "name": "opposite direction",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "direction",
      "parameters": [
        {
          "name": "direction",
          "typing": "direction := Literal[\"up\", \"down\", \"left\", \"right\", \"up-right\", \"up-left\", \"down-right\", \"down-left\"]",
          "description": "the direction to reverse"
        }
      ],
      "description": "compute the opposite of a given direction (e.g., \"up\" <-> \"down\")",
      "cues": [
        "if an operation needs to extend or move away from a reference point or object",
        "if movement or drawing is performed in the direction opposite to a detected neighbor or boundary"
      ],
      "implementation": [
        "map each direction to its opposite (e.g., \"up\" <-> \"down\", \"left\" <-> \"right\", etc.)"
      ],
      "used_in": [
        "25d487eb"
      ]
    },
    "select every nth element": {
      "name": "select every nth element",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[Any]",
      "parameters": [
        {
          "name": "sequence",
          "typing": "list[Any]",
          "description": "the sequence to select from (e.g., range of columns)"
        },
        {
          "name": "n",
          "typing": "int",
          "description": "the step size (e.g., 2 for every second element)"
        },
        {
          "name": "offset",
          "typing": "int",
          "description": "starting offset (default 0; 0 means start from the first element)"
        }
      ],
      "description": "select every nth element from a sequence, optionally starting at a given offset",
      "cues": [
        "if the output grid is affected only for every nth region/object in a spatial or ordered list",
        "if output features (e.g., lines or objects) are repeated at regular intervals (e.g., every second or third column)",
        "if a pattern is applied periodically across a row or column"
      ],
      "implementation": [
        {
          "use Python slicing": "sequence[offset::n]"
        }
      ],
      "used_in": [
        "7447852a",
        "834ec97d",
        "05269061"
      ]
    },
    "is between objects": {
      "name": "is between objects",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the pixel position to check"
        },
        {
          "name": "object1",
          "typing": "object",
          "description": "the first object to check between"
        },
        {
          "name": "object2",
          "typing": "object",
          "description": "the second object to check between"
        },
        {
          "name": "padding",
          "typing": "int",
          "description": "number of pixels to pad around the objects when considering \"between\" (optional, default 0)"
        }
      ],
      "description": "check if a given position lies spatially between two objects, possibly with a specified padding from each object",
      "cues": [
        "if output grid contains a filled path or region connecting two objects, especially if the fill only occurs between them",
        "if black/background pixels between two objects are colored in the output",
        "if two objects are connected by a straight or minimal-width region in the output"
      ],
      "implementation": [
        "compute the bounding boxes of both objects, and check if the position lies within the rectangle defined by their outermost edges (plus padding)",
        "for axis-aligned rectangles, check if the position's coordinates are between the min and max x/y of the two objects (with padding)",
        "can generalize to checking if a position is on the minimal path or region connecting the two objects"
      ],
      "used_in": [
        "d6ad076f"
      ]
    },
    "square object": {
      "name": "square object",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "an object whose height and width are equal; often used as a unit for expansion, framing, or patterning",
      "cues": [
        "if the grid contains objects that are perfect squares (equal height and width)",
        "if the output grid treats square-shaped objects differently, such as centering frames or expansions on them",
        "if the output grid is composed of concentric or nested square regions",
        "if the output grid is a square whose size is determined by properties of the input grid (e.g., width, color count)",
        "if the output grid is composed of repeated or stacked copies of an input object, filling a square region"
      ],
      "implementation": [],
      "used_in": [
        "db93a21d",
        "3befdf3e",
        "eb5a1d5d",
        "feca6190",
        "44d8ac46"
      ]
    },
    "frame size proportional to object": {
      "name": "frame size proportional to object",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to base the frame size on"
        },
        {
          "name": "scale",
          "typing": "float | int",
          "description": "the scaling factor to apply to the object's size (e.g., 2 for twice the size)"
        }
      ],
      "description": "compute the size of a frame or border as a multiple of the object's size, often used for centering or expansion",
      "cues": [
        "if output frames or borders are always a fixed multiple of the input object's size",
        "if frames are always centered on the object and their size is proportional to the object"
      ],
      "implementation": [
        "use max(object.width, object.height) * scale to determine the frame size"
      ],
      "used_in": [
        "db93a21d"
      ]
    },
    "find color": {
      "name": "find color",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "color",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to search for a color in"
        },
        {
          "name": "criteria",
          "typing": "selection criteria := Callable[[color], bool]",
          "description": "logic to determine if a color satisfies the condition"
        }
      ],
      "description": "find a color in the grid that matches a given criteria, such as being the only color in a row or column, or not equal to another color",
      "cues": [
        "if the solution requires identifying a special color used for bars, dividers, frames, or background",
        "if the grid contains rows or columns that are all the same color",
        "if a color appears in lines that separate or partition regions in the grid",
        "if the output grid uses a color from the input grid that is not the bar, divider, or background color",
        "if a color appears exactly once in the input grid and is highlighted, bordered, or framed in the output",
        "if output features are colored to match scattered pixels inside a frame or rectangle"
      ],
      "implementation": [
        "for each unique color in the grid, check if it satisfies the provided criteria function",
        "to find a bar or divider color, check for any row or column where all pixels are equal and use that color",
        "to find a background color, select any color in the grid that is not the bar or divider color",
        "to identify a color used for uninterrupted lines, check if a color forms continuous rows or columns"
      ],
      "used_in": [
        "1190e5a7",
        "1e32b0e9",
        "09629e4f",
        "5daaa586",
        "31aa019c",
        "57aa92db"
      ]
    },
    "all pixels equal in row or column criteria": {
      "name": "all pixels equal in row or column criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "color",
          "typing": "color",
          "description": "the color to check for uniformity"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to check within"
        }
      ],
      "description": "condition on whether all pixels in any row or column are equal to the specified color",
      "cues": [
        "if a row or column in the grid is visually a solid color, possibly indicating a divider or bar",
        "if the solution logic depends on identifying a color that forms uninterrupted lines across the grid"
      ],
      "implementation": [
        "for each row and column, check if all values are equal to the color"
      ],
      "used_in": [
        "1190e5a7"
      ]
    },
    "not equal criteria": {
      "name": "not equal criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "color",
          "typing": "color",
          "description": "the color to check"
        },
        {
          "name": "excluded_color",
          "typing": "color",
          "description": "the color to exclude"
        }
      ],
      "description": "condition on whether a color is not equal to a specified excluded color",
      "cues": [
        "if the solution must select a color from the grid that is not a special color (e.g., bar or divider)"
      ],
      "implementation": [
        "return True if color != excluded_color"
      ],
      "used_in": [
        "1190e5a7"
      ]
    },
    "diagonal neighbors": {
      "name": "diagonal neighbors",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[object] | list[position]",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the position whose diagonal neighbors are to be found"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to check for neighbors in"
        }
      ],
      "description": "get the neighboring pixels in all four diagonal directions from a given position",
      "cues": [
        "if the output grid contains changes to pixels that are diagonally adjacent to colored pixels",
        "if diagonal adjacency is relevant for coloring, movement, or pattern extension",
        "if output features or patterns extend from a pixel to its diagonally adjacent positions"
      ],
      "implementation": [
        "for a given (x, y), diagonal neighbors are at (x-1, y-1), (x-1, y+1), (x+1, y-1), (x+1, y+1)",
        "ensure neighbor positions are within grid bounds before accessing or modifying them"
      ],
      "used_in": [
        "10fcaaa3",
        "3ac3eb23",
        "0ca9ddb6"
      ]
    },
    "place object on opposite side": {
      "name": "place object on opposite side",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "object | grid",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to place (e.g., a bar)"
        },
        {
          "name": "reference",
          "typing": "object",
          "description": "the object to place relative to (e.g., the moved green object)"
        },
        {
          "name": "direction",
          "typing": "direction",
          "description": "the direction from reference to object (used to compute the opposite)"
        },
        {
          "name": "stopping criteria",
          "typing": "stopping criteria := Callable[[object, grid], bool]",
          "description": "criteria to determine when to stop sliding the object"
        },
        {
          "name": "base",
          "typing": "grid",
          "description": "the grid to place the object onto"
        }
      ],
      "description": "place an object on the opposite side of a reference object by sliding it in the direction opposite to the reference direction until a stopping condition is met",
      "cues": [
        "if an object appears on the opposite side of another object in the output grid, especially after movement or alignment",
        "if the output grid contains symmetric placement of objects relative to a central object"
      ],
      "implementation": [
        "compute the direction from the reference to the anchor object, reverse it, and slide the object in that direction until the stopping criteria is satisfied (e.g., until it is no longer colliding with other objects)"
      ],
      "used_in": [
        "56dc2b01"
      ]
    },
    "get endpoints": {
      "name": "get endpoints",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[tuple[position, direction]]",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object (typically a line) whose endpoints are to be found"
        }
      ],
      "description": "find the endpoints of a line object and the direction(s) in which the line extends from each endpoint",
      "cues": [
        "if the output grid contains lines or trails extending from the ends of an object in the input grid",
        "if the solution needs to determine where a line \"points\" or where to start an extension"
      ],
      "implementation": [
        "for each endpoint (pixel with only one neighbor in the object), determine the direction vector away from the object",
        "can use connectivity analysis to find endpoints and their outward directions"
      ],
      "used_in": [
        "508bd3b6"
      ]
    },
    "within bounds": {
      "name": "within bounds",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the position to check"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to check bounds within"
        }
      ],
      "description": "check if a given position is within the valid bounds of the grid",
      "cues": [
        "when a process (such as line drawing or movement) interacts with the grid edge or must avoid out-of-bounds errors when updating grid pixels"
      ],
      "implementation": [
        "check that 0 <= x < grid width and 0 <= y < grid height"
      ],
      "used_in": [
        "508bd3b6",
        "28e73c20"
      ]
    },
    "draw line until color": {
      "name": "draw line until color",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "tuple[position, bool]",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to draw the line on"
        },
        {
          "name": "start",
          "typing": "position",
          "description": "the starting position to draw from"
        },
        {
          "name": "direction",
          "typing": "direction := Literal[\"up\", \"down\", \"left\", \"right\", \"up-right\", \"up-left\", \"down-right\", \"down-left\"]",
          "description": "the direction to draw in"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color of the line to draw"
        },
        {
          "name": "stop_colors",
          "typing": "list[color]",
          "description": "list of colors at which to stop drawing the line"
        }
      ],
      "description": "draw a line from a starting position in a given direction, coloring pixels until a pixel of a stop color is encountered or the grid edge is reached; returns the position where stopped and whether a stop color was hit",
      "cues": [
        "if lines in the output grid are drawn from an endpoint until they hit a barrier or colored object",
        "if a process must stop drawing when a certain color is encountered"
      ],
      "implementation": [
        "iterate from the start position in the given direction, coloring each pixel, until a pixel of stop_colors or grid edge is reached",
        "return the stopping position and whether a stop color was encountered"
      ],
      "used_in": [
        "508bd3b6"
      ]
    },
    "reflect direction": {
      "name": "reflect direction",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "direction",
      "parameters": [
        {
          "name": "direction",
          "typing": "direction",
          "description": "the incoming direction of movement"
        },
        {
          "name": "hit_side",
          "typing": "Literal[\"left\", \"right\", \"top\", \"bottom\"]",
          "description": "the side of the rectangle that was hit"
        }
      ],
      "description": "compute the new direction after reflecting off a rectangle side, given the incoming direction and the side hit",
      "cues": [
        "if lines or movement in the output grid \"bounce\" or reflect off the sides of an object",
        "if output lines change direction upon hitting a rectangle or frame"
      ],
      "implementation": [
        "for each side, reverse the appropriate component of the direction (e.g., hitting \"left\" or \"right\" reverses x, \"top\" or \"bottom\" reverses y)"
      ],
      "used_in": [
        "508bd3b6"
      ]
    },
    "which side of rectangle hit": {
      "name": "which side of rectangle hit",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "Literal[\"left\", \"right\", \"top\", \"bottom\"]",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the position where the rectangle was hit"
        },
        {
          "name": "rectangle",
          "typing": "object",
          "description": "the rectangle object being hit"
        }
      ],
      "description": "determine which side of a rectangle a given position is on (left, right, top, or bottom)",
      "cues": [
        "if the logic for reflection or bouncing depends on which side of a rectangle is contacted",
        "if output lines reflect differently depending on where they hit an object"
      ],
      "implementation": [
        "compare the position to the rectangle's bounding box; if x equals min_x, it's the left side, etc."
      ],
      "used_in": [
        "508bd3b6"
      ]
    },
    "count neighbors in object": {
      "name": "count neighbors in object",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object (typically a pixel or small group) whose neighbors are to be counted"
        },
        {
          "name": "reference_object",
          "typing": "object",
          "description": "the object in which to count neighbors (e.g., a rectangle)"
        },
        {
          "name": "connectivity",
          "typing": "int",
          "description": "connectivity to use for neighbor definition (4 or 8)"
        },
        {
          "name": "criteria",
          "typing": "Callable[[object], bool]",
          "description": "logic to determine if a neighbor counts (e.g., is not black)"
        }
      ],
      "description": "count the number of neighboring pixels of the given object that are also part of the reference object, using the specified connectivity",
      "cues": [
        "if a pixel or object is recolored, merged, or absorbed into another object only when it is adjacent to or touching that object",
        "if output grid shows noise pixels being absorbed into larger objects when adjacent, but deleted otherwise",
        "if isolated pixels are removed from the output grid"
      ],
      "implementation": [
        "for each pixel in the object, check all neighbors (according to connectivity) and count how many are in the reference object's pixel set and satisfy the criteria",
        "sum across all pixels in the object if it is more than a single pixel",
        "for noise removal, use a criteria that excludes background color (e.g., is_not_color(black))"
      ],
      "used_in": [
        "7e0986d6",
        "7f4411dc"
      ]
    },
    "scale object": {
      "name": "scale object",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "object | grid",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to scale"
        },
        {
          "name": "factor",
          "typing": "int | tuple[int, int]",
          "description": "the scaling factor to apply (can be a single integer for uniform scaling or a tuple for separate x/y scaling)"
        }
      ],
      "description": "scale an object by a given factor, enlarging or shrinking it proportionally along one or both axes",
      "cues": [
        "if pixels or objects are removed in the output grid by being set to black",
        "if the output grid uses black to represent absence or background"
      ],
      "implementation": [],
      "used_in": [
        "6b9890af",
        "57aa92db",
        "46f33fce"
      ]
    },
    "frame": {
      "name": "frame",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "an object that forms a rectangular border or outline, typically used to contain or highlight another object",
      "cues": [
        "if a small object in the input grid appears larger or smaller in the output, especially filling a frame or container",
        "if the output object is a scaled (enlarged or reduced) version of an input object, with regions that visually match the input but at a different size",
        "if each pixel or object in the input grid is replaced by a larger or smaller version in the output grid"
      ],
      "implementation": [
        "use numpy.kron or similar functions to repeat the object's pixels according to the scaling factor",
        "for non-uniform scaling, repeat rows and columns separately based on the scaling factors for each axis",
        "ensure the scaled object fits within the intended container or frame in the output grid"
      ],
      "used_in": [
        "6b9890af",
        "6f8cd79b"
      ]
    },
    "background": {
      "name": "background",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "the color used as the background or to fill unused grid space, typically 0 (black)",
      "cues": [
        "if the output grid contains a rectangular border (often of a specific color) surrounding another object or region",
        "if an object is placed inside a colored rectangular outline in the output",
        "if the output region is cropped to a rectangle containing a border and its contents"
      ],
      "implementation": [],
      "used_in": [
        "f8b3ba0a",
        "1e32b0e9",
        "444801d8"
      ]
    },
    "all pixels are color criteria": {
      "name": "all pixels are color criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object or region to check"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color all pixels must match"
        }
      ],
      "description": "condition on whether all pixels in an object are of the specified color",
      "cues": [
        "if the output grid is initialized with a single color before other drawing",
        "if unused or empty grid regions are filled with a uniform color"
      ],
      "implementation": [],
      "used_in": [
        "150deff5",
        "6cf79266",
        "25d8a9c8",
        "e48d4e1a",
        "bd4472b8",
        "3eda0437"
      ]
    },
    "logical operation on corresponding pixels": {
      "name": "logical operation on corresponding pixels",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "grids",
          "typing": "list[grid]",
          "description": "the grids whose corresponding pixels to combine"
        },
        {
          "name": "operation",
          "typing": "Callable[[list[color]], color]",
          "description": "logic to combine the corresponding pixel values"
        }
      ],
      "description": "create a new grid by applying a logical or arithmetic operation to corresponding pixels from multiple input grids",
      "cues": [
        "if objects, regions, or rectangles are selected or filtered based on being uniformly a single color (e.g., all grey, all black, or another color)",
        "if only monochrome regions are processed in the output"
      ],
      "implementation": [
        "check if all pixels in the object's mask or region are equal to the specified color"
      ],
      "used_in": [
        "1b2d62fb",
        "0520fde7",
        "3428a4f5"
      ]
    },
    "copy grid": {
      "name": "copy grid",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to copy"
        }
      ],
      "description": "create a copy of a grid, often used as a base for further drawing or manipulation",
      "cues": [
        "if the output grid is the same shape as input regions and each pixel depends only on the corresponding pixels in the regions",
        "if the output grid is a logical combination (e.g., AND, OR, XOR, NOR, difference) of two regions",
        "if the output grid highlights differences or similarities between two regions or patterns"
      ],
      "implementation": [
        "for each position, apply the operation to the list of pixel values from each grid at that position",
        "for difference or highlighting, set the output pixel to a special color if the inputs differ, and another color if they match"
      ],
      "used_in": [
        "6a1e5592",
        "bd4472b8"
      ]
    },
    "plugged pixel count": {
      "name": "plugged pixel count",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "sprite",
          "typing": "object",
          "description": "the puzzle piece sprite to consider"
        },
        {
          "name": "position",
          "typing": "position",
          "description": "the candidate position to place the sprite"
        },
        {
          "name": "target_object",
          "typing": "object",
          "description": "the object whose holes are to be plugged (e.g., red object)"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the current grid state (to check for overlap)"
        }
      ],
      "description": "count the number of black (empty) pixels in the target object that would be covered (plugged) by placing the sprite at the given position, without overlapping existing non-background pixels in the grid",
      "cues": [
        "if puzzle pieces are placed to maximize coverage of holes or empty pixels in a target object",
        "if placement is chosen to maximize the number of filled pixels"
      ],
      "implementation": [
        "for each candidate position, overlay the sprite and count the number of target_object's black pixels that would be covered",
        "ensure that the sprite does not overlap existing non-background pixels in the grid"
      ],
      "used_in": [
        "6a1e5592"
      ]
    },
    "all valid positions": {
      "name": "all valid positions",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[position]",
      "parameters": [
        {
          "name": "sprite",
          "typing": "object",
          "description": "the object to place"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to place the object onto"
        }
      ],
      "description": "generate all positions where the sprite can be placed on the grid without overlapping existing non-background pixels",
      "cues": [
        "if objects are placed in all possible positions to find the best fit without overlap",
        "if a search is performed over placements that do not collide with existing content"
      ],
      "implementation": [
        "for each position where the sprite's bounding box fits within the grid, check that all sprite pixels would overlay only background pixels"
      ],
      "used_in": [
        "6a1e5592"
      ]
    },
    "argmax": {
      "name": "argmax",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "Any",
      "parameters": [
        {
          "name": "sequence",
          "typing": "list[Any]",
          "description": "the sequence of candidate items to evaluate"
        },
        {
          "name": "key",
          "typing": "Callable[[Any], Any]",
          "description": "function to compute a score for each candidate"
        }
      ],
      "description": "select the element from a sequence that yields the maximum value according to the key function",
      "cues": [
        "if the output grid is initialized as a copy of a region or object from the input grid",
        "if further drawing or overlaying is performed on a grid that should preserve the original content"
      ],
      "implementation": [
        "use numpy.copy or similar to duplicate the grid"
      ],
      "used_in": [
        "6a1e5592",
        "681b3aeb",
        "0e206a2e",
        "57aa92db"
      ]
    },
    "fixed pattern": {
      "name": "fixed pattern",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "a small grid or sprite with a fixed arrangement of colored pixels, often used as a motif or patch to be overlaid at a specific position",
      "cues": [
        "when the solution involves selecting the best candidate from a set based on a scoring or evaluation function, such as maximizing a specific criterion (e.g., number of holes plugged, largest area, etc.)"
      ],
      "implementation": [
        "use Python's max() function with the key argument to select the element with the maximum value according to the provided key function"
      ],
      "used_in": [
        "a9f96cdd",
        "6cf79266",
        "995c5fa3"
      ]
    },
    "anchor position for centered overlay": {
      "name": "anchor position for centered overlay",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "position",
      "parameters": [
        {
          "name": "center_pos",
          "typing": "position",
          "description": "the position to center the overlay on"
        },
        {
          "name": "overlay_shape",
          "typing": "dimensions := tuple[int, int]",
          "description": "the shape of the overlay pattern (rows, columns)"
        }
      ],
      "description": "compute the upper-left anchor position for overlaying a pattern so that its center aligns with a specified position",
      "cues": [
        "if a fixed-size pattern is centered on a pixel or object in the output grid",
        "if the overlay must be positioned so its center matches a reference position"
      ],
      "implementation": [
        "subtract half the overlay's height and width (using integer division) from the center position to get the anchor"
      ],
      "used_in": [
        "a9f96cdd"
      ]
    },
    "pick only color from region": {
      "name": "pick only color from region",
      "kind": "routine",
      "routine_subtype": "color selection",
      "output_typing": "color",
      "parameters": [
        {
          "name": "region",
          "typing": "grid",
          "description": "the region grid to extract the color from"
        }
      ],
      "description": "select the only non-background color present in a region; assumes the region contains exactly one color besides the background (e.g., black)",
      "cues": [
        "if a recognizable, fixed-size pattern or motif (such as a colored square or diagonal) appears in the output grid, especially centered on an input pixel or object, or used to overwrite regions",
        "if the output grid contains motifs or templates of a fixed size (e.g., 4x4) not present in the input, or if patterns are matched to a reference set to determine output properties"
      ],
      "implementation": null,
      "used_in": [
        "780d0b14",
        "90c28cc7",
        "0b148d64"
      ]
    },
    "positions_where": {
      "name": "positions_where",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[tuple[int, int]]",
      "parameters": [
        {
          "name": "condition",
          "typing": "ndarray[bool] | Callable[[Any], bool]",
          "description": "boolean mask or function indicating which positions to select"
        }
      ],
      "description": "get the list of positions in an array where a condition holds (e.g., where a mask is True)",
      "cues": [
        "if you need to iterate over only the positions in a grid that satisfy a certain property (e.g., non-background pixels)"
      ],
      "implementation": [
        "use numpy's np.argwhere or np.where to get positions matching the condition"
      ],
      "used_in": [
        "1e32b0e9",
        "11852cab"
      ]
    },
    "fill missing pattern pixels with divider color": {
      "name": "fill missing pattern pixels with divider color",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "template_pattern",
          "typing": "grid",
          "description": "the reference pattern to fill from"
        },
        {
          "name": "target_pattern",
          "typing": "grid",
          "description": "the pattern to fill missing pixels in"
        },
        {
          "name": "fill color",
          "typing": "color",
          "description": "the color to use for filling missing pixels (e.g., divider line color)"
        }
      ],
      "description": "for each position where the template pattern has a non-background pixel, if the target pattern is missing or has a different value, fill it with the specified color",
      "cues": [
        "if output regions are filled to match a template, with missing pixels replaced by a special color (e.g., divider color)",
        "if output grid shows regions that are \"completed\" using a reference pattern, but with differences filled by a standard color"
      ],
      "implementation": [
        "for each position in the template, if the target pattern at that position does not match, set it to the fill color"
      ],
      "used_in": [
        "1e32b0e9"
      ]
    },
    "is_not_color": {
      "name": "is_not_color",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "color",
          "typing": "color",
          "description": "the color to check"
        },
        {
          "name": "excluded_color",
          "typing": "color",
          "description": "the color to exclude (e.g., black)"
        }
      ],
      "description": "condition on whether a color is not equal to a specified excluded color",
      "cues": [
        "if the solution must select or count only non-background pixels",
        "if the logic applies to all colors except a specific one (e.g., black)"
      ],
      "implementation": [
        "return True if color != excluded_color"
      ],
      "used_in": [
        "7f4411dc"
      ]
    },
    "unique": {
      "name": "unique",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[Any]",
      "parameters": [
        {
          "name": "sequence",
          "typing": "list[Any]",
          "description": "the sequence to extract unique elements from"
        }
      ],
      "description": "extract unique elements from a sequence, preserving order",
      "cues": [
        "If each region in the input grid is filled with a single color (other than the background/divider)",
        "If output grid pixels correspond to the color of regions in the input grid"
      ],
      "implementation": [
        "Use np.unique to find colors in the region, exclude the background/divider color, and return the remaining color"
      ],
      "used_in": [
        "90c28cc7",
        "0b148d64",
        "0dfd9992"
      ]
    },
    "period detection": {
      "name": "period detection",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to analyze for periodicity"
        },
        {
          "name": "axis",
          "typing": "axis := Literal[\"horizontal\", \"vertical\"]",
          "description": "the axis along which to detect the period (optional; default vertical)"
        }
      ],
      "description": "determine the period (height or width) of a repeating pattern in the grid, i.e., the minimal size such that the grid is composed of repeated copies of a sprite (possibly with symmetry)",
      "cues": [
        "when you need to identify or enumerate unique items (such as positions, colors, or attributes) from a list, especially if the solution logic depends on finding a unique value among candidates (e.g., a unique color among quadrants)"
      ],
      "implementation": [
        "use a set to track seen elements and filter duplicates while preserving the original order of the sequence"
      ],
      "used_in": [
        "2dee498d",
        "3bdb4ada",
        "0a938d79"
      ]
    },
    "repeated sprite with symmetry": {
      "name": "repeated sprite with symmetry",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "a grid region that is composed of repeated copies of a sprite, where each copy may be reflected or flipped",
      "cues": [
        "if the input grid consists of stacked or tiled regions that are all identical or mirror images of each other",
        "if the output is a single tile or sprite extracted from a repeated pattern in the input grid"
      ],
      "implementation": [],
      "used_in": [
        "2dee498d"
      ]
    },
    "stopping criteria": {
      "name": "stopping criteria",
      "kind": "routine",
      "routine_subtype": "stopping criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the position to check"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to check against"
        }
      ],
      "description": "a callable that determines when to stop an iterative process (e.g., drawing a line)",
      "cues": [
        "if a process (e.g., line drawing) stops at the grid edge or another condition"
      ],
      "implementation": [
        "for out-of-bounds, check that 0 <= x < grid width and 0 <= y < grid height"
      ],
      "used_in": [
        "3ac3eb23"
      ]
    },
    "no collision with": {
      "name": "no collision with",
      "kind": "routine",
      "routine_subtype": "stopping criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object being moved"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to check for collisions with"
        }
      ],
      "description": "stopping criteria that returns True if moving the object would not result in a collision with any non-background pixel in the grid",
      "cues": [
        "if an object is moved stepwise and must not overlap with other objects or colored pixels in the output grid",
        "if movement must stop before colliding with a fixed set of objects or markers"
      ],
      "implementation": [
        "for each candidate position, check if any of the object's pixels would overlap with non-background pixels in the grid"
      ],
      "used_in": [
        "5168d44c"
      ]
    },
    "sliding window": {
      "name": "sliding window",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[grid]",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to extract windows from"
        },
        {
          "name": "window_shape",
          "typing": "dimensions := tuple[int, int]",
          "description": "the shape (height, width) of the window to slide"
        }
      ],
      "description": "generate all possible subgrids of a given shape by sliding a window over the grid",
      "cues": [
        "if the output depends on detecting or modifying fixed-size regions throughout the grid",
        "if the solution operates on all possible subgrids of a certain size (e.g., 3x3)"
      ],
      "implementation": [
        "use nested loops to extract all subarrays of the specified shape from the grid, along with their positions"
      ],
      "used_in": [
        "6cf79266"
      ]
    },
    "create cross": {
      "name": "create cross",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "shape",
          "typing": "dimensions := tuple[int, int]",
          "description": "the (height, width) of the cross to create"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color to use for the cross"
        }
      ],
      "description": "create a cross-shaped sprite of the given dimensions and color, with bars centered in the grid",
      "cues": [
        "if the output grid contains a cross (plus sign) shape, possibly centered on a special position",
        "if a cross-shaped pattern appears in the output grid, especially of a fixed size (e.g., 3x3)"
      ],
      "implementation": [
        "create a grid of the specified shape, set the central row and column to the color, others to background"
      ],
      "used_in": [
        "e9614598"
      ]
    },
    "midpoint between": {
      "name": "midpoint between",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "position",
      "parameters": [
        {
          "name": "position1",
          "typing": "position",
          "description": "the first position"
        },
        {
          "name": "position2",
          "typing": "position",
          "description": "the second position"
        }
      ],
      "description": "compute the position exactly halfway between two positions (e.g., for centering a sprite)",
      "cues": [
        "if an object or pattern is centered between two input features (e.g., colored pixels)",
        "if output features are equidistant from two reference points"
      ],
      "implementation": [
        "average the row and column indices of the two positions (integer division)"
      ],
      "used_in": [
        "e9614598"
      ]
    },
    "centered at": {
      "name": "centered at",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "position",
      "parameters": [
        {
          "name": "center_pos",
          "typing": "position",
          "description": "the position to center the overlay on"
        },
        {
          "name": "overlay_shape",
          "typing": "dimensions := tuple[int, int]",
          "description": "the shape of the overlay pattern (rows, columns)"
        }
      ],
      "description": "compute the upper-left anchor position for overlaying a pattern so that its center aligns with a specified position",
      "cues": [
        "Presence of repeated regions or sprites in the grid, possibly with reflection.",
        "Output consists of a single tile or sprite extracted from a repeated pattern in the input grid."
      ],
      "implementation": [
        "For each possible period, partition the grid along the specified axis and check if all regions are identical, allowing for possible reflection symmetry.",
        "Utilize shape matching and reflection operations to account for symmetric repetitions."
      ],
      "used_in": [
        "e9614598",
        "b7249182"
      ]
    },
    "row": {
      "name": "row",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "a horizontal sequence of pixels in the grid, often treated as a region or object for per-row processing",
      "cues": [
        "if a fixed-size pattern is centered on a pixel or object in the output grid",
        "if the overlay must be positioned so its center matches a reference position"
      ],
      "implementation": [
        "subtract half the overlay's height and width (using integer division) from the center position to get the anchor"
      ],
      "used_in": [
        "25d8a9c8",
        "995c5fa3"
      ]
    },
    "count": {
      "name": "count",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "sequence",
          "typing": "list[Any]",
          "description": "the sequence to count elements in"
        }
      ],
      "description": "count the number of elements in a sequence; can be used to count unique colors, objects, etc.",
      "cues": [
        "if the output grid is manipulated or recolored on a row-by-row basis",
        "if each row is processed independently in the solution logic",
        "if each row of the output grid is filled with a single color corresponding to an input pattern",
        "if output grid is constructed row by row, with each row determined by input features"
      ],
      "implementation": [],
      "used_in": [
        "fcc82909",
        "0b148d64",
        "681b3aeb",
        "0e206a2e"
      ]
    },
    "bottom left position": {
      "name": "bottom left position",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "position",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object whose bottom left position is to be found"
        }
      ],
      "description": "compute the (row, column) of the bottom-left pixel of an object's bounding box",
      "cues": [
        "if new objects are placed directly below existing objects in the output grid",
        "if the output grid contains features aligned with the lower edge of input objects"
      ],
      "implementation": [
        "find the minimum column and maximum row among the object's pixels"
      ],
      "used_in": [
        "fcc82909"
      ]
    },
    "rectangle object": {
      "name": "rectangle object",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "an object whose shape is a rectangle, often used for bars, highlights, or as a region to fill",
      "cues": [
        "if the output or solution logic depends on the number of distinct items (e.g., colors, objects) or the frequency of a color in regions or objects"
      ],
      "implementation": [
        "use len() on the sequence"
      ],
      "used_in": [
        "fcc82909",
        "3bdb4ada",
        "3befdf3e",
        "3eda0437",
        "af902bf9",
        "41e4d17e",
        "e73095fd"
      ]
    },
    "symmetry types": {
      "name": "symmetry types",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "the set of symmetry types to check for, such as \"rotational\", \"vertical\", \"horizontal\", or \"diagonal\"",
      "cues": [
        "if the output grid contains regions, objects, or background areas filled with green that are not present in the input"
      ],
      "implementation": [],
      "used_in": [
        "72ca375d",
        "11852cab"
      ]
    },
    "create periodic hole pattern": {
      "name": "create periodic hole pattern",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "object | grid",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object (usually a rectangle) to punch holes in"
        },
        {
          "name": "axis",
          "typing": "axis := Literal[\"horizontal\", \"vertical\"]",
          "description": "the axis along which to punch holes (e.g., center row or column)"
        },
        {
          "name": "period",
          "typing": "int",
          "description": "the period (spacing) between holes"
        },
        {
          "name": "offset",
          "typing": "int",
          "description": "how many pixels in to start the first hole (default 0)"
        },
        {
          "name": "hole_color",
          "typing": "color",
          "description": "the color to use for the holes (typically black)"
        }
      ],
      "description": "set every nth pixel along the center line (row or column) of an object to a specified color, starting at a given offset",
      "cues": [
        "if output rectangles have regularly spaced missing pixels (holes) along their center",
        "if every other pixel (or at another fixed interval) in a row or column is set to black or another color",
        "if a periodic pattern of holes appears in the center of objects in the output grid"
      ],
      "implementation": [
        "for the chosen axis (row or column), iterate from offset to the end in steps of period, setting the pixel to hole_color",
        "for horizontal, operate on the center row; for vertical, on the center column",
        "can rotate the object to canonical orientation for simpler implementation, then rotate back if needed"
      ],
      "used_in": [
        "3bdb4ada"
      ]
    },
    "edges of object": {
      "name": "edges of object",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[edge]",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object (typically a rectangle or square) whose edges to extract"
        }
      ],
      "description": "extract the edges of a rectangular object, providing their orientation, length, and outward position for further drawing",
      "cues": [
        "if rectangles or squares in the output have features added to their edges",
        "if drawing or extending shapes from the border of an object"
      ],
      "implementation": [
        "for each of the four sides of a rectangle, record the orientation (\"top\", \"bottom\", \"left\", \"right\"), the length, and the position just outside the edge for drawing extensions"
      ],
      "used_in": [
        "3befdf3e"
      ]
    },
    "create rectangle": {
      "name": "create rectangle",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "size",
          "typing": "tuple[int, int]",
          "description": "the (height, width) of the rectangle to create"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color to fill the rectangle with"
        },
        {
          "name": "orientation",
          "typing": "Literal[\"horizontal\", \"vertical\"]",
          "description": "the orientation of the rectangle (optional; determines which dimension is length vs width)"
        }
      ],
      "description": "create a filled rectangle of the specified size, color, and orientation",
      "cues": [
        "if output grid contains new rectangles extending from the edges of existing shapes",
        "if rectangles are added to the border of objects, matching the color and size of other features"
      ],
      "implementation": [
        "create a numpy array of the given size, filled with the specified color",
        "for orientation, swap height/width as needed"
      ],
      "used_in": [
        "3befdf3e"
      ]
    },
    "most common color": {
      "name": "most common color",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "color",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to analyze for the most frequent color"
        }
      ],
      "description": "find the color that appears most frequently in the grid, typically used as the background color",
      "cues": [
        "if the output grid contains filled rectangles of a single color, especially adjacent to or below input objects",
        "if new rectangular regions are added in the output grid with dimensions determined by properties of input objects",
        "if the solution searches for or processes rectangular regions in the grid"
      ],
      "implementation": [],
      "used_in": [
        "e8dc4411",
        "caa06a1f",
        "3618c87e",
        "41e4d17e",
        "0962bcdd"
      ]
    },
    "stride for translation": {
      "name": "stride for translation",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "template",
          "typing": "object",
          "description": "the object to be translated"
        },
        {
          "name": "indicator",
          "typing": "object",
          "description": "the indicator object to align with"
        },
        {
          "name": "direction",
          "typing": "direction",
          "description": "the direction in which to translate"
        },
        {
          "name": "background",
          "typing": "color",
          "description": "background color to ignore when checking for overlap (optional)"
        }
      ],
      "description": "compute the largest step size in the given direction such that translating the template keeps it covering the indicator (and not overlapping non-background pixels)",
      "cues": [
        "if an object is repeatedly translated in a direction, with each copy covering a reference pixel",
        "if output grid shows repeated, evenly spaced copies of an object aligned with indicator pixels"
      ],
      "implementation": [
        "for increasing step sizes, translate the template and check if it still covers the indicator and does not overlap non-background pixels",
        "stop when the template would no longer cover the indicator or would overlap another object"
      ],
      "used_in": [
        "e8dc4411"
      ]
    },
    "repeated translation": {
      "name": "repeated translation",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to translate and draw repeatedly"
        },
        {
          "name": "start_position",
          "typing": "position",
          "description": "the starting position for translation"
        },
        {
          "name": "direction",
          "typing": "direction",
          "description": "the direction in which to translate (e.g., diagonal)"
        },
        {
          "name": "stride",
          "typing": "int",
          "description": "the step size for each translation"
        },
        {
          "name": "repetitions",
          "typing": "int",
          "description": "number of times to repeat the translation"
        },
        {
          "name": "base",
          "typing": "grid",
          "description": "the grid to draw onto"
        }
      ],
      "description": "repeatedly translate an object by a fixed stride in a given direction and draw it onto the grid",
      "cues": [
        "if the solution distinguishes between different types of symmetry (e.g., mirror vs. rotational)",
        "if objects are selected based on being symmetric under one or more transformations"
      ],
      "implementation": [],
      "used_in": [
        "e8dc4411",
        "0a938d79",
        "feca6190"
      ]
    },
    "alternating pattern stacking": {
      "name": "alternating pattern stacking",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "patterns",
          "typing": "list[grid]",
          "description": "the list of grids or sprites to alternate between when stacking"
        },
        {
          "name": "repetitions",
          "typing": "int",
          "description": "number of times to repeat the alternating stacking pattern"
        },
        {
          "name": "overlap",
          "typing": "int",
          "description": "number of rows (or columns) to overlap between consecutive stackings"
        },
        {
          "name": "axis",
          "typing": "axis := Literal[\"vertical\", \"horizontal\"]",
          "description": "the axis along which to stack the patterns (default vertical)"
        },
        {
          "name": "base",
          "typing": "grid",
          "description": "the grid to draw onto (optional; if not provided, create new grid)"
        }
      ],
      "description": "stack a sequence of patterns (e.g., a grid and its reflection) alternately along an axis, overlapping by a specified number of rows or columns each time",
      "cues": [
        "if the output grid consists of repeated copies of input and its reflection, stacked with overlap",
        "if the output is a tall or wide strip formed by alternately stacking input and flipped input, with each new copy overlapping the previous",
        "if the output grid is much taller or wider than the input, and the stacking alternates between two patterns"
      ],
      "implementation": [
        "for each repetition, select the appropriate pattern (e.g., alternating original and flipped), compute the anchor position based on overlap, and draw it onto the base grid",
        "use a loop to alternate between patterns and increment the stacking position by (pattern size - overlap) each time"
      ],
      "used_in": [
        "eb281b96"
      ]
    },
    "map object corner to output": {
      "name": "map object corner to output",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "position",
      "parameters": [
        {
          "name": "object_position",
          "typing": "position",
          "description": "the position of the object in the input grid (typically its top-left corner)"
        },
        {
          "name": "input_shape",
          "typing": "dimensions := tuple[int, int]",
          "description": "the shape of the input grid"
        },
        {
          "name": "output_shape",
          "typing": "dimensions := tuple[int, int]",
          "description": "the shape of the output grid"
        }
      ],
      "description": "map the corner position of an object in the input grid to the corresponding corner in the output grid, preserving the relative corner (e.g., top-left, top-right, bottom-left, bottom-right)",
      "cues": [
        "if patterns from the four corners of the input grid are copied to the corresponding corners of the output grid",
        "if objects are aligned to corners in both input and output grids"
      ],
      "implementation": [
        "determine which corner (top-left, top-right, bottom-left, bottom-right) the object's position corresponds to in the input grid, and compute the matching corner position in the output grid",
        "for top-left, map to (0, 0); for top-right, map to (0, output_width - object_width); etc."
      ],
      "used_in": [
        "bc1d5164"
      ]
    },
    "max": {
      "name": "max",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "sequence",
          "typing": "list[int]",
          "description": "the sequence of values to find the maximum of"
        }
      ],
      "description": "compute the maximum value in a sequence, often used to determine the largest dimension among a set of objects",
      "cues": [
        "if the output grid size is determined by the largest object in the input grid"
      ],
      "implementation": [
        "use Python's built-in max() function over the relevant attribute (e.g., object.width)"
      ],
      "used_in": [
        "bc1d5164"
      ]
    },
    "vertical line beneath object criteria": {
      "name": "vertical line beneath object criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "pixel",
          "typing": "object",
          "description": "the pixel to check for being beneath the object"
        },
        {
          "name": "object",
          "typing": "object",
          "description": "the object to check if it is above the pixel"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid containing the pixel and object"
        }
      ],
      "description": "condition on whether a pixel is directly beneath an object (e.g., chevron), i.e., moving upward from the pixel encounters the object before any other occurrence of the object color.",
      "cues": [
        "if output grid contains vertical lines starting just below a specific object, aligned with colored pixels beneath that object",
        "if colored pixels in the input grid are vertically aligned with a specific object and are extended downward in the output"
      ],
      "implementation": [
        "for the given pixel, move upward (decreasing y) and check if the first non-background pixel encountered is part of the object",
        "ensure there are no object pixels between the pixel and the object above"
      ],
      "used_in": [
        "6d58a25d"
      ]
    },
    "color exclusion": {
      "name": "color exclusion",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "color",
      "parameters": [
        {
          "name": "colors",
          "typing": "set[color]",
          "description": "set of candidate colors"
        },
        {
          "name": "exclude",
          "typing": "set[color]",
          "description": "colors to exclude"
        }
      ],
      "description": "select a color from a set, excluding specified colors (e.g., background or object color)",
      "cues": [
        "if the output depends on identifying a color present in the input grid but not used for a specific object or background"
      ],
      "implementation": [
        "subtract the exclude set from the set of candidate colors"
      ],
      "used_in": [
        "6d58a25d"
      ]
    },
    "nested layers": {
      "name": "nested layers",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "a visual pattern where multiple objects or regions are arranged as concentric layers, each enclosed within the previous one, often with different colors",
      "cues": [
        "if output grid is composed of concentric colored squares or rectangles, with each inner layer surrounded by an outer layer of a different color",
        "if the number of layers matches the number of objects in the input grid",
        "if each layer is one pixel wide and colored according to input object colors"
      ],
      "implementation": [],
      "used_in": [
        "eb5a1d5d"
      ]
    },
    "object_area": {
      "name": "object_area",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object whose area (number of pixels) to compute"
        }
      ],
      "description": "compute the area (number of pixels) of an object, often used for sorting or ranking objects by size",
      "cues": [
        "when the background color varies and must be inferred from the grid",
        "when object extraction or masking relies on identifying the most common color"
      ],
      "implementation": [
        "use numpy or collections.Counter to count color frequencies and select the most common color"
      ],
      "used_in": [
        "eb5a1d5d",
        "ce602527",
        "3eda0437"
      ]
    },
    "odd-one-out region": {
      "name": "odd-one-out region",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "grid | object",
      "parameters": [
        {
          "name": "regions",
          "typing": "list[grid]",
          "description": "the list of regions to search"
        },
        {
          "name": "key",
          "typing": "Callable[[grid], Any]",
          "description": "function to extract the property to test for uniqueness (e.g., color)"
        }
      ],
      "description": "select the region whose property (e.g., color) is unique among all regions",
      "cues": [
        "if one region among several is visually distinct by color or other property",
        "if the output grid is a copy of the only region with a unique color"
      ],
      "implementation": [
        "for each region, compute the key; select the region whose key occurs exactly once among all regions"
      ],
      "used_in": [
        "0b148d64"
      ]
    },
    "find unique color": {
      "name": "find unique color",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "color",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to search for a unique color in"
        },
        {
          "name": "exclude",
          "typing": "list[color]",
          "description": "colors to exclude from consideration"
        }
      ],
      "description": "find the unique color in a grid, excluding specified colors (e.g., background or marker colors)",
      "cues": [
        "if the grid contains a single colored object or feature, and other colors are background or markers",
        "if the output depends on identifying a single color that is not background or a special marker"
      ],
      "implementation": [
        "use np.unique to get all colors in the grid, remove excluded colors, and check if only one remains"
      ],
      "used_in": [
        "e48d4e1a"
      ]
    },
    "find row": {
      "name": "find row",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to search"
        },
        {
          "name": "criteria",
          "typing": "selection criteria := Callable[[object], bool]",
          "description": "logic to determine if a row matches"
        }
      ],
      "description": "find the index of a row in the grid that matches a given criteria (e.g., all pixels are a specific color)",
      "cues": [
        "if output grid contains repeated, evenly spaced copies of an object in a straight line, diagonal, or other direction",
        "if an object is \"stamped\" multiple times in a regular pattern to fill a region, possibly with recoloring"
      ],
      "implementation": [
        "for each repetition, compute the new position by adding stride * direction to the start position and draw the object at that position",
        "stop if the object would go out of bounds or overlap non-background pixels",
        "for diagonal translation, increment both row and column by the stride for each repetition"
      ],
      "used_in": [
        "e48d4e1a",
        "bd4472b8"
      ]
    },
    "find column": {
      "name": "find column",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to search"
        },
        {
          "name": "criteria",
          "typing": "selection criteria := Callable[[object], bool]",
          "description": "logic to determine if a column matches"
        }
      ],
      "description": "find the index of a column in the grid that matches a given criteria (e.g., all pixels are a specific color)",
      "cues": [
        "if a column in the grid is fully filled with a single color, corresponding to a feature or object",
        "if the output depends on the position of a column with a special property"
      ],
      "implementation": [
        "iterate over columns and apply the criteria; return the index of the matching column"
      ],
      "used_in": [
        "e48d4e1a"
      ]
    },
    "cross object": {
      "name": "cross object",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "an object composed of a filled row and a filled column intersecting at a single position, typically forming a plus sign",
      "cues": [
        "if objects are sorted, ranked, or selected based on their size or area",
        "if output depends on comparing the sizes of input objects or regions"
      ],
      "implementation": [
        "count the number of non-background pixels in the object's mask or region"
      ],
      "used_in": [
        "e48d4e1a",
        "0962bcdd"
      ]
    },
    "shift object position": {
      "name": "shift object position",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "position",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the original position of the object or feature"
        },
        {
          "name": "row_shift",
          "typing": "int",
          "description": "number of rows to shift (positive or negative)"
        },
        {
          "name": "col_shift",
          "typing": "int",
          "description": "number of columns to shift (positive or negative)"
        }
      ],
      "description": "compute a new position by shifting the original position by the specified row and column offsets",
      "cues": [
        "if an object or pattern in the output grid is a shifted version of one in the input grid, with the shift amount determined by a count or property",
        "if the position of a feature is adjusted by a computed offset"
      ],
      "implementation": [
        "add row_shift to the row index and col_shift to the column index of the original position"
      ],
      "used_in": [
        "e48d4e1a"
      ]
    },
    "find background color": {
      "name": "find background color",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "color",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to analyze for background color"
        },
        {
          "name": "method",
          "typing": "str | Callable",
          "description": "method for determining background color (e.g., most_common_on_border)"
        }
      ],
      "description": "determine the background color of a grid, possibly using a specific method such as the most common color on the grid border",
      "cues": [
        "if the background color is not always black and must be inferred from the grid, especially from the border",
        "if object extraction or masking depends on the background color"
      ],
      "implementation": [
        "extract the border pixels of the grid and count color frequencies to find the most common color",
        "can use np.unique or collections.Counter on the border pixels"
      ],
      "used_in": [
        "caa06a1f"
      ]
    },
    "compute orbit": {
      "name": "compute orbit",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[position]",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the starting position to compute the orbit from"
        },
        {
          "name": "symmetry",
          "typing": "symmetry := Callable[[position], position]",
          "description": "the symmetry transformation to repeatedly apply (e.g., translation)"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid whose bounds to restrict the orbit to"
        }
      ],
      "description": "compute the set of positions that a given position maps to under repeated application of a symmetry transformation, restricted to a grid's bounds",
      "cues": [
        "if a row in the grid is fully filled with a single color, corresponding to a feature or object",
        "if the output depends on the position of a row with a special property"
      ],
      "implementation": [
        "iterate over rows and apply the criteria; return the index of the matching row"
      ],
      "used_in": [
        "caa06a1f",
        "0dfd9992"
      ]
    },
    "crop grid": {
      "name": "crop grid",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to crop"
        },
        {
          "name": "rows",
          "typing": "tuple[int, int]",
          "description": "the range of rows to keep (optional; default is all rows)"
        },
        {
          "name": "columns",
          "typing": "tuple[int, int]",
          "description": "the range of columns to keep (optional; default is all columns)"
        }
      ],
      "description": "create a new grid that is a contiguous subregion of the input grid, specified by row and/or column ranges",
      "cues": [
        "if the output grid is a shifted or truncated version of a larger pattern",
        "if the output grid is a subregion of a larger constructed grid"
      ],
      "implementation": [
        "use array slicing to extract the specified rows and columns from the grid",
        "for cropping off the leftmost column, set columns=(1, grid.shape[1])"
      ],
      "used_in": [
        "caa06a1f"
      ]
    },
    "get row": {
      "name": "get row",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[color]",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to extract the row from"
        },
        {
          "name": "row",
          "typing": "int",
          "description": "the index of the row to extract"
        }
      ],
      "description": "extract the sequence of colors from a specified row in the grid",
      "cues": [
        "if the output grid's rows repeat or depend on the color sequence of a specific row in the input grid"
      ],
      "implementation": [
        "use grid[row] to extract the row as a list or array"
      ],
      "used_in": [
        "bd4472b8",
        "3618c87e"
      ]
    },
    "repeat color sequence in rows": {
      "name": "repeat color sequence in rows",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid whose rows to fill"
        },
        {
          "name": "start_row",
          "typing": "int",
          "description": "the index of the first row to fill"
        },
        {
          "name": "color_sequence",
          "typing": "list[color]",
          "description": "the sequence of colors to repeat in filling rows"
        }
      ],
      "description": "fill each row of a grid (starting from start_row) with colors from a sequence, cycling through the sequence as needed",
      "cues": [
        "presence of a plus-shaped pattern formed by a row and column of the same color in the grid",
        "output grid is created by drawing a filled row and column intersecting at a specific position"
      ],
      "implementation": null,
      "used_in": [
        "bd4472b8",
        "bbc9ae5d"
      ]
    },
    "copy rows": {
      "name": "copy rows",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to copy rows from"
        },
        {
          "name": "rows",
          "typing": "list[int]",
          "description": "the indices of the rows to copy"
        }
      ],
      "description": "copy specified rows from a grid to another grid, preserving their content and order",
      "cues": [
        "if the output grid begins with a prefix of rows identical to the input grid",
        "if the top rows of the output grid are unchanged from the input grid"
      ],
      "implementation": [
        "for each row index in rows, copy grid[row] to the corresponding row in the output grid"
      ],
      "used_in": [
        "bd4472b8"
      ]
    },
    "rotate direction": {
      "name": "rotate direction",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "direction",
      "parameters": [
        {
          "name": "direction",
          "typing": "direction := Literal[\"up\", \"down\", \"left\", \"right\", \"up-right\", \"up-left\", \"down-right\", \"down-left\"]",
          "description": "the current direction"
        },
        {
          "name": "angle",
          "typing": "int",
          "description": "angle in degrees to rotate (positive for clockwise, negative for counterclockwise)"
        }
      ],
      "description": "rotate a direction by a specified angle (typically 90 degrees for right turns)",
      "cues": [
        "if an agent or process turns right or left when blocked or at corners",
        "if output patterns involve repeated right-angle turns (e.g., spirals, zigzags)"
      ],
      "implementation": [
        "map directions to vectors, apply rotation matrix, map back to direction label",
        "for 90-degree increments, use a fixed order list and modulo arithmetic"
      ],
      "used_in": [
        "28e73c20"
      ]
    },
    "spiral path": {
      "name": "spiral path",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "a path that starts at a corner or edge and winds inward, turning at right angles whenever blocked, forming a spiral",
      "cues": [
        "if the output grid contains a continuous colored path that spirals inward from the edge or corner",
        "if coloring proceeds in a spiral, with each turn occurring when the path meets a boundary or previously colored cell"
      ],
      "implementation": [],
      "used_in": [
        "28e73c20"
      ]
    },
    "bottom row alignment": {
      "name": "bottom row alignment",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "position",
      "parameters": [
        {
          "name": "x",
          "typing": "int",
          "description": "the column index to align with"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid whose bottom row to use"
        }
      ],
      "description": "compute the position in the bottom row of the grid aligned with a given column index",
      "cues": [
        "if output grid contains colored pixels in the bottom row aligned with the center or another property of input objects",
        "if features in the output are always placed at the bottom of the grid, aligned horizontally with input objects"
      ],
      "implementation": [
        "set y to grid.height - 1 and x to the desired column index"
      ],
      "used_in": [
        "54d82841"
      ]
    },
    "bounding box": {
      "name": "bounding box",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "grid | object",
      "parameters": [
        {
          "name": "objects",
          "typing": "list[object]",
          "description": "the objects to compute the bounding box for"
        }
      ],
      "description": "compute the minimal rectangle containing all specified objects",
      "cues": [
        "output grid is filled by extending a pattern using a symmetry transformation (e.g., translation)",
        "a motif or colored pixel is repeated at regular intervals in the output grid"
      ],
      "implementation": [
        "repeatedly apply the symmetry transformation to the starting position, collecting all unique positions within the grid until a cycle is detected or a position goes out of bounds"
      ],
      "used_in": [
        "681b3aeb",
        "aba27056",
        "3f7978a0",
        "d4f3cd78"
      ]
    },
    "enumerate nonoverlapping placements": {
      "name": "enumerate nonoverlapping placements",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[placement]",
      "parameters": [
        {
          "name": "objects",
          "typing": "list[object]",
          "description": "the objects to place"
        },
        {
          "name": "allow_rotation",
          "typing": "bool",
          "description": "whether to allow rotation of objects in placements"
        }
      ],
      "description": "generate all possible placements of the given objects such that they do not overlap, optionally allowing rotation",
      "cues": [
        "if the output grid contains objects packed together with no overlap and no empty space",
        "if the solution requires searching over possible arrangements of objects to optimize a packing criterion"
      ],
      "implementation": [
        "for each permutation of object positions (and rotations if allowed), check for non-overlapping placements within a bounding rectangle",
        "yield placements as lists of positions (and orientations if relevant)"
      ],
      "used_in": [
        "681b3aeb"
      ]
    },
    "count empty pixels": {
      "name": "count empty pixels",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "region",
          "typing": "grid | object",
          "description": "the region or bounding box to count empty pixels in"
        },
        {
          "name": "background",
          "typing": "color",
          "description": "the color considered as empty (default 0)"
        }
      ],
      "description": "count the number of pixels in a region that are equal to the background color",
      "cues": [
        "if the solution selects arrangements that minimize empty space in a region",
        "if output grid is a rectangle with no empty (background) pixels between objects"
      ],
      "implementation": [
        "count the number of pixels in the region that are equal to the background color (e.g., np.sum(region == background))"
      ],
      "used_in": [
        "681b3aeb"
      ]
    },
    "arrange regions as grid": {
      "name": "arrange regions as grid",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[list[grid]]",
      "parameters": [
        {
          "name": "regions",
          "typing": "list[grid]",
          "description": "the list of regions to arrange"
        }
      ],
      "description": "arrange a list of regions into a 2D grid structure (list of lists), based on their spatial positions in the original grid",
      "cues": [
        "if the grid is partitioned into a regular grid of regions by divider lines, and you need to map regions to a 2D array for further processing",
        "if the output grid is constructed by mapping region positions to a pattern or color"
      ],
      "implementation": [
        "sort regions by their top-left coordinates (row, column) and group them into rows and columns according to their positions",
        "can use bounding box coordinates to determine row and column indices for each region"
      ],
      "used_in": [
        "09629e4f"
      ]
    },
    "fill region with pattern by grid position": {
      "name": "fill region with pattern by grid position",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "region_grid",
          "typing": "list[list[grid]]",
          "description": "the 2D grid of regions to fill"
        },
        {
          "name": "pattern",
          "typing": "grid",
          "description": "the pattern or sprite to use for filling (dimensions must match region_grid)"
        },
        {
          "name": "divider_color",
          "typing": "color",
          "description": "the color of divider lines to preserve (optional)"
        },
        {
          "name": "output_grid",
          "typing": "grid",
          "description": "the grid to fill (optional; if not provided, create new grid)"
        }
      ],
      "description": "fill each region in a region grid with the corresponding color or pattern from a reference sprite/pattern, matching by region grid position, while preserving divider lines if present",
      "cues": [
        "if the output grid is constructed by filling each region with a color or pattern based on its position in a region grid",
        "if divider lines or bars must be preserved in the output",
        "if the output grid is a tiled or mapped version of a reference pattern, aligned to a region grid"
      ],
      "implementation": [
        "for each region at (i, j) in region_grid, set all non-divider pixels in that region to pattern[i, j]",
        "copy divider line pixels from the input grid to the output grid before filling regions"
      ],
      "used_in": [
        "09629e4f"
      ]
    },
    "is_aligned": {
      "name": "is_aligned",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "objects",
          "typing": "list[object]",
          "description": "the objects to check alignment for"
        },
        {
          "name": "axis",
          "typing": "axis := Literal[\"horizontal\", \"vertical\"]",
          "description": "the axis to check alignment along"
        }
      ],
      "description": "check if all objects are aligned along the specified axis (i.e., all share the same row or column)",
      "cues": [
        "if two or more objects/pixels are in a straight line in the input grid",
        "if the solution logic rotates the grid to align objects for easier processing"
      ],
      "implementation": [
        "for \"horizontal\", check if all y-coordinates are equal; for \"vertical\", check if all x-coordinates are equal"
      ],
      "used_in": [
        "b7249182"
      ]
    },
    "position_along_axis": {
      "name": "position_along_axis",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "axis",
          "typing": "axis := Literal[\"x\", \"y\"]",
          "description": "the axis to extract the position along"
        }
      ],
      "description": "returns a function that, given an object, extracts its x or y coordinate (e.g., for sorting)",
      "cues": [
        "if objects are sorted or processed left-to-right or top-to-bottom",
        "if the solution logic needs to order objects by their position along an axis"
      ],
      "implementation": [
        "for axis \"x\", return object's minimum x-coordinate; for \"y\", return minimum y-coordinate"
      ],
      "used_in": [
        "b7249182"
      ]
    },
    "create_hollow_rectangle": {
      "name": "create_hollow_rectangle",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "width",
          "typing": "int",
          "description": "the width of the rectangle"
        },
        {
          "name": "height",
          "typing": "int",
          "description": "the height of the rectangle"
        },
        {
          "name": "left_color",
          "typing": "color",
          "description": "color for the left half of the rectangle border"
        },
        {
          "name": "right_color",
          "typing": "color",
          "description": "color for the right half of the rectangle border"
        }
      ],
      "description": "create a hollow rectangle (border only, interior empty) with the left and right halves of the border colored differently",
      "cues": [
        "if output grid contains a rectangle with a border of two colors, each matching a nearby pixel",
        "if a rectangle is centered between two colored pixels, with each half of the border matching the color of the nearest pixel"
      ],
      "implementation": [
        "create a grid of the given size; set the border pixels in the left half to left_color and in the right half to right_color; leave interior pixels as background"
      ],
      "used_in": [
        "b7249182"
      ]
    },
    "border pixels": {
      "name": "border pixels",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "pixel objects (typically of size 1) located on the edge of the grid, often serving as starting points for movement or transformation",
      "cues": [
        "if only single pixels on the grid edge are selected for movement or manipulation",
        "if output features originate from the border of the input grid"
      ],
      "implementation": [
        "filter objects of size 1 and check if their position is on the grid edge"
      ],
      "used_in": [
        "1f642eb9"
      ]
    },
    "find pixels": {
      "name": "find pixels",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[object]",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to search for pixels in"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color to search for"
        },
        {
          "name": "criteria",
          "typing": "selection criteria := Callable[[object], bool]",
          "description": "additional criteria to filter pixels (optional)"
        }
      ],
      "description": "extract all pixel objects in a grid of a given color, optionally filtered by additional criteria",
      "cues": [
        "if the solution needs to process only scattered pixels of a specific color inside a region",
        "if output features are drawn from or to specific colored pixels not on lines or borders"
      ],
      "implementation": [
        "for each pixel in the grid, if its color matches and criteria (if any) is satisfied, include it in the result"
      ],
      "used_in": [
        "5daaa586"
      ]
    },
    "get edge pixel": {
      "name": "get edge pixel",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "object",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid or region to search in"
        },
        {
          "name": "position",
          "typing": "position",
          "description": "the starting position inside the grid"
        },
        {
          "name": "direction",
          "typing": "direction := Literal[\"up\", \"down\", \"left\", \"right\"]",
          "description": "the direction to search toward the edge"
        }
      ],
      "description": "find the first pixel on the edge of a grid or region in the specified direction from a starting position",
      "cues": [
        "if the solution draws lines from interior pixels to the edge of a rectangle or frame",
        "if output features connect scattered pixels to the nearest edge in a given direction"
      ],
      "implementation": [
        "from the starting position, move stepwise in the given direction until reaching the edge of the grid or region",
        "return the first pixel encountered at the edge"
      ],
      "used_in": [
        "5daaa586"
      ]
    },
    "combinations": {
      "name": "combinations",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[tuple[object, object]]",
      "parameters": [
        {
          "name": "objects",
          "typing": "list[object]",
          "description": "the list of objects to generate combinations from"
        },
        {
          "name": "r",
          "typing": "int",
          "description": "the size of each combination (default 2)"
        }
      ],
      "description": "generate all unique unordered pairs (or r-sized combinations) from a list of objects",
      "cues": [
        "if logic compares all pairs of objects for matching or relationship"
      ],
      "implementation": [
        "use itertools.combinations or nested loops to generate all unique pairs"
      ],
      "used_in": [
        "ce602527"
      ]
    },
    "generate rectangles": {
      "name": "generate rectangles",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[grid]",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to enumerate rectangles from"
        },
        {
          "name": "min_width",
          "typing": "int",
          "description": "minimum width of rectangles to generate"
        },
        {
          "name": "min_height",
          "typing": "int",
          "description": "minimum height of rectangles to generate"
        }
      ],
      "description": "enumerate all possible rectangular subregions of a grid with at least the specified minimum width and height",
      "cues": [
        "if the solution involves searching for the largest or smallest rectangle of a certain color in the grid",
        "if the output grid highlights or recolors a contiguous rectangular region"
      ],
      "implementation": [
        "use nested loops to iterate over all possible top-left and bottom-right corners that satisfy the minimum size constraints",
        "extract subarrays corresponding to each rectangle"
      ],
      "used_in": [
        "3eda0437"
      ]
    },
    "unique color": {
      "name": "unique color",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "color",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to extract the row from"
        },
        {
          "name": "row",
          "typing": "int",
          "description": "the index of the row to extract the color from"
        }
      ],
      "description": "extract the unique non-background color from a specified row, assuming only one such color exists",
      "cues": [
        "if a row (e.g., the bottom row) is visually a solid color and used as a reference or baseline in the output logic"
      ],
      "implementation": [
        "use np.unique on the specified row, excluding background color if necessary"
      ],
      "used_in": [
        "3618c87e"
      ]
    },
    "lowest row below": {
      "name": "lowest row below",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "pixel",
          "typing": "object",
          "description": "the pixel whose column to search in"
        },
        {
          "name": "criteria",
          "typing": "selection criteria := Callable[[object], bool]",
          "description": "logic to determine which pixels block falling (e.g., baseline or background)"
        }
      ],
      "description": "find the lowest available row in a column below a given pixel, stopping at the first pixel matching the criteria",
      "cues": [
        "if pixels or objects in the output grid \"fall\" vertically until they reach a baseline or background pixel",
        "if the output grid shows stacking or gravity-like behavior for non-background pixels"
      ],
      "implementation": [
        "iterate from the bottom of the column upward, stopping at the first pixel matching the criteria or at the pixel's current position",
        "for each row below the pixel, check if the criteria is met; if not, continue downward"
      ],
      "used_in": [
        "3618c87e"
      ]
    },
    "grid edges": {
      "name": "grid edges",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[edge]",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid whose edges to enumerate"
        }
      ],
      "description": "generate the four edges of a grid as start and end positions, typically for drawing borders or frames",
      "cues": [
        "if the output grid contains a border or frame drawn along all four sides of the grid",
        "if lines are drawn along the perimeter of the grid in the output"
      ],
      "implementation": [
        "for a grid of shape (height, width), yield four edges: top (from (0,0) to (0,width-1)), bottom (from (height-1,0) to (height-1,width-1)), left (from (0,0) to (height-1,0)), right (from (0,width-1) to (height-1,width-1))",
        "can be implemented as a generator yielding namedtuples or dictionaries with 'start' and 'end' fields"
      ],
      "used_in": [
        "6f8cd79b"
      ]
    },
    "find rectangles from corners": {
      "name": "find rectangles from corners",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[tuple[position, position]]",
      "parameters": [
        {
          "name": "corners",
          "typing": "list[position]",
          "description": "list of positions (pixels) that may serve as rectangle corners"
        }
      ],
      "description": "find all axis-aligned rectangles whose four corners are present in a set of candidate corner positions",
      "cues": [
        "if the input grid contains scattered pixels of a special color (e.g., yellow) and the output grid fills rectangles defined by these as corners",
        "if the output grid contains filled rectangles not present in the input, with boundaries matching input pixel positions"
      ],
      "implementation": [
        "for each pair of distinct corner positions (x1, y1), (x2, y2) with x1 != x2 and y1 != y2, check if the other two corners ((x1, y2), (x2, y1)) are present in the set",
        "avoid duplicate rectangles by canonicalizing corner order (e.g., always use (min_x, min_y), (max_x, max_y))"
      ],
      "used_in": [
        "af902bf9"
      ]
    },
    "rectangle shape": {
      "name": "rectangle shape",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "x_range",
          "typing": "tuple[int, int]",
          "description": "the (inclusive, exclusive) range of x-coordinates (columns) for the rectangle interior"
        },
        {
          "name": "y_range",
          "typing": "tuple[int, int]",
          "description": "the (inclusive, exclusive) range of y-coordinates (rows) for the rectangle interior"
        }
      ],
      "description": "create a filled rectangle grid of the specified ranges, typically used to define the interior region between rectangle corners",
      "cues": [
        "if the output grid fills the area inside a rectangle defined by corner pixels",
        "if the solution logic requires constructing a mask or region for a rectangle interior"
      ],
      "implementation": [
        "create a grid of zeros with shape (y_range[1] - y_range[0], x_range[1] - x_range[0]), then fill all pixels with the intended color",
        "can be used as a sprite for overlaying or as a mask for filling"
      ],
      "used_in": [
        "af902bf9"
      ]
    },
    "vertical line": {
      "name": "vertical line",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "a contiguous object that spans a single column from a starting row to an ending row, often used for drawing or filling",
      "cues": [
        "if output grid rows are filled with a repeating or cyclical color pattern derived from an input row, such as lower rows matching the top row's color sequence"
      ],
      "implementation": [
        "for each row starting from start_row, fill the row with color_sequence[i % len(color_sequence)]"
      ],
      "used_in": [
        "834ec97d",
        "3f7978a0"
      ]
    },
    "orthogonal neighbors": {
      "name": "orthogonal neighbors",
      "kind": "routine",
      "routine_subtype": null,
      "output_typing": "list[object] | list[position]",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the position whose orthogonal neighbors are to be found"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to check for neighbors in"
        }
      ],
      "description": "get the neighboring pixels in the four cardinal (orthogonal) directions from a given position",
      "cues": [
        "if the output grid contains changes to pixels that are directly adjacent (up, down, left, right) to colored pixels",
        "if output features are drawn from a pixel and its four-connected neighbors",
        "if coloring or movement is only allowed in the four cardinal directions"
      ],
      "implementation": [
        "for a given (x, y), orthogonal neighbors are at (x-1, y), (x+1, y), (x, y-1), (x, y+1)",
        "check that neighbor positions are within grid bounds"
      ],
      "used_in": [
        "0ca9ddb6"
      ]
    },
    "diagonal direction": {
      "name": "diagonal direction",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "direction := Literal[\"up-right\", \"down-right\", \"up-left\", \"down-left\"]",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object (or pixel) whose diagonal direction is to be determined"
        }
      ],
      "description": "determine the diagonal direction(s) for line drawing, often used to extend patterns along both diagonals",
      "cues": [
        "if the output grid is a minimal rectangle containing multiple objects",
        "if objects are packed together with no empty space between them in the output",
        "if the region to be cropped is defined by the outermost extent of objects (e.g., lines, bars)",
        "if the crop region is determined by the bounding boxes of boundary objects"
      ],
      "implementation": [
        "find the minimum and maximum x and y coordinates among all object pixels to define the bounding box, then slice the grid accordingly"
      ],
      "used_in": [
        "05269061",
        "ea786f4a",
        "aba27056"
      ]
    },
    "repeat pattern at periodic offsets": {
      "name": "repeat pattern at periodic offsets",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "pattern",
          "typing": "Callable[[position], None]",
          "description": "function to draw or apply the pattern at a given position"
        },
        {
          "name": "offsets",
          "typing": "list[int]",
          "description": "list of offsets at which to repeat the pattern (e.g., multiples of 3)"
        },
        {
          "name": "axis",
          "typing": "axis := Literal[\"x\", \"y\"]",
          "description": "axis along which to apply the offsets"
        },
        {
          "name": "base_position",
          "typing": "position",
          "description": "the reference position to offset from"
        }
      ],
      "description": "repeat a drawing or pattern at every nth position along an axis, creating a periodic/interlaced effect",
      "cues": [
        "if output grid contains repeated features at regular intervals (e.g., every third column or row)",
        "if a motif or line is repeated at periodic spatial offsets from input features"
      ],
      "implementation": [
        "for each offset in offsets, compute the new position along the axis and apply the pattern at that position",
        "can be implemented with a loop over offsets and calls to the pattern function"
      ],
      "used_in": [
        "05269061"
      ]
    },
    "next pixel in direction": {
      "name": "next pixel in direction",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "position",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object or pixel to start from"
        },
        {
          "name": "direction",
          "typing": "direction := Literal[\"up\", \"down\", \"left\", \"right\"]",
          "description": "the direction in which to find the next pixel"
        }
      ],
      "description": "compute the position immediately adjacent to the given object or pixel in the specified direction",
      "cues": [
        "if a line or path starts immediately next to a pixel or object, not including the pixel itself",
        "if a process needs to begin drawing or filling from the neighbor of a reference pixel"
      ],
      "implementation": [
        "for a pixel object, add the direction vector to its (x, y) position",
        "for an object, use its position or bounding box to determine the edge in the given direction, then add the direction vector"
      ],
      "used_in": [
        "d4a91cb9"
      ]
    },
    "horizontal_towards": {
      "name": "horizontal_towards",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "direction := Literal[\"left\", \"right\"]",
      "parameters": [
        {
          "name": "target",
          "typing": "object | position",
          "description": "the target position or object to move towards"
        },
        {
          "name": "source",
          "typing": "object | position",
          "description": "the source position or object to move from"
        }
      ],
      "description": "determine the horizontal direction (\"left\" or \"right\") from the source to the target",
      "cues": [
        "if a line is drawn horizontally from one pixel to another, and the direction depends on their relative positions"
      ],
      "implementation": [
        "compare the x-coordinates of source and target; if target.x > source.x, direction is \"right\", else \"left\""
      ],
      "used_in": [
        "d4a91cb9"
      ]
    },
    "vertical_towards": {
      "name": "vertical_towards",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "direction := Literal[\"up\", \"down\"]",
      "parameters": [
        {
          "name": "target",
          "typing": "object | position",
          "description": "the target position or object to move towards"
        },
        {
          "name": "source",
          "typing": "object | position",
          "description": "the source position or object to move from"
        }
      ],
      "description": "determine the vertical direction (\"up\" or \"down\") from the source to the target",
      "cues": [
        "if a line is drawn vertically from one pixel to another, and the direction depends on their relative positions"
      ],
      "implementation": [
        "compare the y-coordinates of source and target; if target.y > source.y, direction is \"down\", else \"up\""
      ],
      "used_in": [
        "d4a91cb9"
      ]
    },
    "is on bounding box edge criteria": {
      "name": "is on bounding box edge criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the pixel position to check"
        },
        {
          "name": "bounding_box",
          "typing": "object",
          "description": "the bounding box object to check edge against"
        }
      ],
      "description": "check if a pixel is on the edge of a bounding box (e.g., to identify the opening of a container)",
      "cues": [
        "if the output grid contains vertical lines of a single color, especially extending from a pixel to the grid edge",
        "if repeated vertical lines are drawn at regular intervals along a row",
        "if vertical lines are used as boundaries for cropping or region selection"
      ],
      "implementation": null,
      "used_in": [
        "aba27056",
        "d4f3cd78"
      ]
    },
    "find extremal points": {
      "name": "find extremal points",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[position]",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object or set of pixels to find extremal points in"
        }
      ],
      "description": "find the two most distant points (e.g., endpoints) in a set of pixels, often used to identify the edges of an opening or region",
      "cues": [
        "if the solution draws lines from the ends or corners of an opening or region",
        "if output features originate from the most separated points of a boundary"
      ],
      "implementation": [
        "compute pairwise distances between all pixels and select the pair with the maximum distance"
      ],
      "used_in": [
        "aba27056"
      ]
    },
    "stop at non-black": {
      "name": "stop at non-black",
      "kind": "routine",
      "routine_subtype": "stopping criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the position to check"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to check against"
        }
      ],
      "description": "stopping criteria that returns True if the pixel at the given position is not black (background)",
      "cues": [
        "if line drawing or filling stops when encountering a non-background pixel",
        "if lines or patterns extend outward until they hit a colored object or the grid edge"
      ],
      "implementation": [
        "check if grid[position] != 0 (assuming 0 is black/background)"
      ],
      "used_in": [
        "aba27056"
      ]
    },
    "cup (container with opening)": {
      "name": "cup (container with opening)",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "an object that is a container with an open boundary (opening), typically to be filled or have lines drawn from its opening",
      "cues": [
        "presence of lines or patterns extending in diagonal directions (up-right, down-right, up-left, down-left) from a pixel or object in the output grid",
        "diagonal symmetry or repeated diagonal patterns in the output grid"
      ],
      "implementation": [
        {
          "represent diagonal directions using direction vectors": "(1,1), (1,-1), (-1,1), (-1,-1) corresponding to up-right, down-right, up-left, and down-left"
        }
      ],
      "used_in": [
        "aba27056",
        "d4f3cd78"
      ]
    },
    "opening of container": {
      "name": "opening of container",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "the set of pixels on the boundary of a container object that are not enclosed, forming the \"opening\" through which filling or extension occurs",
      "cues": [
        "if lines or features are drawn from a contiguous edge of a container object",
        "if the output grid extends features from a gap in a closed region"
      ],
      "implementation": [],
      "used_in": [
        "aba27056"
      ]
    },
    "distance to grid edge": {
      "name": "distance to grid edge",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the starting position"
        },
        {
          "name": "direction",
          "typing": "direction := Literal[\"up\", \"down\", \"left\", \"right\", \"up-right\", \"up-left\", \"down-right\", \"down-left\"]",
          "description": "the direction to measure toward the grid edge"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to measure within"
        }
      ],
      "description": "compute the number of steps from a position to the grid edge in the specified direction",
      "cues": [
        "if lines or regions are extended from a pixel to the grid border",
        "if the extent of a drawn feature is determined by the distance to the grid edge"
      ],
      "implementation": [
        "incrementally move in the given direction from the position until the edge of the grid is reached, counting steps"
      ],
      "used_in": [
        "b527c5c6"
      ]
    },
    "has only one nonblack color": {
      "name": "has only one nonblack color",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to check"
        }
      ],
      "description": "condition on whether an object contains exactly one non-black color",
      "cues": [
        "if an object in the grid is monochrome except for black/background pixels",
        "if the solution distinguishes between objects with a single color and those with multiple colors"
      ],
      "implementation": [
        "extract the set of unique colors in the object, remove black (0), and check if the length is 1"
      ],
      "used_in": [
        "6ecd11f4"
      ]
    },
    "not": {
      "name": "not",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "Callable[[object], bool]",
      "parameters": [
        {
          "name": "criteria",
          "typing": "Callable[[object], bool]",
          "description": "the criteria to negate"
        }
      ],
      "description": "returns a selection criteria that negates the result of another criteria",
      "cues": [
        "if objects are selected by being the opposite of a certain property (e.g., not monochrome)"
      ],
      "implementation": [
        "return a function that returns not criteria(target)"
      ],
      "used_in": [
        "6ecd11f4",
        "aabf363d",
        "2204b7a8",
        "b782dc8a",
        "2bcee788"
      ]
    },
    "crop object": {
      "name": "crop object",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid | object",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to crop to its bounding box"
        },
        {
          "name": "background",
          "typing": "color",
          "description": "color to treat as background and exclude from the cropped region (optional)"
        }
      ],
      "description": "crop an object to its minimal bounding box, returning the cropped grid or object",
      "cues": [
        "if the solution requires identifying pixels on the perimeter of a region or object",
        "if lines or features are drawn from the edge of a region or container"
      ],
      "implementation": [
        "compare the pixel's coordinates to the min/max x and y of the bounding box"
      ],
      "used_in": [
        "6ecd11f4",
        "8d5021e8",
        "f8a8fe49",
        "3f7978a0",
        "8e5a5113",
        "44d8ac46",
        "137eaa0f",
        "57aa92db"
      ]
    },
    "resize object": {
      "name": "resize object",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid | object",
      "parameters": [
        {
          "name": "object",
          "typing": "grid | object",
          "description": "the object or grid to resize"
        },
        {
          "name": "new_shape",
          "typing": "dimensions := tuple[int, int]",
          "description": "the desired output shape (height, width)"
        },
        {
          "name": "method",
          "typing": "str",
          "description": "the resizing method (e.g., \"nearest_neighbor\", \"block_sampling\")"
        }
      ],
      "description": "resize an object or grid to new dimensions, optionally using a specified method",
      "cues": [
        "if an object in the input grid appears at a different size in the output, especially scaled down or up to match another object's size",
        "if a large object is used as a mask or template for a smaller region"
      ],
      "implementation": [
        "for downscaling, use block sampling or nearest neighbor to map larger regions to single pixels",
        "for upscaling, repeat pixels or interpolate as needed"
      ],
      "used_in": [
        "6ecd11f4"
      ]
    },
    "mask object": {
      "name": "mask object",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "object",
          "typing": "grid | object",
          "description": "the object or grid to apply the mask to"
        },
        {
          "name": "mask",
          "typing": "grid",
          "description": "the mask grid; must be the same shape as the object"
        },
        {
          "name": "mask_value",
          "typing": "int",
          "description": "the value in the mask that indicates masking (default 0)"
        },
        {
          "name": "fill_value",
          "typing": "int",
          "description": "the value to assign to masked-out pixels (default 0)"
        }
      ],
      "description": "apply a mask to an object or grid, setting pixels to fill_value where the mask equals mask_value, and keeping original pixels elsewhere",
      "cues": [
        "if the output grid is a copy of an object with some pixels zeroed out according to a mask pattern",
        "if a pattern is used to erase or keep pixels in another object"
      ],
      "implementation": [
        "for each pixel, if mask at that position equals mask_value, set output to fill_value; else, copy from object"
      ],
      "used_in": [
        "6ecd11f4"
      ]
    },
    "all pairs": {
      "name": "all pairs",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[tuple[object, object]]",
      "parameters": [
        {
          "name": "objects",
          "typing": "list[object]",
          "description": "the list of objects to generate pairs from"
        }
      ],
      "description": "generate all unique unordered pairs from a list of objects, typically used to compare or process relationships between objects in a row or column",
      "cues": [
        "if the solution logic compares all pairs of objects in a row or column for matching properties",
        "if filling or connecting occurs between pairs of matching objects in a sequence"
      ],
      "implementation": [
        "use itertools.combinations(objects, 2) to generate all unique pairs"
      ],
      "used_in": [
        "06df4c85"
      ]
    },
    "cells between": {
      "name": "cells between",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[object]",
      "parameters": [
        {
          "name": "sequence",
          "typing": "list[object]",
          "description": "the ordered list of objects (e.g., cells in a row or column)"
        },
        {
          "name": "object1",
          "typing": "object",
          "description": "the first object delimiting the range"
        },
        {
          "name": "object2",
          "typing": "object",
          "description": "the second object delimiting the range"
        }
      ],
      "description": "extract the objects that are strictly between two given objects in an ordered sequence (e.g., cells between two matching-colored cells in a row or column)",
      "cues": [
        "if all objects or regions between two matching features are recolored or filled in the output grid",
        "if the output grid shows contiguous filling between pairs of objects with the same property"
      ],
      "implementation": [
        "find the indices of object1 and object2 in the sequence, and return all objects between them (exclusive)",
        "ensure ordering is handled (object1 may precede or follow object2)"
      ],
      "used_in": [
        "06df4c85"
      ]
    },
    "find divider line color": {
      "name": "find divider line color",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "color",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to analyze for divider lines"
        }
      ],
      "description": "identify the color used for divider lines that partition the grid into regions or cells",
      "cues": [
        "if the grid is visually partitioned by lines of a single color",
        "if regions or cells are separated by a consistent color not used elsewhere"
      ],
      "implementation": [
        "for each unique color in the grid, check if it forms uninterrupted lines spanning rows or columns; select the color that does so"
      ],
      "used_in": [
        "06df4c85"
      ]
    },
    "transpose": {
      "name": "transpose",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[list[object]]",
      "parameters": [
        {
          "name": "grid",
          "typing": "list[list[object]]",
          "description": "a 2D grid or list of lists to transpose (swap rows and columns)"
        }
      ],
      "description": "transpose a 2D grid or list of lists, converting rows to columns and vice versa",
      "cues": [
        "if the solution logic processes both rows and columns in a similar fashion",
        "if the same operation is applied along both axes of a region grid"
      ],
      "implementation": [
        "use zip(*grid) or equivalent to transpose the structure"
      ],
      "used_in": [
        "06df4c85"
      ]
    },
    "count shape features": {
      "name": "count shape features",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "shape",
          "typing": "shape := Any",
          "description": "the shape representation of the object (e.g., pixel mask, contour, or list of positions)"
        },
        {
          "name": "feature",
          "typing": "str",
          "description": "the type of shape feature to count (e.g., \"bend\", \"endpoint\", \"corner\")"
        }
      ],
      "description": "count the number of specified features (such as bends or corners) present in an object's shape",
      "cues": [
        "if objects are recolored or categorized based on geometric properties such as number of corners, bends, or endpoints",
        "if output grid colors correspond to the number of turns or L-shaped corners in input objects"
      ],
      "implementation": [
        "for \"bend\", traverse the object's contour or pixel sequence and count positions where the direction changes (i.e., L-shaped turns)",
        "can use connectivity analysis or chain code to detect bends in the object's outline",
        "for 4-connected objects, a bend occurs where two consecutive segments are not collinear"
      ],
      "used_in": [
        "e509e548"
      ]
    },
    "map value": {
      "name": "map value",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "Any",
      "parameters": [
        {
          "name": "value",
          "typing": "Any",
          "description": "the value to map (e.g., integer feature count)"
        },
        {
          "name": "mapping",
          "typing": "dict[Any, Any]",
          "description": "a dictionary mapping input values to output values (e.g., bend count to color)"
        }
      ],
      "description": "map an input value to an output value using a fixed mapping dictionary",
      "cues": [
        "if output grid colors or features are assigned based on a lookup table or fixed mapping from an input property",
        "if a small set of possible input values are mapped to specific output values"
      ],
      "implementation": [
        "use Python's dict lookup: mapping[value]"
      ],
      "used_in": [
        "e509e548"
      ]
    },
    "is hollow rectangle": {
      "name": "is hollow rectangle",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to check for being a hollow rectangle"
        },
        {
          "name": "background",
          "typing": "color",
          "description": "the color considered as background inside the rectangle (optional; default is 0)"
        }
      ],
      "description": "condition on whether an object is a hollow rectangle, i.e., has a rectangular border and an interior filled with background color",
      "cues": [
        "if the grid contains rectangular outlines with empty (background) interiors",
        "if the output grid fills only the interiors of hollow rectangles",
        "if rectangles in the input grid are not solid but have a border and empty center"
      ],
      "implementation": [
        "crop the object to its bounding box and check that the interior (excluding the border) is all background color",
        "check that the object forms a rectangle by verifying its bounding box and border pixels"
      ],
      "used_in": [
        "e73095fd"
      ]
    },
    "has grey adjacent to corners": {
      "name": "has grey adjacent to corners",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the rectangle object to check"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to check adjacency in"
        }
      ],
      "description": "condition on whether any of the rectangle's corner pixels have a grey pixel adjacent (4- or 8-connected) in the grid",
      "cues": [
        "if rectangles in the input grid have lines or features attached at their corners, and these are treated differently in the output",
        "if only rectangles without attached lines at corners are filled in the output grid"
      ],
      "implementation": [
        "for each corner of the object's bounding box, check the neighboring pixels in the grid for the presence of grey",
        "use 4- or 8-connectivity as appropriate for adjacency"
      ],
      "used_in": [
        "e73095fd"
      ]
    },
    "edge pixels": {
      "name": "edge pixels",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[object]",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to search for edge pixels in"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color to search for"
        },
        {
          "name": "object",
          "typing": "object",
          "description": "the object to extract edge pixels from"
        }
      ],
      "description": "extract all pixel objects in a grid of a given color that are located on the edge of the grid",
      "cues": [
        "if the grid contains a region bounded on all sides except one (the opening)",
        "if the output grid fills a region inside a container and extends features from its open edge"
      ],
      "implementation": null,
      "used_in": [
        "f15e1fac",
        "2204b7a8"
      ]
    },
    "find edge with color": {
      "name": "find edge with color",
      "kind": "routine",
      "routine_subtype": null,
      "output_typing": "Literal[\"top\", \"bottom\", \"left\", \"right\"]",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to search"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color to search for on the edges"
        }
      ],
      "description": "find which edge(s) of the grid contain at least one pixel of the specified color",
      "cues": [
        "if the direction of a process depends on which edge contains a certain colored pixel",
        "if colored pixels only appear on a single edge in the input grid"
      ],
      "implementation": [
        "check each edge (first/last row and column) for the presence of the specified color"
      ],
      "used_in": [
        "f15e1fac"
      ]
    },
    "get flow direction": {
      "name": "get flow direction",
      "kind": "routine",
      "routine_subtype": null,
      "output_typing": "direction",
      "parameters": [
        {
          "name": "start_edge",
          "typing": "Literal[\"top\", \"bottom\", \"left\", \"right\"]",
          "description": "the edge where the flow starts"
        },
        {
          "name": "end_edge",
          "typing": "Literal[\"top\", \"bottom\", \"left\", \"right\"]",
          "description": "the edge toward which the flow proceeds"
        }
      ],
      "description": "determine the direction in which to \"flow\" or propagate from a starting edge toward the opposite edge, possibly based on the positions of colored pixels",
      "cues": [
        "if a process extends from one edge of the grid toward the opposite edge",
        "if the direction of propagation is determined by the positions of colored pixels on the grid edges"
      ],
      "implementation": [
        "map edge pairs to cardinal directions (e.g., \"left\" to \"right\" => \"right\")"
      ],
      "used_in": [
        "f15e1fac"
      ]
    },
    "get push direction": {
      "name": "get push direction",
      "kind": "routine",
      "routine_subtype": null,
      "output_typing": "direction",
      "parameters": [
        {
          "name": "edge",
          "typing": "Literal[\"top\", \"bottom\", \"left\", \"right\"]",
          "description": "the edge or reference from which to push away"
        }
      ],
      "description": "determine the direction to \"push\" a process away from a reference edge or set of pixels, typically to avoid or step aside from an obstacle",
      "cues": [
        "if a process is deflected or offset when encountering a row or column containing a special color",
        "if the output grid shows a \"bend\" or offset when a path aligns with a colored pixel"
      ],
      "implementation": [
        "map the reference edge to the direction away from it (e.g., \"top\" => \"down\")"
      ],
      "used_in": [
        "f15e1fac"
      ]
    },
    "in bounds": {
      "name": "in bounds",
      "kind": "routine",
      "routine_subtype": null,
      "output_typing": "bool",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the position to check"
        },
        {
          "name": "grid_shape",
          "typing": "tuple[int, int]",
          "description": "the shape of the grid (height, width)"
        }
      ],
      "description": "check if a given position is within the valid bounds of the grid",
      "cues": [
        "if the output grid or a sprite is a tight crop of an object from the input grid",
        "if a region or subregion of the output grid is extracted for further manipulation, such as flipping, tiling, or other transformations",
        "if the output grid contains only the content inside a frame or border, possibly with the border width trimmed",
        "if a contiguous subregion of the input grid, bounded by lines, colored markers, or special pixels (e.g., vertical bars, corner markers), is used in the output"
      ],
      "implementation": [
        "find the minimum and maximum x and y coordinates of the object's pixels and slice the grid accordingly",
        "allow specifying the crop region via bounding boxes, explicit coordinates, or by referencing special markers",
        "optionally mask out or ignore pixels of the background color if specified"
      ],
      "used_in": [
        "f15e1fac",
        "0962bcdd"
      ]
    },
    "set pixel": {
      "name": "set pixel",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to modify"
        },
        {
          "name": "position",
          "typing": "position",
          "description": "the position of the pixel to set"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color to assign to the pixel"
        }
      ],
      "description": "set the color of a specific pixel in a grid, overwriting its previous value",
      "cues": [
        "if the solution logic starts from or processes only colored pixels on the grid edge",
        "if output features originate from the border of the input grid",
        "if distance, adjacency, coloring, or assignment depends on proximity to the edge of a region, object, or the grid itself"
      ],
      "implementation": [
        "for each pixel in the grid or object, if its color matches and its position is on the grid edge, or if any neighboring position is not part of the object, include it as an edge pixel"
      ],
      "used_in": [
        "aabf363d",
        "11852cab",
        "0962bcdd",
        "31aa019c"
      ]
    },
    "corner pixel": {
      "name": "corner pixel",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "a pixel located at one of the four corners of the grid, often used as a marker or to determine a color for further processing",
      "cues": [
        "if a single pixel in the corner of the input grid is missing or has a special color in the output",
        "if the color of a corner pixel is used elsewhere in the output grid"
      ],
      "implementation": [],
      "used_in": [
        "aabf363d"
      ]
    },
    "tiling of mirrored sprites": {
      "name": "tiling of mirrored sprites",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "a grid composed of repeated copies of an input sprite, where each copy may be a reflection (horizontal, vertical, or both), arranged in a regular pattern (e.g., 2x3 grid)",
      "cues": [
        "if the output grid is larger than the input and consists of repeated, mirrored, or flipped versions of the input object",
        "if the output grid is constructed by assembling mirrored tiles of an input sprite in a regular arrangement"
      ],
      "implementation": [],
      "used_in": [
        "8d5021e8"
      ]
    },
    "is filled rectangle": {
      "name": "is filled rectangle",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to check for being a filled rectangle"
        }
      ],
      "description": "condition on whether an object is a solid (filled) rectangle, i.e., its bounding box is completely filled with a single color and contains no holes or gaps.",
      "cues": [
        "if an object in the input grid is a solid rectangle that occludes or covers part of another object",
        "if the output grid is missing a rectangular region present in the input grid"
      ],
      "implementation": [
        "crop the object to its bounding box and check that all pixels are the same color and there are no background pixels inside",
        "check that the object's area matches the area of its bounding box"
      ],
      "used_in": [
        "3345333e"
      ]
    },
    "remove object": {
      "name": "remove object",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to remove the object from"
        },
        {
          "name": "object",
          "typing": "object",
          "description": "the object to remove"
        }
      ],
      "description": "remove an object from the grid, setting its pixels to the background color",
      "cues": [
        "if an object present in the input grid is missing in the output grid, revealing previously occluded content",
        "if a rectangular region is erased or deleted in the output"
      ],
      "implementation": [
        "set all pixels of the object in the grid to the background color (usually 0)"
      ],
      "used_in": [
        "3345333e"
      ]
    },
    "find mirror symmetry": {
      "name": "find mirror symmetry",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[symmetry := Callable[[position], position]]",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to analyze for mirror symmetry"
        },
        {
          "name": "ignore_colors",
          "typing": "list[color]",
          "description": "colors to ignore when checking for symmetry (optional)"
        }
      ],
      "description": "detect mirror symmetry transformations (e.g., vertical, horizontal) present in a grid, optionally ignoring specified colors",
      "cues": [
        "if the output grid restores symmetry that is broken in the input grid by an occluding object",
        "if the output grid is symmetric along an axis, but the input grid is not due to an occlusion"
      ],
      "implementation": [
        "for each axis, compare the grid to its reflection along that axis, ignoring specified colors",
        "return a list of symmetry functions (e.g., lambda pos: (pos[0], width-1-pos[1]) for vertical symmetry)"
      ],
      "used_in": [
        "3345333e"
      ]
    },
    "not_equal": {
      "name": "not_equal",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "Callable[[object], bool]",
      "parameters": [
        {
          "name": "reference",
          "typing": "object",
          "description": "the object to compare against"
        }
      ],
      "description": "condition on whether a target object is not equal to a reference object",
      "cues": [
        "if all objects except one are selected for further processing",
        "if the solution logic distinguishes a central or special object from others"
      ],
      "implementation": [
        "for each object, compare to the reference object using identity or equality of properties (e.g., position, color, shape)"
      ],
      "used_in": [
        "045e512c"
      ]
    },
    "argmax_displacement": {
      "name": "argmax_displacement",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "tuple[int, int]",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to move"
        },
        {
          "name": "target",
          "typing": "object",
          "description": "the object to overlap"
        },
        {
          "name": "criteria",
          "typing": "Callable[[object, object, tuple[int, int]], bool]",
          "description": "logic to determine if the overlap is acceptable (e.g., full overlap)"
        },
        {
          "name": "search_space",
          "typing": "list[tuple[int, int]]",
          "description": "possible displacements to consider"
        }
      ],
      "description": "find the displacement vector that, when applied to the object, maximizes a criterion (e.g., full overlap with target), preferring the largest-magnitude displacement",
      "cues": [
        "if an object is repeatedly moved in a fixed direction and distance to overlap other objects",
        "if the solution requires maximizing the extent of movement while achieving a spatial relationship"
      ],
      "implementation": [
        "for each displacement in the search space, check if moving the object by that displacement satisfies the criteria; select the one with the largest magnitude"
      ],
      "used_in": [
        "045e512c"
      ]
    },
    "full_overlap": {
      "name": "full_overlap",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to move"
        },
        {
          "name": "target",
          "typing": "object",
          "description": "the object to overlap"
        },
        {
          "name": "displacement",
          "typing": "tuple[int, int]",
          "description": "the displacement vector to apply"
        }
      ],
      "description": "condition on whether moving the object by the given displacement results in it fully overlapping the target object",
      "cues": [
        "if the solution logic requires one object to completely cover another",
        "if movement or tiling is based on achieving exact spatial overlap"
      ],
      "implementation": [
        "after applying the displacement, check if all pixels of the moved object coincide with the target object's pixels"
      ],
      "used_in": [
        "045e512c"
      ]
    },
    "displacement_direction": {
      "name": "displacement_direction",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "direction",
      "parameters": [
        {
          "name": "displacement",
          "typing": "tuple[int, int]",
          "description": "the displacement vector"
        }
      ],
      "description": "extract the direction from a displacement vector (e.g., (dx, dy) -> direction label)",
      "cues": [
        "if repeated movement is along a fixed direction determined by a displacement"
      ],
      "implementation": [
        "map the sign of dx and dy to a direction label (e.g., (1,0) -> \"right\", (0,1) -> \"down\", etc.)"
      ],
      "used_in": [
        "045e512c"
      ]
    },
    "displacement_magnitude": {
      "name": "displacement_magnitude",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "displacement",
          "typing": "tuple[int, int]",
          "description": "the displacement vector"
        }
      ],
      "description": "compute the magnitude (step size) of a displacement vector for use as the gap in tiling",
      "cues": [
        "if repeated movement is by a fixed number of rows/columns per step"
      ],
      "implementation": [
        "use max(abs(dx), abs(dy)) or another norm as appropriate"
      ],
      "used_in": [
        "045e512c"
      ]
    },
    "detect rotational symmetry": {
      "name": "detect rotational symmetry",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "symmetry := Callable[[position], position] | object",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to analyze for rotational symmetry"
        },
        {
          "name": "ignore_colors",
          "typing": "list[color]",
          "description": "colors to ignore when detecting symmetry (optional)"
        }
      ],
      "description": "detect the presence and properties of rotational symmetry in a grid, including the center of rotation, angle, and symmetry order.",
      "cues": [
        "if the output grid is a completed or restored version of a rotationally symmetric pattern in the input grid",
        "if missing or incomplete regions are filled in the output grid to achieve rotational symmetry",
        "if the input grid exhibits partial rotational symmetry, and the output grid is fully symmetric",
        "if colored pixels in the output grid appear at positions related by rotation around a central point"
      ],
      "implementation": [
        "analyze the grid to find the center of symmetry and the smallest angle of rotation that maps the pattern onto itself",
        "can use geometric analysis of colored pixel positions, possibly ignoring background pixels",
        "return an object with fields: center, angle, order (number of symmetry axes), and a function to rotate positions"
      ],
      "used_in": [
        "11852cab"
      ]
    },
    "append row": {
      "name": "append row",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to append a row to"
        },
        {
          "name": "row",
          "typing": "list[color]",
          "description": "the row to append (must match grid width)"
        }
      ],
      "description": "append a new row to the bottom of a grid, increasing its height by one",
      "cues": [
        "if the output grid is taller than the input grid and rows are added sequentially",
        "if the output grid is constructed by stacking rows derived from previous rows"
      ],
      "implementation": [
        "use numpy.vstack or concatenate the new row to the grid",
        "ensure the new row has the same width as the grid"
      ],
      "used_in": [
        "bbc9ae5d"
      ]
    },
    "rightmost pixel": {
      "name": "rightmost pixel",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "row",
          "typing": "list[color]",
          "description": "the row to search in"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color to search for"
        }
      ],
      "description": "find the index of the rightmost pixel of the specified color in a row",
      "cues": [
        "if the output logic depends on extending or modifying a colored segment in a row",
        "if the rightmost extent of a colored region is incremented in each row"
      ],
      "implementation": [
        "iterate from the end of the row backwards to find the first occurrence of the color",
        "can use numpy.where or reversed() with enumerate"
      ],
      "used_in": [
        "bbc9ae5d"
      ]
    },
    "extend colored segment": {
      "name": "extend colored segment",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "list[color]",
      "parameters": [
        {
          "name": "row",
          "typing": "list[color]",
          "description": "the row to extend"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color to use for extension"
        },
        {
          "name": "position",
          "typing": "int",
          "description": "the index to set as the new rightmost colored pixel"
        }
      ],
      "description": "extend a contiguous segment of colored pixels in a row by setting the specified position to the color",
      "cues": [
        "if each row in the output grid has a colored segment that is one pixel longer than the previous row",
        "if the output grid shows a growing bar or region along a row or column"
      ],
      "implementation": [
        "copy the row, set row[position] = color",
        "ensure that the segment remains contiguous (i.e., only extend by one at a time)"
      ],
      "used_in": [
        "bbc9ae5d"
      ]
    },
    "pattern-to-color mapping": {
      "name": "pattern-to-color mapping",
      "kind": "routine",
      "routine_subtype": "color scheme",
      "output_typing": "color",
      "parameters": [
        {
          "name": "pattern",
          "typing": "object",
          "description": "the pattern object to assign a color to"
        },
        {
          "name": "color_map",
          "typing": "dict[object, color]",
          "description": "mapping from pattern templates to colors"
        }
      ],
      "description": "assign a color to a pattern object by matching it to a known template and using a fixed mapping",
      "cues": [
        "if each input pattern is associated with a unique color in the output grid",
        "if output grid rows are colored according to the identity of input patterns",
        "if a fixed set of templates or patterns are mapped to specific colors"
      ],
      "implementation": [
        "compare the input pattern to each template in color_map, using shape or pixel-wise comparison",
        "assign the corresponding color if a match is found"
      ],
      "used_in": [
        "995c5fa3"
      ]
    },
    "split_vertical_center": {
      "name": "split_vertical_center",
      "kind": "routine",
      "routine_subtype": "object splitting scheme",
      "output_typing": "list[object]",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to split"
        }
      ],
      "description": "split an object into left and right halves along its vertical center axis",
      "cues": [
        "if a pattern or region is divided into left/right halves for mirroring or placement"
      ],
      "implementation": [
        "compute the vertical center of the object's bounding box and slice into left/right halves"
      ],
      "used_in": [
        "f8a8fe49"
      ]
    },
    "split_horizontal_center": {
      "name": "split_horizontal_center",
      "kind": "routine",
      "routine_subtype": "object splitting scheme",
      "output_typing": "list[object]",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to split"
        }
      ],
      "description": "split an object into top and bottom halves along its horizontal center axis",
      "cues": [
        "if a pattern or region is divided into top/bottom halves for mirroring or placement"
      ],
      "implementation": [
        "compute the horizontal center of the object's bounding box and slice into top/bottom halves"
      ],
      "used_in": [
        "f8a8fe49"
      ]
    },
    "aligned_inside": {
      "name": "aligned_inside",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "position",
      "parameters": [
        {
          "name": "frame",
          "typing": "object",
          "description": "the frame or container object to align within"
        },
        {
          "name": "object",
          "typing": "object",
          "description": "the object to be placed inside the frame (optional; if not provided, aligns a standard size)"
        }
      ],
      "description": "compute the position to place an object so it is centered or aligned within a frame or container",
      "cues": [
        "if the output grid places patterns or sprites exactly inside frames or containers, possibly after transformation",
        "if alignment within a frame is required for correct placement"
      ],
      "implementation": [
        "compute the anchor position so that the object's bounding box is centered or aligned within the frame's interior region",
        "may use the difference in size between the frame's interior and the object to determine the offset"
      ],
      "used_in": [
        "f8a8fe49"
      ]
    },
    "crop region between lines": {
      "name": "crop region between lines",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to crop from"
        },
        {
          "name": "left_line",
          "typing": "object",
          "description": "the left boundary object (e.g., vertical line)"
        },
        {
          "name": "right_line",
          "typing": "object",
          "description": "the right boundary object (e.g., vertical line)"
        },
        {
          "name": "y_extension",
          "typing": "tuple[int, int]",
          "description": "number of pixels to extend above and below the bounding box (optional; default (0,0))"
        }
      ],
      "description": "crop the region of the grid bounded by two vertical lines, optionally extending the region above and below the lines",
      "cues": [
        "if the output grid is a subregion defined by two parallel lines (e.g., vertical bars) and possibly extended beyond their bounding boxes",
        "if the crop region is not strictly the bounding box of objects, but includes extra rows or columns"
      ],
      "implementation": [
        "use the x-coordinates of the left and right lines as crop boundaries",
        "use the min and max y-coordinates of the lines, extending by y_extension as needed",
        "slice the grid accordingly to extract the region"
      ],
      "used_in": [
        "3f7978a0"
      ]
    },
    "min_distance": {
      "name": "min_distance",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "position1",
          "typing": "position",
          "description": "the position of the first pixel or object"
        },
        {
          "name": "positions2",
          "typing": "list[position]",
          "description": "the list of positions (e.g., edge pixels of an object) to compute distance to"
        }
      ],
      "description": "compute the minimum Manhattan distance from a position to a set of positions",
      "cues": [
        "if coloring or assignment is based on proximity to the nearest object or feature in the grid",
        "if output grid recolors pixels to match the nearest object or line"
      ],
      "implementation": [
        "for each position in positions2, compute the Manhattan distance to position1 and return the minimum",
        "can use numpy broadcasting or a loop for efficiency"
      ],
      "used_in": [
        "2204b7a8"
      ]
    },
    "flood fill alternating": {
      "name": "flood fill alternating",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "start",
          "typing": "position",
          "description": "the starting position for the flood fill"
        },
        {
          "name": "colors",
          "typing": "list[color]",
          "description": "the sequence of colors to alternate when filling"
        },
        {
          "name": "path_criteria",
          "typing": "selection criteria := Callable[[object], bool]",
          "description": "logic to determine which pixels are considered part of the path to fill (e.g., is_color(black))"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to perform the flood fill on"
        }
      ],
      "description": "flood fill from a starting position, coloring reachable path pixels with alternating colors from the provided list, switching color at each step or layer.",
      "cues": [
        "if output grid shows a path or region filled with alternating colors, starting from indicator pixels",
        "if a maze or path is colored with two or more colors in an alternating fashion, spreading from one or more sources",
        "if the output grid contains a colored trail or region that alternates between two colors along a path"
      ],
      "implementation": [
        "perform a BFS or DFS from the start position, for each step or layer, assign the next color in the sequence to the pixel",
        "use a queue to track positions and the current color index; for each neighbor satisfying path_criteria, enqueue it with the next color",
        "can alternate colors by depth (distance from start) or by step along the path"
      ],
      "used_in": [
        "b782dc8a"
      ]
    },
    "other_indicator": {
      "name": "other_indicator",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "object",
      "parameters": [
        {
          "name": "indicator_pixels",
          "typing": "list[object]",
          "description": "the list of indicator pixel objects"
        },
        {
          "name": "indicator",
          "typing": "object",
          "description": "the current indicator object"
        }
      ],
      "description": "returns the other indicator object from a list of two, given one of them",
      "cues": [
        "if alternating coloring or logic depends on both indicator pixels and their colors"
      ],
      "implementation": [
        "given a list of two objects, return the one that is not equal to the provided indicator"
      ],
      "used_in": [
        "b782dc8a"
      ]
    },
    "occurs_exactly_once": {
      "name": "occurs_exactly_once",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "color",
          "typing": "color",
          "description": "the color to check for unique occurrence"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to check within"
        }
      ],
      "description": "condition on whether a color appears exactly once in the grid",
      "cues": [
        "if the output grid highlights or processes a pixel that is the only one of its color in the input"
      ],
      "implementation": [
        "count the number of times the color appears in the grid; return True if count == 1"
      ],
      "used_in": [
        "31aa019c"
      ]
    },
    "find pixel": {
      "name": "find pixel",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "object",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to search for the pixel in"
        },
        {
          "name": "criteria",
          "typing": "selection criteria := Callable[[object], bool]",
          "description": "logic to select the pixel (e.g., has_color)"
        }
      ],
      "description": "extract the position (object) of a pixel in the grid matching the given criteria",
      "cues": [
        "if the output grid is constructed by referencing or centering features on a specific pixel in the input"
      ],
      "implementation": [
        "iterate over all positions in the grid, return the position where criteria is True"
      ],
      "used_in": [
        "31aa019c"
      ]
    },
    "generate all rotations and flips": {
      "name": "generate all rotations and flips",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[object]",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to generate all rotated and flipped versions of"
        }
      ],
      "description": "generate all unique rotations (by 90 degrees) and mirror flips (horizontal, vertical) of an object",
      "cues": [
        "if objects in the output grid appear in multiple orientations or mirrored versions compared to the input",
        "if a matching or placement process tries all possible orientations of an object"
      ],
      "implementation": [
        "use numpy.rot90 and numpy.flip to generate all 4 rotations and both flips, removing duplicates if necessary"
      ],
      "used_in": [
        "0e206a2e"
      ]
    },
    "all positions within grid": {
      "name": "all positions within grid",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "list[position]",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to be placed"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid within which to enumerate valid anchor positions"
        }
      ],
      "description": "generate all positions where an object can be placed within a grid such that it fits entirely inside",
      "cues": [
        "if the solution tries all possible placements of an object within a region or grid",
        "if the output grid is constructed by fitting pieces into a container or matching colored regions"
      ],
      "implementation": [
        "slide the object's bounding box over all positions where it remains within the grid's bounds"
      ],
      "used_in": [
        "0e206a2e"
      ]
    },
    "color match at overlap criteria": {
      "name": "color match at overlap criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object or sprite to be placed"
        },
        {
          "name": "position",
          "typing": "position",
          "description": "the position at which to place the object"
        },
        {
          "name": "mask",
          "typing": "grid",
          "description": "the target mask or grid to match colors against"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid representing the current placement state"
        }
      ],
      "description": "condition on whether, at overlapping pixels between the placed object and the mask, the colors match (ignoring background)",
      "cues": [
        "if the solution only allows placements where overlapping colored pixels match exactly",
        "if output objects must cover target regions without color mismatches"
      ],
      "implementation": [
        "for each overlapping pixel where both object and mask are non-background, check that the colors are equal"
      ],
      "used_in": [
        "0e206a2e"
      ]
    },
    "pixel cluster": {
      "name": "pixel cluster",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "a small object consisting of a contiguous group of a few pixels (e.g., <= 4), often serving as a target to be covered or matched",
      "cues": [
        "if the grid contains small clusters of colored pixels that are targets for covering or matching by larger objects",
        "if the output grid is constructed by aligning or overlaying larger objects onto small colored regions"
      ],
      "implementation": [],
      "used_in": [
        "0e206a2e"
      ]
    },
    "large object": {
      "name": "large object",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "an object with more than a threshold number of pixels (e.g., > 4), typically used as a movable or transformable piece",
      "cues": [
        "if the grid contains objects of varying sizes and only the larger ones are manipulated or moved in the output",
        "if large objects are used to cover or match smaller pixel clusters in the output grid"
      ],
      "implementation": [],
      "used_in": [
        "0e206a2e"
      ]
    },
    "all_pixels_not_in criteria": {
      "name": "all_pixels_not_in criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to check"
        },
        {
          "name": "exclude",
          "typing": "list[color]",
          "description": "list of colors that must not appear in the object"
        }
      ],
      "description": "condition on whether all pixels in an object are not in a given list of excluded colors",
      "cues": [
        "if an object is selected for not containing any of a set of colors (e.g., black, green)",
        "if a color guide or palette is present and is distinguished by not containing certain colors"
      ],
      "implementation": [
        "extract the set of unique colors in the object and check that none are in the exclude list"
      ],
      "used_in": [
        "7c008303"
      ]
    },
    "split into quadrants": {
      "name": "split into quadrants",
      "kind": "routine",
      "routine_subtype": "object splitting scheme",
      "output_typing": "list[object]",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to split into quadrants"
        }
      ],
      "description": "split an object into four equal-sized quadrants (top-left, top-right, bottom-left, bottom-right)",
      "cues": [
        "if a pattern or region is divided into four equal parts for recoloring or processing",
        "if output grid shows quadrant-wise transformation or coloring"
      ],
      "implementation": [
        "compute the vertical and horizontal midpoints of the object's bounding box and slice into four subregions",
        "ensure that each quadrant is the same size (or as close as possible if dimensions are odd)"
      ],
      "used_in": [
        "7c008303"
      ]
    },
    "combine objects": {
      "name": "combine objects",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "objects",
          "typing": "list[object]",
          "description": "the list of objects to combine into a single grid"
        }
      ],
      "description": "combine a list of objects (e.g., quadrants) into a single grid, placing each at its original relative position",
      "cues": [
        "if a pattern is split into parts for processing and then reassembled",
        "if output grid is constructed by merging transformed regions back together"
      ],
      "implementation": [
        "create a blank grid of the appropriate size and copy each object's pixels into their corresponding positions",
        "for quadrant recombination, place each quadrant at its original bounding box location within the parent object/grid"
      ],
      "used_in": [
        "7c008303"
      ]
    },
    "is_inside_container criteria": {
      "name": "is_inside_container criteria",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to test for being inside the container"
        },
        {
          "name": "container",
          "typing": "object",
          "description": "the container object (e.g., boundary) to check against"
        }
      ],
      "description": "condition on whether an object is fully enclosed within a specified container object (e.g., a boundary)",
      "cues": [
        "if regions in the output grid are recolored only if they are fully surrounded by a boundary of a specific color",
        "if the output grid colors interior regions differently from exterior or touching-the-boundary regions",
        "if the input grid contains colored outlines or boundaries enclosing empty or black regions",
        "if the solution logic distinguishes between regions that touch the boundary and those that do not"
      ],
      "implementation": [
        "for each candidate region, check that none of its pixels touch or overlap the container's boundary pixels",
        "can use flood fill from the boundary to mark reachable regions, then select regions not reachable from the boundary as \"inside\"",
        "verify that all pixels of the region are strictly within the boundary (not touching or overlapping)"
      ],
      "used_in": [
        "00d62c1b"
      ]
    },
    "cup opening": {
      "name": "cup opening",
      "kind": "structure",
      "routine_subtype": null,
      "output_typing": null,
      "parameters": [],
      "description": "the set of pixels on the boundary of a container object that are not enclosed, forming the \"opening\" through which filling or extension occurs",
      "cues": [
        "if lines or features are drawn from a contiguous edge of a container object",
        "if the output grid extends features from a gap in a closed region"
      ],
      "implementation": [],
      "used_in": [
        "d4f3cd78"
      ]
    },
    "find direction from opening": {
      "name": "find direction from opening",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "direction",
      "parameters": [
        {
          "name": "cup_interior",
          "typing": "object",
          "description": "the interior region of the cup (the area to be filled)"
        },
        {
          "name": "cup_opening",
          "typing": "list[object]",
          "description": "the set of opening pixels on the cup's boundary"
        }
      ],
      "description": "determine the cardinal direction(s) from the opening pixels that lead outside the cup, often used to guide line drawing or pattern extension from the opening",
      "cues": [
        "if lines or features are drawn outward from the opening of a container or cup shape in the output grid",
        "if the output grid extends features from a gap or opening in a closed region"
      ],
      "implementation": [
        "for each opening pixel, check the four cardinal directions; the direction(s) that immediately leave the cup's interior are considered outward",
        "if all opening pixels are contiguous and aligned, the direction can be inferred from their arrangement (e.g., all at the top edge implies \"up\")"
      ],
      "used_in": [
        "d4f3cd78"
      ]
    },
    "is shape square": {
      "name": "is shape square",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to check for being a square"
        }
      ],
      "description": "condition on whether an object has equal height and width (i.e., is a square)",
      "cues": [
        "if only square-shaped regions or holes are treated differently in the output grid",
        "if output grid fills or recolors only square-shaped holes or objects"
      ],
      "implementation": [
        "check if the object's bounding box has equal height and width",
        "can use the object's shape or dimensions attribute for comparison"
      ],
      "used_in": [
        "44d8ac46"
      ]
    },
    "obstacle avoidance path": {
      "name": "obstacle avoidance path",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "list[position]",
      "parameters": [
        {
          "name": "start",
          "typing": "position",
          "description": "the starting position for the path"
        },
        {
          "name": "direction",
          "typing": "direction",
          "description": "the primary direction to move (e.g., \"up\")"
        },
        {
          "name": "avoid_color",
          "typing": "color",
          "description": "the color to avoid (e.g., gray)"
        },
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to navigate"
        },
        {
          "name": "alternate_direction",
          "typing": "direction",
          "description": "the direction to move when an obstacle is encountered (e.g., \"right\")"
        }
      ],
      "description": "compute a path from a starting position in a primary direction, but when a pixel of avoid_color is encountered, move in an alternate direction before resuming the primary direction",
      "cues": [
        "if output lines or paths \"bend\" or \"step aside\" to avoid obstacles of a specific color",
        "if lines are not straight but deviate around colored regions or pixels",
        "if output features follow a path that detours around obstacles in the input grid"
      ],
      "implementation": [
        "at each step, check if the next position in the primary direction is blocked by avoid_color; if so, move in the alternate direction instead, then resume",
        "can be implemented as a loop that updates the position according to the rules, recording each step"
      ],
      "used_in": [
        "d9f24cd1"
      ]
    },
    "all_nonblack_pixels": {
      "name": "all_nonblack_pixels",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "list[object]",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to extract non-black pixels from"
        }
      ],
      "description": "extract all pixel objects in a grid that are not black (background)",
      "cues": [
        "if the output grid is cropped tightly around all colored content, ignoring black/background pixels",
        "if the solution logic needs to find all non-background pixels for cropping or further processing"
      ],
      "implementation": [
        "for each pixel in the grid, include it if its color is not black (0)",
        "can use np.argwhere(grid != 0) to get positions"
      ],
      "used_in": [
        "137eaa0f"
      ]
    },
    "indicator color": {
      "name": "indicator color",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "color",
      "parameters": [
        {
          "name": "objects",
          "typing": "list[object]",
          "description": "the list of objects to analyze"
        }
      ],
      "description": "find the color that is present in every object in a list, typically used as an indicator or anchor for alignment",
      "cues": [
        "if all objects in the input grid contain a single common color, often in the same relative position",
        "if a color is used as a marker or anchor for alignment or transformation across multiple objects"
      ],
      "implementation": [
        "for each object's color set, compute the intersection across all objects to find the common color",
        "use set intersection on the list of color sets from each object"
      ],
      "used_in": [
        "57aa92db"
      ]
    },
    "indicator region size": {
      "name": "indicator region size",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "int",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object to analyze"
        },
        {
          "name": "indicator_color",
          "typing": "color",
          "description": "the color used as the indicator"
        }
      ],
      "description": "compute the size (number of pixels) of the region within an object that has the indicator color",
      "cues": [
        "if the scale of an overlay or transformation is determined by the size of a colored region within each object",
        "if indicator regions are used for alignment or scaling"
      ],
      "implementation": [
        "count the number of pixels in the object that are equal to the indicator color"
      ],
      "used_in": [
        "57aa92db"
      ]
    },
    "position": {
      "name": "position",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "position",
      "parameters": [
        {
          "name": "object",
          "typing": "object",
          "description": "the object or grid to search in"
        },
        {
          "name": "color",
          "typing": "color",
          "description": "the color whose position to find"
        }
      ],
      "description": "get the position (or anchor) of a pixel of the specified color in an object, typically used for alignment",
      "cues": [
        "if alignment or overlaying is performed based on matching colored pixels between objects",
        "if a colored pixel serves as an anchor for transformation"
      ],
      "implementation": [
        "find the coordinates of the pixel(s) in the object that match the specified color",
        "if multiple, select the first or use the mean position as needed"
      ],
      "used_in": [
        "57aa92db"
      ]
    },
    "is_touching": {
      "name": "is_touching",
      "kind": "routine",
      "routine_subtype": "selection criteria",
      "output_typing": "bool",
      "parameters": [
        {
          "name": "target",
          "typing": "object",
          "description": "the object to check for touching another object"
        },
        {
          "name": "other",
          "typing": "object",
          "description": "the object to check contact with"
        }
      ],
      "description": "condition on whether an object is in contact with another object, i.e. they share a pixel or edge",
      "cues": [
        "if the output grid shows an object mirrored or transformed to cover another object that is adjacent to it",
        "if the logic depends on detecting adjacency/contact between two objects for further transformation"
      ],
      "implementation": [
        "check if any pixel of the target object is adjacent (4- or 8-connected) to any pixel of the other object"
      ],
      "used_in": [
        "2bcee788"
      ]
    },
    "axis_perpendicular_to": {
      "name": "axis_perpendicular_to",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "axis",
      "parameters": [
        {
          "name": "direction",
          "typing": "direction",
          "description": "the direction to find the perpendicular axis to"
        }
      ],
      "description": "returns the axis (horizontal or vertical) perpendicular to the given direction",
      "cues": [
        "if mirroring or reflection is performed across an axis perpendicular to a direction of adjacency/contact"
      ],
      "implementation": [
        "for \"left\" or \"right\", return \"vertical\"; for \"up\" or \"down\", return \"horizontal\""
      ],
      "used_in": [
        "2bcee788"
      ]
    },
    "scale grid": {
      "name": "scale grid",
      "kind": "routine",
      "routine_subtype": "grid manipulation",
      "output_typing": "grid",
      "parameters": [
        {
          "name": "grid",
          "typing": "grid",
          "description": "the grid to scale"
        },
        {
          "name": "scale",
          "typing": "int | tuple[int, int]",
          "description": "the scaling factor to apply (uniform or per axis)"
        }
      ],
      "description": "scale an entire grid by a given factor, enlarging or shrinking it proportionally along one or both axes",
      "cues": [
        "if the entire output grid is a scaled-up or scaled-down version of the input grid or an intermediate result",
        "if the output grid is a larger version of the input, preserving the arrangement of features"
      ],
      "implementation": [
        "use numpy.kron or repeat to scale the grid",
        "for non-uniform scaling, repeat rows and columns separately"
      ],
      "used_in": [
        "46f33fce"
      ]
    },
    "adjusted position": {
      "name": "adjusted position",
      "kind": "routine",
      "routine_subtype": "intermediate",
      "output_typing": "position",
      "parameters": [
        {
          "name": "position",
          "typing": "position",
          "description": "the original position to adjust"
        },
        {
          "name": "scale",
          "typing": "int | tuple[int, int]",
          "description": "the scaling factor applied to the position"
        },
        {
          "name": "anchor",
          "typing": "Literal[\"upper left\", \"center\", \"custom\"]",
          "description": "how to align the scaled object relative to the original position"
        }
      ],
      "description": "compute the anchor position for placing a scaled object so that its intended reference point (e.g., upper left) matches the scaled position",
      "cues": [
        "if scaled objects must be placed so that their upper left corner aligns with the scaled position of the original pixel",
        "if the placement of scaled objects depends on the scaling factor and anchor alignment"
      ],
      "implementation": [
        "for \"upper left\" anchor, multiply the original position by the scale factor",
        "for \"center\" anchor, adjust by half the scaled size minus half the original size"
      ],
      "used_in": [
        "46f33fce"
      ]
    }
  },
  "solutions": {
    "776ffc46": {
      "problem_id": "776ffc46",
      "solution": null,
      "summary": "mark a guide object (inside a container) and recolor objects that match the guide's shape",
      "pseudocode": "objects = extract_objects(input_grid, single_color=true, connectivity=4)\nguides = filter_objects(objects, criteria=is_inside_container)\nfor object in objects:\n  # recolor object if its shape matches any guide's shape\n  if any(shape_match(object, guide) for guide in guides):\n    output_grid = recolor(object, guide.color)\n"
    },
    "0d3d703e": {
      "problem_id": "0d3d703e",
      "solution": null,
      "summary": "recolor with fixed mapping",
      "pseudocode": "# fixed color mapping\ncolor_scheme = {\n  \"red\": \"blue\",\n  ...\n}\nfor pixel in grid:\n  output_grid, _ = recolor(pixel, color_scheme=color_scheme)\n"
    },
    "cf98881b": {
      "problem_id": "cf98881b",
      "solution": null,
      "summary": "split regions and overlay in left to right order",
      "pseudocode": "# 3 regions organized left to right (vertical dividers)\nregions = split_regions(input, splitting_scheme=split_on_dividers)\n# layer regions in right to left order (i.e. left region on top)\noutput = regions[-1]\nfor region in reversed(regions[:-1]):\n  output = draw_object(region, output)\n"
    },
    "228f6490": {
      "problem_id": "228f6490",
      "solution": null,
      "summary": "move objects into other objects' holes if the object shape matches the hole shape",
      "pseudocode": "objects = extract_objects(input_grid, single_color=true, connectivity=4)\nguides = filter_objects(objects, criteria=is_color(grey))\nholes = [get_holes(guide) for guide in guides]\nfor object in objects - guides:\n  # move object into hole if its shape matches the hole shape\n  if any(shape_match(object, hole) for hole in holes):\n    output_grid = move_object(object, hole.position)\n"
    },
    "4093f84a": {
      "problem_id": "4093f84a",
      "solution": null,
      "summary": "slide objects towards a grey object, recoloring them to grey",
      "pseudocode": "objects = extract_objects(input_grid, single_color=true, connectivity=4)\ngrey_obj = find_object(objects, criteria=is_color(grey))\nother_objects = filter_objects(objects, criteria=not(is_color(grey)))\nfor object in other_objects:\n  direction = direction_between(object, grey_obj)\n  output = slide(object, direction, stopping_criteria=movement_collision)\n  output = recolor(object, grey)\n"
    },
    "9f236235": {
      "problem_id": "9f236235",
      "solution": null,
      "summary": "split grid into grid of regions, create a new grid with pixel corresponding to each region, and reflect the grid",
      "pseudocode": "# input grid organized in a \"meta grid\" of regions\ndivider_lines = find_divider_lines(input_grid)\nregion_grid = split_regions(input_grid, splitting_scheme=divider_line_grid)\n# convert each region to a pixel in a new grid\noutput_grid = convert_region_grid_to_pixel_grid(\n  region_grid, \n  color_selection=pick_only_color_from_region\n)\noutput_grid = reflect_grid(output_grid, axis=vertical)\n"
    },
    "e21d9049": {
      "problem_id": "e21d9049",
      "solution": null,
      "summary": "extend each arm of a cross object by tiling the horizontal and vertical bars in all four directions",
      "pseudocode": "# extract cross object\nobjects = extract_objects(input_grid, single_color=false, connectivity=4)\ncross = objects[0]\n# split cross into horizontal and vertical bars\nhorizontal_bar, vertical_bar = split_object(cross, object_splitting_scheme=split_cross)\n# replicate each bar to extend it in all four directions\noutput_grid = tile_object(horizontal_bar, start=horizontal_bar.rightmost + 1, direction=right, gap=0)\noutput_grid = tile_object(horizontal_bar, start=horizontal_bar.leftmost - horizontal_bar.width - 1, direction=left, gap=0)\noutput_grid = tile_object(vertical_bar, start=vertical_bar.bottommost + 1, direction=down, gap=0)\noutput_grid = tile_object(vertical_bar, start=vertical_bar.topmost - vertical_bar.height - 1, direction=up, gap=0)\n"
    },
    "ff28f65a": {
      "problem_id": "ff28f65a",
      "solution": null,
      "summary": "create a blue checkerboard pattern with blue number of blue squares = count of objects in the input grid",
      "pseudocode": "# count number of objects in the input grid\nobjects = extract_objects(input_grid, single_color=true, connectivity=4)\nnum_objects = len(objects)\nnew_grid = create_new_grid(dimensions=(3, 3))\n# draw a checkerboard pattern with number of squares equal to earlier count\noutput_grid = draw_expandable_shape(pattern=\"checkerboard\", color=blue, scale=num_objects, grid=new_grid)\n"
    },
    "1b60fb0c": {
      "problem_id": "1b60fb0c",
      "solution": null,
      "summary": "complete the rotational symmetry and recolor the new section red",
      "pseudocode": "# input grid contains an object that's almost rotationally symmetric\nobjects = extract_objects(input_grid, single_color=true, connectivity=8)\nsprite = object[0]\n# complete the symmetry by rotating the sprite and adding it to the grid\nrotated_sprite = rotate_object(sprite, angle=90)\noutput_grid = draw_object(rotated_sprite, base=input_grid, position=sprite.position)\n# recolor the new section red\nnew_section = filter_objects(output_grid_pixels, criteria=new_pixels(old=input_grid))\noutput_grid = recolor_object(new_section, color=red)\n"
    },
    "3e980e27": {
      "problem_id": "3e980e27",
      "solution": null,
      "summary": "copy guide objects to anchors with colors matching the guide colors and flipping the guide objet if the indicator is red",
      "pseudocode": "extracted_objects = extract_objects(input_grid, single_color=false, connectivity=8)\nguides = filter_objects(extracted_objects, criteria=size_criteria(\"> 1\"))\nanchors = filter_objects(extracted_objects, criteria=size_criteria(\"== 1\"))\noutput_grid = input_grid\nfor anchor in anchors:\n  guide = find_object(guides, criteria=has_color(anchor.color))\n  if has_color(anchor, red):\n    guide = reflect_object(guide, axis=\"x=6\")\n  # draw the guide to align with or complete the anchor object\n  alignment_pos = get_aligment_pos(full_sprite=guide, partial_sprite=anchor)\n  output_grid = draw_object(guide, base=output_grid, position=alignment_pos)\n"
    },
    "48d8fb45": {
      "problem_id": "48d8fb45",
      "solution": null,
      "summary": "crop the object that is touching a grey guide object",
      "pseudocode": "objects = extract_objects(input_grid, single_color=true, connectivity=8)\nguide = find_object(objects, criteria=is_color(grey))\nselected = find_object(objects, criteria=is_touching(guide))\noutput_grid = crop_around_objects(selected)\n"
    },
    "6cdd2623": {
      "problem_id": "6cdd2623",
      "solution": null,
      "summary": "draw lines between same color pixels on opposite edges",
      "pseudocode": "# find color that has all pixels on the edge of the grid\nfor color in unique_colors(input_grid):\n  color_subset = filter_objects(input_grid_pixels, criteria=has_color(color))\n  if all(on_edge(candidate=pixel, parent=input_grid) for pixel in color_subset):\n    break\n# draw connecting lines between selected pixels on opposite edges\nfor pixel in color_edge_subset:\n  for other_pixel in color_edge_subset:\n    if pixel != other_pixel and is_aligned(pixel, other_pixel):\n      output_grid = draw_line(pixel, other_pixel, color=color)\n"
    },
    "4258a5f9": {
      "problem_id": "4258a5f9",
      "solution": null,
      "summary": "surround each grey pixel with a blue border",
      "pseudocode": "# draw border around individual grey pixels by drawing the 3x3 over them and then recoloring the center pixel\nfor pixel in input_grid:\n  if pixel.color == gray:\n    output_grid = draw_object(\n      sprite=blue_square_3x3, \n      base=output_grid, \n      position=pixel.position\n    )\nfor pixel in input_grid:\n  if pixel.color == gray:\n    output_grid[pixel.position] = gray\n"
    },
    "8403a5d5": {
      "problem_id": "8403a5d5",
      "solution": null,
      "summary": "starting from the input grid pixel, draw a zigzag pattern of vertical lines to the right",
      "pseudocode": "# get single input grid pixel\nobjects = extract_objects(input_grid, single_color=true, connectivity=4)\npixel = objects[0]\n# draw a repeating pattern of vertical line, then single grey pixel at the top/bottom (alternating)\n# start pattern at input pixel, then extend it to the right\npattern = create_new_grid(dimensions=(input_grid.height, 4))\ndraw_line(grid=pattern, start=(0, 0), direction=down, color=pixel.color)\ndraw_object(grid=pattern, object=pixel, position=(0, 1), color=grey)\ndraw_line(grid=pattern, start=(0, 2), direction=down, color=pixel.color)\ndraw_object(grid=pattern, object=pixel, position=(pattern.height - 1, 3), color=grey)\noutput_grid = tile_object(pattern, start=pixel.position, direction=right, gap=0)\n"
    }
  },
  "custom_types": {
    "direction": "Literal[\"up\", \"down\", \"left\", \"right\"]",
    "dimensions": "tuple[int, int]",
    "axis": "Literal[\"x\", \"y\", \"both\", \"horizontal\", \"vertical\"] | int | float | tuple[axis, int | float]",
    "pattern": "str | Callable[[int], grid]",
    "symmetry": "Callable[[position], position]",
    "shape": "Any",
    "list[symmetry": "Callable[[position], position]]"
  }
}